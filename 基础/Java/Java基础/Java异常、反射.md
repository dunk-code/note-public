

# Java异常分类即处理

## 异常概念

异常指方法在不能按照正常方式完成时，可以通过抛出异常的方式退出该方法，在异常中封装了方法执行过程中的错误信息即原因，调用方在获取该异常后可根据业务的情况选择处理该异常或者继续抛出该异常

在方法在执行过程中出现异常时，Java异常处理机制会将代码的执行权交给异常处理器，异常处理器根据在系统中定义的异常处理规则执行不同的异常处理逻辑（抛出异常或者捕捉并处理异常）

## 异常的分类

Java中,`Throwable`是所有错误或异常的父类，`Throwable`又可分为Error和Exception，常见的Error有`AWTError`、`ThreadDeath`，Exception又分为`RuntimeException`和`CheckedException`

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210612104022.png" alt="image-20210612104014494" style="zoom: 80%;" />



- Error是指Java运行错误，如果程序在启动时出现Error，则启动失败，如果运行过程中出现Error，则系统将退出进程，出现Error通常是因为系统内部错误或者资源耗尽，Error不能被在运行时动态处理。如果程序出现Error，则系统能做的工作只有记录错误的成因和安全终止
- Exception指Java程序运行异常，即运行中的程序发生了人们不期望发生的事件，可以被Java异常处理机制处理，Exception也是程序开发中异常处理的核心，可以分
  - `RuntimeException`：指在Java虚拟机正常运行期间抛出的异常，`RuntimeException`可以被捕获并处理，如果出现`RuntimeException`异常，那么一定是程序发生错误导致的，我们通常需要抛出异常或者捕获并处理异常，常见的运行时异常有`NullPointerException`、`ClassCastException`、`ArrayIndexOutOfBundsException`等
  - `CheckedException`：是指在编译阶段Java编译器会检查`CheckedException`异常，并强制程序捕获和处理此类异常，即要求程序在可能出现异常的地方通过try catch语句块捕获并处理异常。常见的`CheckedException`有由于I/O错误引起的`IOException`、`SQLException`、`ClassNotFoundException`、 `FileNotFoundException`，该异常一般由于打开错误文件、SQL语法错误、类不存在等引起

### 异常的选择

是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就是用受检异常，否则选择非受检异常，一般来讲，如果没有特殊的要求，我们建议使用`RuntimeException`异常

## 异常处理方式

> 异常处理方式有抛出异常和使用try catch语句块捕获并处理异常

- 抛出异常：遇到异常时不进行具体处理，而是将异常抛给调用者，有调用者根据情况处理。有可能直接捕获并处理，也有可能继续向上层抛出异常。抛出异常有三种方式：throws、throw、系统自动抛出异常
  - throws作用在方法上，用于定义方法可能抛出的异常
  - throw作用在方法内，表示明确抛出一个异常
- try catch捕获并处理异常：使用try catch捕获异常能够有针对性的处理每种可能遇到的异常，并在捕获到异常后根据不同的情况做不同的处理

|          | throw                                                        | throws                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 位置不同 | 方法内，后面跟的是异常对象                                   | 方法上，后面跟的是异常类（相当于可以抛出多个异常）           |
| 功能不同 | 抛出封装了异常信息的对象，程序执行到throw，后续代码将不会执行，而是跳转到调用者，并将异常信息抛给调用者（finally内的语句除外） | 声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型，预先声明不同的处理方式 |

## 受检异常和非受检异常

### 受检异常

编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。**除 `RuntimeException` 及其子类外，其他的 Exception 异常都属于受检异常**。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过

### 非受检异常

编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。**该类异常包括运行时异常（`RuntimeException`极其子类）和错误（Error）**

## [扩展问题](https://thinkwon.blog.csdn.net/article/details/104390689)

### JVM是如何处理异常的？

在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈

JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序

### try-catch-finally 中哪个部分可以省略？

> catch可以省略

更为严格的说法其实是：try只适合处理运行时异常，try + catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略

###  try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

> 会执行，在return前面执行

在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不立马返回调用者，而是记录下返回值待finally代码执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值，显然，在finally中返回或者修改返回值会对程序造成很大的困扰

```java
public static int getInt() {
    int a = 10;
    try {
        System.out.println(a / 0);
        a = 20;
    } catch (ArithmeticException e) {
        a = 30;
        return a;
        /*
         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
         */
    } finally {
        a = 40;
    }
	return a;
}

执行结果：30
```



```java
public static int getInt() {
    int a = 10;
    try {
        System.out.println(a / 0);
        a = 20;
    } catch (ArithmeticException e) {
        a = 30;
        return a;
    } finally {
        a = 40;
        //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40
        return a; 
    }

}

执行结果：40
```

# 反射机制

## 动态语言的概念

动态语言指程序运行时可以改变其结构，比如新的属性或方法的添加、删除的等结构上的变化。JavaScript、Ruby、Python等都属于动态语言；C、C++不属于动态语言，从反射的角度来书，Java属于半动态语言

## 反射机制的概念

反射机制指程序运行过程中，对任意一个类都能获取其所有属性和方法，并对任意一个对象都能调用其任意一个方法，这种动态获取类和对象的信息，以及动态调用对象方法的功能被称为Java语言的反射机制

> 缺点：破坏了封装性以及泛型约束，反射是框架的核心，Spring大量使用反射

### 反射的应用

Java中的对象有两种类型：编译时类型和运行时类型

- 编译时类型指在声明对象时所采用的类型 如persion
- 运行时类型指为对象赋值时所采用的类型 如Student

```java
Person persion = new Student()
```

因此，程序在编译期间时无法预知该对象的真实信息，只能通过运行时信息来发现该对象和类的真实信息，而其真实信息（对象的属性和方法）通常反射机制来获取。

### 反射API

Java反射API主要用于运行过程中动态生成类、接口或对象信息

- Class类：用于获取类的属性、方法信息
- Field类：用于获取类的成员变量，用于获取和设置类中的属性值
- Method类：用于获取类的方法，用于获取方法的描述信息或者执行某个方法
- Constructor类：表示类的构造方法

### 反射机制优缺点

- 优点：运行期类型判断，动态加载类是，提高代码的灵活度
- 缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的Java代码要慢很多

### class类的作用，如何获取一个Class对象

在程序运行期间，Java运行时系统为所有对象维护了一个运行时类型标识，这个信息会跟踪每个对象所述的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是Class没这事一个泛型类

获取Class对象

- `类名.class`
- `对象.getClass()`
- `Class.forName(类的全限定名)`

### 反射机制的应用场景

> 反射是框架设计的灵魂

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制

举例

- 我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序
- Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：
  - 将程序内所有 XML 或 Properties 配置文件加载入内存中
  - Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 
  - 使用反射机制，根据这个字符串获得某个类的Class实例
  - 动态配置实例的属性