[Java面试题1](https://thinkwon.blog.csdn.net/article/details/104390612)

[java面试题2](https://www.nowcoder.com/discuss/447742?channel=-1&source_id=profile_follow_post_nctrack)



[TOC]

# 面向对象

## 面向对象和面向过程的区别

- 面向过程：具体化的，流程化的，解决一个问题，你需要一步一步分析，一步一步实现
  - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素
  - 缺点：没有面向对象易维护、易复用、易扩展
- 面向对象：模型化的，你只需要抽出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的
  - 优点：：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
  - 缺点：性能比面向过程低

## 三大特性

抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面，抽象只关注对象有哪些属性和行为，并不关注这些行为的细节

### 封装

是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护

迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter/setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private

### 继承

用来扩展一个类，子类可继承父类的部分属性和行为使模块具有服用性，继承是“is-a”的关系，可使用里氏替换原则判断是够满足“is-a”的关系，即任何父类出现的地方子类都可以出现。。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则

### 多态

以封装和继承为基础，根据运行时对象实际类型使同以行为具有不同表现形式，多态指在编译层面无法确定最终调用的方法体，在运行期由JVM动态绑定，适合合适的重写方法，由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写

## 重载与重写

### 重载

**重载**指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。对编译器来说，方法名称和参数列表组成了一个唯一键，称为方法签名，JVM 通过方法签名决定调用哪种重载方法。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法，因此属于静态绑定

JVM 在重载方法中选择合适方法的顺序：① 精确匹配。② 基本数据类型自动转换成更大表示范围。③ 自动拆箱与装箱。④ 子类向上转型。⑤ 可变参数

### 重写

**重写**指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现

元空间有一个方法表保存方法信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实现。父类引用执行子类方法时无法调用子类存在而父类不存在的方法。

重写方法访问权限不能变小，返回类型和抛出的异常类型不能变大，必须加 `@Override`

## 类之间的关系

| 类关系 |              描述              | 权力强侧 |               举例               |
| :----: | :----------------------------: | :------: | :------------------------------: |
|  继承  |     父子类之间的关系：is-a     |   父类   |          小狗继承于动物          |
|  实现  | 接口和实现类之间的关系：can-do |   接口   |        小狗实现了狗叫接口        |
|  组合  |  比聚合更强的关系：contains-a  |   整体   |         头是身体的一部分         |
|  聚合  |     暂时组装的关系：has-a      |  组装方  |    小狗和绳子是暂时的聚合关系    |
|  依赖  |  一个类用到另一个：depends-a   | 被依赖方 |      人养小狗，人依赖于小狗      |
|  关联  |    平等的使用关系：links-a     |   平等   | 人使用卡消费，卡可以提取人的信息 |

## 访问权限控制符

| 访问权限控制符 | 本类 | 包内 | 包外子类 | 任何地方 |
| :------------: | :--: | :--: | :------: | :------: |
|     public     |  √   |  √   |    √     |    √     |
|   protected    |  √   |  √   |    √     |    ×     |
|       无       |  √   |  √   |    ×     |    ×     |
|    private     |  √   |  ×   |    ×     |    ×     |

# 语言特性

## Java语言的优点

- 平台无关性，摆脱硬件束缚，一次编写，导出运行
- 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界
- 热点代码检测和运行时编译及优化，使程序随时间运行增长获得更高的性能
- 完善的应用程序接口，支持第三方类库

## Java如何实现平台无关？

JVM：java编译器可生成与计算机体系结构无关的字节码指令，字节码指令不仅可以轻易的在任何机器上解释执行，还可以动态地转换为本地机器代码，转换是由JVM实现的，JVM是平台相关的，屏蔽了不同操作系统的差异

语言规范：基本数据类型有明确的规定，例如int永远为32位，而C/C++中可能是16位、32位，也可能是编译器开发商指定的其他大小，Java中数值类型有固定的字节数，二进制格式存储和传输，字符串采用标准的Unicode格式存储

## JDK和JRE的区别

JDK：Java Development Kit，开发工具包。提供了编译运行Java程序的各种工具，包括编译器（javac.exe）、JRE以及打包工具（jar.exe），是Java的核心

JRE：Java Runtime Environment，运行时环境，运行Java程序所必须的环境，包括JVM、核心类库、核心配置工具

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210612162823.png" alt="img" style="zoom:80%;" />

### Java是按值调用还是引用调用

- 按值传递：是指接受调用者提供的值
- 按引用调用：是指方法接受调用者提供的变量地址

Java总是按值调用，方法得到的所有参数的副本，传递对象时实际上方法接受的是对象引用的副本。方法不能修改基本数据类型的参数，如果传递了一个int值，改变值不会影响实参，因为改变的是值的一个副本

可以改变对象参数的状态，但不能让对象参数引用一个新的对象，如果传递了一个int数组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象

## 浅拷贝和深拷贝的区别

- 浅拷贝：只复制当前对象的基本数据类型即引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全
- 深拷贝：完全拷贝基本数据类型和应用数据类型，安全

# 序列化

Java 对象 JVM 退出时会全部销毁，如果需要将对象及状态持久化，就要通过序列化实现，将内存中的对象保存在二进制流中，需要时再将二进制流反序列化为对象。==对象序列化保存的是对象的状态，因此属于类属性的静态变量不会被序列化==

## 常见的序列化方式

### Java 原生序列化

实现 `Serializabale` 标记接口，Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息）以及对象数据，兼容性最好，但不支持跨语言，性能一般。序列化和反序列化必须保持序列化 ID 的一致，一般使用 `private static final long serialVersionUID` 定义序列化 ID，如果不设置编译器会根据类的内部实现自动生成该值。如果是兼容升级不应该修改序列化 ID，防止出错，如果是不兼容升级则需要修改

### Hessian 序列化

Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。Java 对象序列化的二进制流可以被其它语言反序列化。Hessian 协议的特性：① 自描述序列化类型，不依赖外部描述文件，用一个字节表示常用基础类型，极大缩短二进制流。② 语言无关，支持脚本语言。③ 协议简单，比 Java 原生序列化高效。Hessian 会把复杂对象所有属性存储在一个 Map 中序列化，当父类和子类存在同名成员变量时会先序列化子类再序列化父类，因此子类值会被父类覆盖

### JSON 序列化

JSON 序列化就是将数据对象转换为 JSON 字符串，在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确进行。相比前两种方式可读性更好，方便调试

>序列化通常会使用网络传输对象，而对象中往往有敏感数据，容易遭受攻击，Jackson 和 fastjson 等都出现过反序列化漏洞，因此不需要进行序列化的敏感属性传输时应加上 transient 关键字。transient 的作用就是把变量生命周期仅限于内存而不会写到磁盘里持久化，变量会被设为对应数据类型的零值

# 常问方法和类

## Object 类有哪些方法？

**equals：**检测对象是否相等，默认使用 `==` 比较对象引用，可以重写 equals 方法自定义比较规则。equals 方法规范：自反性、对称性、传递性、一致性、对于任何非空引用 x，`x.equals(null)` 返回 false

**hashCode：**散列码是由对象导出的一个整型值，没有规律，每个对象都有默认散列码，值由对象存储地址得出。字符串散列码由内容导出，值可能相同。为了在集合中正确使用，一般需要同时重写 equals 和 hashCode，要求 equals 相同 hashCode 必须相同，hashCode 相同 equals 未必相同，因此 hashCode 是对象相等的必要不充分条件

**toString**：打印对象时默认的方法，如果没有重写打印的是表示对象值的一个字符串

**clone：**clone 方法声明为 protected，类只能通过该方法克隆它自己的对象，如果希望其他类也能调用该方法必须定义该方法为 public。如果一个对象的类没有实现 Cloneable 接口，该对象调用 clone 方***抛出一个 CloneNotSupport 异常。默认的 clone 方法是浅拷贝，一般重写 clone 方法需要实现 Cloneable 接口并指定访问修饰符为 public

**finalize：**确定一个对象死亡至少要经过两次标记，如果对象在可达性分析后发现没有与 GC Roots 连接的引用链会被第一次标记，随后进行一次筛选，条件是对象是否有必要执行 finalize 方法。假如对象没有重写该方法或方法已被虚拟机调用，都视为没有必要执行。如果有必要执行，对象会被放置在 F-Queue 队列，由一条低调度优先级的 Finalizer 线程去执行。虚拟机会触发该方法但不保证会结束，这是为了防止某个对象的 finalize 方法执行缓慢或发生死循环。只要对象在 finalize 方法中重新与引用链上的对象建立关联就会在第二次标记时被移出回收集合。由于运行代价高昂且无法保证调用顺序，在 JDK 9 被标记为过时方法，并不适合释放资源

**getClass：**返回包含对象信息的类对象。

**wait / notify / notifyAll：**阻塞或唤醒持有该对象锁的线程

## hashCode与equals的

HashSet如何检查重复，两个对象的hashCode()相同，则equals()也一定为true

### hashCode()介绍

hashCode()的作用是获取哈希吗，也称为散列码；它实际上是返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object类中，这就意味着Java中任何类都包含hashCode()函数

散列表存储的是键值对（key-value），它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

### 为什么要有hashCode()

**我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode**：

当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashCode值的对象，这时会调用 equals()方法来检查 hashCode相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置

### hashCode()与equals()的相关规定

如果两个对象相等，则hashcode一定相等

两个对象相等，对两个对象分别调用equals返回都是true

两个对象有相同的hashcode值，但是他们不一定相等

> 因此，equals()方法被覆盖，则hashCode()值也必须被覆盖

hashCode()默认行为是对堆上的对象产生独特的值，如果没有重写hashCode()，则该class两个对象，无论如何都不会相等（即使这两个对象指向相同的数据）

#### 对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等

### ==和equals？

- **==**：它的作用是判断两个对象的地址是不是相等的，即，判断两个对象是不是同一个对象（基本的数据类型**==**比较的是值，引用数据类型**==**比较的是内存地址）
- **equals()**：它的作用也是判断两个对象是否相等。但它一般有两种使用情况
  - 类没有覆盖equals()方法，则通过equals()比较该类的两个对象时，等价通过**==**比较这两个对象
  - 类覆盖了**equals()**方法，一般，我们都覆盖**equals()**放方法来判断两个对象内容是否相等，若他们的内容相等，则返回true

注意：String中的equals方法是被重写过的，因为Object的equals方法比较的对象的内存地址，而String的equals方法比较的是对象的值

当创建String类型的对象时，虚拟机会在常量池中查找有么有已经存在的值和要创建的值相同的对象，如果有就把它赋值给当前引用，如果没有就在常量池中创建一个String对象

### 自定义对象只实现 equals() 而不实现 hashcode() 会有什么问题

两个对象相等的情况下，hashcode()值不同

# 数据类型

## java的基本数据类型

| 数据类型 |            内存大小            |  默认值  |          取值范围           |
| :------: | :----------------------------: | :------: | :-------------------------: |
|   byte   |               1B               | (byte)0  |         -128 ~ 127          |
|  short   |               2B               | (short)0 |      -2^15^ ~ 2^15^-1       |
|   int    |               4B               |    0     |      -2^31^ ~ 2^31^-1       |
|   long   |               8B               |    0L    |      -2^63^ ~ 2^63^-1       |
|  float   |               4B               |   0.0F   | ±3.4E+38（有效位数 6~7 位） |
|  double  |               8B               |   0.0D   | ±1.7E+308（有效位数 15 位） |
|   char   | 英文1B，中文UTF-8占3B，GBK占2B | '\u0000' |     '\u0000' ~ '\uFFFF'     |
| boolean  |       单个变量4B/数组1B        |  false   |         true、false         |

> JVM没有boolean赋值的专用字节码指令，`boolean f = false` 就是使用 ICONST_0 即常数 0 赋值。单个 boolean 变量用 int 代替，boolean 数组会编码成 byte 数组

## 包装类

每个基本数据类型都对应一个包装类，除了int和char对应Integer和Character外，其余基本数据类型的包装类都是首字母大写

- 自动装箱：将基本类型用它们对应的引用类型包装起来

- 自动拆箱：将包装类型转换为基本数据类型

### int和Integer区别

Java是一个近乎纯洁的面向对象的编程语言，但是为了编程方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当做对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class）），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换

### Java 为每个原始类型提供了包装类型：

原始类型: boolean，char，byte，short，int，long，float，double

包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

### Integer a = 127和Integer b = 127相等吗

对于对象引用类型：==比较的是对象的内存地址。
对于基本数据类型：==比较的是值

如果整型字面量的值在**-128到127之间**，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false

```java
public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;  // 将3自动装箱成Integer类型
    int c = 3;
    System.out.println(a == b); // false 两个引用没有引用同一对象
    System.out.println(a == c); // true a自动拆箱成int类型再和c比较
    System.out.println(b == c); // true

    Integer a1 = 128;
    Integer b1 = 128;
    System.out.println(a1 == b1); // false

    Integer a2 = 127;
    Integer b2 = 127;
    System.out.println(a2 == b2); // true
}
```

## String

### 字符串拼接的方式有哪些

- 直接用 `+` ，底层用 StringBuilder 实现。只适用小数量，如果在循环中使用 `+` 拼接，相当于不断创建新的 StringBuilder 对象再转换成 String 对象，效率极差
- 使用 String 的 concat 方法，该方法中使用 `Arrays.copyOf` 创建一个新的字符数组 buf 并将当前字符串 value 数组的值拷贝到 buf 中，buf 长度 = 当前字符串长度 + 拼接字符串长度。之后调用 `getChars` 方法使用 `System.arraycopy` 将拼接字符串的值也拷贝到 buf 数组，最后用 buf 作为构造参数 new 一个新的 String 对象返回。效率稍高于直接使用 `+`
- 使用 StringBuilder 或 StringBuffer，两者的 `append` 方法都继承自 AbstractStringBuilder，该方法首先使用 `Arrays.copyOf` 确定新的字符数组容量，再调用 `getChars` 方法使用 `System.arraycopy` 将新的值追加到数组中。StringBuilder 是 JDK5 引入的，效率高但线程不安全。StringBuffer 使用 synchronized 保证线程安全

### String a = "a" + new String("b")创建了几个对象？

常量和常量拼接仍是常量，结果在常量池，只要有变量参与拼接结果就是变量，存在堆

使用字面量时只创建一个常量池中的常量，使用 new 时如果常量池中没有该值就会在常量池中新创建，再在堆中创建一个对象引用常量池中常量。因此 `String a = "a" + new String("b")` 会创建四个对象，常量池中的 a 和 b，堆中的 b 和堆中的 ab

## StringBuffer和StringBuilder的区别？

### 可变性

- String类中使用字符数组保存字符，`private final char value[]`，所以String对象是不可变的。

- StringBuilder与StringBuffer都继承自`AbstractStringBuilder`类，在`AbstractStringBuilder`中也是使用字符数组保存字符串

### 线程安全性

- String中的对象是不可变的，也就可以理解常量，线程安全。
- `AbstractStringBuilder`是StringBuilder与StringBuffer的公共父类，StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的

### 性能

- 每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指向新的String对象。
- StringBuffer每次都会对StringBuffer进行操作，而不是生成新的对象并改变对象的引用，相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险

### 总结

- 如果操作少量的数据使用String
- 单线程操作大量数据使用StringBuilder
- 多线程操作大量数据使用StringBuffer

## switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？

在Java5以前，switch(expr)中，expr只能是byte、short、char、int，从java5开始，java中引入了枚举类型，expr也可以是enum类型，从Java7开始，expr还可以是字符串(String)，但是==long不支持==

# final关键字

- 修饰变量

凡是对成员变量或者局部变量（在方法中的或者代码块中的变量称为本地变量）声明为final的都叫做final变量，final变量经常和static关键字一起使用，作为常量

final修饰的基本数据的变量时，必须赋予初始值且不能变修饰引用变量时，该引用变量不能在指向其他对象

当final修饰基本数据类型变量时不赋予初始值以及引用变量指向其他对象时就会报错

当final修饰基本数据类型变量被改变时，就会报错

- 修饰方法

final也可以声明方法，方法上面加上final关键字，代表这个方法不可以被子类方法重写，如果你认为一个方法的功能足够完整了，子类不需要改变的话，你也可以声明此方法为final，final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时在进行绑定

- 修饰类

使用final修饰的类叫做final类，final类通常功能是完整的，他们不能被继承，Java中有许多类是final的，如String，Integer以及其他包装类

### final、finally、finalize 有什么区别？

final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。



# Java异常分类即处理

## 异常概念

异常指方法在不能按照正常方式完成时，可以通过抛出异常的方式退出该方法，在异常中封装了方法执行过程中的错误信息即原因，调用方在获取该异常后可根据业务的情况选择处理该异常或者继续抛出该异常

在方法在执行过程中出现异常时，Java异常处理机制会将代码的执行权交给异常处理器，异常处理器根据在系统中定义的异常处理规则执行不同的异常处理逻辑（抛出异常或者捕捉并处理异常）

## 异常的分类

Java中,`Throwable`是所有错误或异常的父类，`Throwable`又可分为Error和Exception，常见的Error有`AWTError`、`ThreadDeath`，Exception又分为`RuntimeException`和`CheckedException`

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210612104022.png" alt="image-20210612104014494" style="zoom: 80%;" />



- Error是指Java运行错误，如果程序在启动时出现Error，则启动失败，如果运行过程中出现Error，则系统将退出进程，出现Error通常是因为系统内部错误或者资源耗尽，Error不能被在运行时动态处理。如果程序出现Error，则系统能做的工作只有记录错误的成因和安全终止
- Exception指Java程序运行异常，即运行中的程序发生了人们不期望发生的事件，可以被Java异常处理机制处理，Exception也是程序开发中异常处理的核心，可以分
  - `RuntimeException`：指在Java虚拟机正常运行期间抛出的异常，`RuntimeException`可以被捕获并处理，如果出现`RuntimeException`异常，那么一定是程序发生错误导致的，我们通常需要抛出异常或者捕获并处理异常，常见的运行时异常有`NullPointerException`、`ClassCastException`、`ArrayIndexOutOfBundsException`等
  - `CheckedException`：是指在编译阶段Java编译器会检查`CheckedException`异常，并强制程序捕获和处理此类异常，即要求程序在可能出现异常的地方通过try catch语句块捕获并处理异常。常见的`CheckedException`有由于I/O错误引起的`IOException`、`SQLException`、`ClassNotFoundException`、 `FileNotFoundException`，该异常一般由于打开错误文件、SQL语法错误、类不存在等引起

### 异常的选择

是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就是用受检异常，否则选择非受检异常，一般来讲，如果没有特殊的要求，我们建议使用`RuntimeException`异常

## 异常处理方式

> 异常处理方式有抛出异常和使用try catch语句块捕获并处理异常

- 抛出异常：遇到异常时不进行具体处理，而是将异常抛给调用者，有调用者根据情况处理。有可能直接捕获并处理，也有可能继续向上层抛出异常。抛出异常有三种方式：throws、throw、系统自动抛出异常
  - throws作用在方法上，用于定义方法可能抛出的异常
  - throw作用在方法内，表示明确抛出一个异常
- try catch捕获并处理异常：使用try catch捕获异常能够有针对性的处理每种可能遇到的异常，并在捕获到异常后根据不同的情况做不同的处理

|          | throw                                                        | throws                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 位置不同 | 方法内，后面跟的是异常对象                                   | 方法上，后面跟的是异常类（相当于可以抛出多个异常）           |
| 功能不同 | 抛出封装了异常信息的对象，程序执行到throw，后续代码将不会执行，而是跳转到调用者，并将异常信息抛给调用者（finally内的语句除外） | 声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型，预先声明不同的处理方式 |

## 受检异常和非受检异常

### 受检异常

编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。**除 `RuntimeException` 及其子类外，其他的 Exception 异常都属于受检异常**。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过

### 非受检异常

编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。**该类异常包括运行时异常（`RuntimeException`极其子类）和错误（Error）**

## [扩展问题](https://thinkwon.blog.csdn.net/article/details/104390689)

### JVM是如何处理异常的？

在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈

JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序

### try-catch-finally 中哪个部分可以省略？

> catch可以省略

更为严格的说法其实是：try只适合处理运行时异常，try + catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略

###  try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

> 会执行，在return前面执行

在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不立马返回调用者，而是记录下返回值待finally代码执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值，显然，在finally中返回或者修改返回值会对程序造成很大的困扰

```java
public static int getInt() {
    int a = 10;
    try {
        System.out.println(a / 0);
        a = 20;
    } catch (ArithmeticException e) {
        a = 30;
        return a;
        /*
         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
         */
    } finally {
        a = 40;
    }
	return a;
}

执行结果：30
```



```java
public static int getInt() {
    int a = 10;
    try {
        System.out.println(a / 0);
        a = 20;
    } catch (ArithmeticException e) {
        a = 30;
        return a;
    } finally {
        a = 40;
        //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40
        return a; 
    }

}

执行结果：40
```

# 反射机制

## 动态语言的概念

动态语言指程序运行时可以改变其结构，比如新的属性或方法的添加、删除的等结构上的变化。JavaScript、Ruby、Python等都属于动态语言；C、C++不属于动态语言，从反射的角度来书，Java属于半动态语言

## 反射机制的概念

反射机制指程序运行过程中，对任意一个类都能获取其所有属性和方法，并对任意一个对象都能调用其任意一个方法，这种动态获取类和对象的信息，以及动态调用对象方法的功能被称为Java语言的反射机制

> 缺点：破坏了封装性以及泛型约束，反射是框架的核心，Spring大量使用反射

### 反射的应用

Java中的对象有两种类型：编译时类型和运行时类型

- 编译时类型指在声明对象时所采用的类型 如persion
- 运行时类型指为对象赋值时所采用的类型 如Student

```java
Person persion = new Student()
```

因此，程序在编译期间时无法预知该对象的真实信息，只能通过运行时信息来发现该对象和类的真实信息，而其真实信息（对象的属性和方法）通常反射机制来获取。

### 反射API

Java反射API主要用于运行过程中动态生成类、接口或对象信息

- Class类：用于获取类的属性、方法信息
- Field类：用于获取类的成员变量，用于获取和设置类中的属性值
- Method类：用于获取类的方法，用于获取方法的描述信息或者执行某个方法
- Constructor类：表示类的构造方法

### 反射机制优缺点

- 优点：运行期类型判断，动态加载类是，提高代码的灵活度
- 缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的Java代码要慢很多

### class类的作用，如何获取一个Class对象

在程序运行期间，Java运行时系统为所有对象维护了一个运行时类型标识，这个信息会跟踪每个对象所述的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是Class没这事一个泛型类

获取Class对象

- `类名.class`
- `对象.getClass()`
- `Class.forName(类的全限定名)`

### 反射机制的应用场景

> 反射是框架设计的灵魂

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制

举例

- 我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序
- Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：
  - 将程序内所有 XML 或 Properties 配置文件加载入内存中
  - Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 
  - 使用反射机制，根据这个字符串获得某个类的Class实例
  - 动态配置实例的属性