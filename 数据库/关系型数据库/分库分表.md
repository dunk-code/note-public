> 最近培训有聊到分库分表相关的内容，今天就来聊聊分库分表相关的知识

https://maxwell.gitbook.io/way-to-architect/shu-ju-ku/mysql/mysqlzhong-de-sharding/gai-nian-ff1a-fen-5e93-fen-8868-fen-qu

https://zhuanlan.zhihu.com/p/136963357

https://zhuanlan.zhihu.com/p/98030096

https://blog.51cto.com/u_15127565/2664941

## 概念

>首先需要明确什么是分库分表

库，即database、分库，即将一个database分为多个database；表，table，分表，即将一个表拆分成多张表

> 那为什么要分库分表？

首先，数据库系统有它的性能瓶颈，无论是从服务器硬件资源还是sql语句优化，总之，他都有一定的性能瓶颈，为了突破性能瓶颈，获得更高的QPS，于是，针对数据库系统有一套架构演变过程：单机->读写分离（主从）->分库分表

读写分离，即主从，可以在一定程度解决请求量太大的问题，他的原理是：所有的写请求会直接操作主服务器，所有的读请求会读从服务器，然后从服务器通过bin log中继日志和主服务器进行数据同步。但是，如果写请求或者读请求再增长，单机可能就无法承受，比如单机的磁盘，内存，IO等都是有限的。所以，将单库变为多库，就是一种解决方案。

如果一张表的数据量无限增大，甚至整个库都是一张表，但是仍然无法存储持续到来的数据，再或者，由于数据量的持续增长，索引也会变得很大，查询也会变得很慢，此时，将单表变为多表，就是一种解决方案。

## 分库

所谓分库，其实就是将1个库中的n个表，拆分到多个库中，这样每个库中表的数量就减少了。所以，分库只有一种方式，就是垂直分库：按照业务模块来划分出不同的数据库，与微服务的划分方式类似。

比如一般的电商平台，包含了用户、商品、订单等几大模块，简单的做法是在同一个库中分别建3张表，但是随着业务量的增长，将所有业务都放在一个库中已经变得越来越难以维护，因此可以将不同业务放在不同的库中。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/202208312317640.png" alt="image-20220831231720413" style="zoom:50%;" />

## 分表

### 垂直分表

根据数据库里面而的数据表的相关性进行拆分，例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说，垂直拆分是指数据表列的拆分，把一张类列比较多的表拆分为多张表。

![image-20210504154022883](https://gitee.com/zhang-songyao/blog-images/raw/master/20210504154023.png)

（1）将长度较短，访问频率较高的列尽量放在一个表里（**主表）**

（2）将字段较长，访问频率较低的列尽量放在一个表里（**扩展表）**

（3）经常一起访问的属性，也可以放在一个表里

垂直拆分后，存在之前一张表可以访问到的列，拆分后，需要JOIN联表

此时，建议不要使用JOIN来联表访问，而应该分两次进行查询。

比如，将表user(uid, name, age, gender)拆分为user_base(uid, name)和user_ext(uid, age, gender)，拆分前：

```sql
SELECT uid, name, age, gender FROM user WHERE uid=1;
```

拆分后应该避免使用如下联表的方式查询

```sql
SELECT uid, name, age, gender 
FROM user_base 
LEFT JOIN user_ext USING uid
WHERE uid=1;
```

而是使用两次查询，然后交给应用程序来完成JOIN的语义

```sql
SELECT uid, name FROM user_base WHERE uid=1;
SELECT uid, age, gender FROM user_ext WHERE uid=1;
```

（1）join更消损耗数据库性能；

（2）join会让user_base表和user_ext表耦合在一起（必须在一个数据库实例上，否则无法JOIN），不利于数据量大时拆分到不同的数据库实例上。毕竟减少数据量，提升性能才是垂直拆分的初衷。

此外，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。

### 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。


![image-20210504154251960](https://gitee.com/zhang-songyao/blog-images/raw/master/20210504154252.png)

需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨界点Join性能较差，逻辑复杂。

《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

常见的水平拆分的规则：

#### 范围拆分

按照范围拆分，如：按照自增主键id来拆分，0-100000一张表，100001-200000一张表。

范围拆分的优点是策略简单，可以很快定位到数据在哪个库上，且扩容简单，如果容量不够，只要增加新库即可。

范围拆分的缺点：

- 列值必须要满足递增的特性
- 数据量不均，新增的库，在初期的数据会比较少
- 请求量不均，比如我们用户id来拆分，一般来说新注册的用户活跃度会比较高，导致服务器利用率不平衡

#### 哈希取模

按照表中某个列的值的进行先哈希取模来拆分。

比如有user(uid, name)和order(uid, ...)，则可以对user和order中的uid进行取模操作（mod = uid % (表的数量)），这样同一个用户的订单就会落在同一个数据库实例中，可以避免跨库事务之类的问题。

如果要按照某个非数值类型的列进行拆分，则可以先对列值进行HASH操作，再取模。

哈希取模的优点是：策略简单，可以很快定位到数据在哪个库上，且数据量均衡，请求量均衡（前提是HASH均匀）。

哈希取模的不足是扩容麻烦：如果容量不够，要增加一个库，重新hash可能会导致数据迁移。

**地理区域**

比如按照华东，华南，华北这样来区分业务。

**时间**

按照时间拆分，实现“冷热数据分离”。

##### **拆分后的查询处理**

水平拆分后，对于拆分列（按照这个列进行拆分）上的查询，可以根据拆分规则，直接路由到库，但是对于非拆分列上的查询，就需要费一番周折。

比如`user(uid, login_name)`按照uid拆分为`user_1(uid, login_name)`和`user_2(uid, login_name)`。

那么，拆分列为uid，则如下查询可以根据拆分规则，直接路由到库(假设为user_1)，获取查询结果。

SELECT uid, login_name FROM user_1 WHERE uid=1;

但是，对于按照`login_name`进行的查询，就很困难，因为不知道要去哪个库去查。

SELECT uid, login_name FROM user_? WHERE login_name=maxwell;

如果遍历所有库，当分库数量很多的时候，性能会显著降低。

针对这种查询，一般有如下解决方案。

**索引表法**

思路：uid能直接定位到库，login_name不能直接定位到库，如果通过login_name能查询到uid，问题解决

解决方案：新建表t(login_name, uid)，用login_name来访问时，先通过索引表查询到uid，再定位相应的库。

索引表属性较少，可以容纳非常多数据，一般不需要分库；如果数据量过大，可以通过login_name来分库。

这种方案的不足之处在于：多一次数据库查询。

**缓存映射法**

思路：访问索引表性能较低，把映射关系放在缓存里性能更佳

解决方案：login_name查询先到cache中查询uid，再根据uid定位数据库；假设cache miss，采用扫全库法获取login_name对应的uid，放入cache；login_name到uid的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高。

这种方案的不足之处在于：多一次缓存查询。

**login_name生成uid**

思路：不进行远程查询，由login_name直接得到uid

解决方案：在用户注册时，设计函数login_name生成uid，uid=f(login_name)，按uid分库插入数据；用login_name来访问时，先通过函数计算出uid，即uid=f(login_name)再来一遍，由uid路由到对应库。

这种方案的不足之处在于：函数设计需要非常讲究技巧，有uid生成冲突风险。

**login_name基因融入uid**

思路：不用login_name生成uid，可以从login_name抽取“基因”，融入uid中

假设分8库，采用uid%8路由，则uid的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”。

解决方案：

\>在用户注册时，设计函数login_name生成3bit基因，login_name_gene=f(login_name)

\>同时，生成61bit的全局唯一id，作为用户的标识

\>接着把3bit的login_name_gene也作为uid的一部分

\>生成64bit的uid，由id和login_name_gene拼装而成，并按照uid分库插入数据

\>用login_name来访问时，先通过函数由login_name再次复原3bit基因，login_name_gene=f(login_name)，通过login_name_gene%8直接定位到库

**数据库分片的两种常见方案：**

- 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
- 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。

​	

## 分库分表后平滑扩容

### 停服务方案

假设原来分了x个库，现在要扩展到y个库，则实施方案如下：

（1）站点挂一个公告“为了为广大用户提供更好的服务，本站点/游戏将在今晚00:00-2:00之间升级，届时将不能登录，用户周知”

（2）停服务

（3）新建y个库，做好高可用

（4）数据迁移，重新分布，写一个数据迁移程序，从x个库里导入到y个库里，路由规则由%x升级为%y

（5）修改服务配置，原来x行配置升级为y行

（6）重启服务，连接新库重新对外提供服务

整个过程中，**最耗时的是第四步数据迁移。**

**回滚方案**：如果数据迁移失败，或者迁移后测试失败，则将配置改回x库，恢复服务，改天再挂公告。

**方案优点**：简单

**方案缺点**：

（1）停服务，不高可用

（2）技术同学压力大，所有工作要在规定时间内做完，根据经验，压力越大约容易出错（这一点很致命）

（3）如果有问题第一时间没检查出来，启动了服务，运行一段时间后再发现有问题，难以回滚，需要回档，可能会丢失一部分数据

### 平滑扩容方案

假设原来分2个库，现在要扩为4个库，实施方案如下：

**第一步：修改配置**

a）数据库实例所在的机器做双虚ip，原来%2=0的库是虚ip0，现在增加一个虚ip00，%2=1的库时ip1，现在增加一个虚ip11；

b）修改应用（数据库使用方）的数据库配置（保证拆分后依然能够路由到正确的数据），如下图所示：

- 将2个库的数据库配置，改为4个库的数据库配置
- %4=0与%4=2的数据落在原来%2=0所在的库，%4=1与%4=3的数据落在原来%2=1所在的库

这步操作如下图所示：![image-20220909155105496](https://gitee.com/zhang-songyao/blog-images/raw/master/202209091551623.png)



**第二步：reload应用（数据库使用方)配置**

服务层reload配置，reload可能是这么几种方式：

a）比较原始的，重启服务，读新的配置文件

b）高级一点的，配置中心给服务发信号，重读配置文件，重新初始化数据库连接池

不管哪种方式，reload之后，数据库的**实例扩容就完成了**，原来是2个数据库实例提供服务，现在变为4个数据库实例提供服务，这个过程一般可以在秒级完成。

整个过程可以逐步重启，**对服务的正确性和可用性完全没有影响**：

a）即使%2寻库和%4寻库同时存在，也不影响数据的正确性，因为此时仍然是双主数据同步的

b）服务reload之前是不对外提供服务的，冗余的服务能够保证高可用

**第三步：数据收缩**

a）把双虚ip修改回单虚ip；

b）解除旧的双主同步，让成对库的数据不再同步增加；

![image-20220913111236816](https://gitee.com/zhang-songyao/blog-images/raw/master/202209131112091.png)

c）增加新的双主同步（对应上图，就是为user0-master1/user0-master2/user1-master1/user1-master2分别增加同步主库)

d）删除掉冗余数据（对应上图，就是user0-master1中删除%4=2的数据，user0-master2中删除%4=0的数据，user1-master1中删除%4=3的数据，user1-master2中删除%4=1的数据）

这样下来，每个库的数据量就降为原来的一半，数据收缩完成。

该方案能够实现n库扩2n库的秒级、平滑扩容，增加数据库服务能力，降低单库一半的数据量。

**总结步骤：对原来的每个分表，双主均做双虚IP，然后修改应用数据库配置以及路由规则，然后先将双虚IP改为单虚IP，解除双主关系，为每个单库增加新的同步主库，最后，删除冗余数据。**

### 归档

- log data
- history data

https://maxwell.gitbook.io/way-to-architect/shu-ju-ku/mysql/mysqlzhong-de-sharding/fen-ku-fen-biao-hou-de-ping-hua-kuo-rong