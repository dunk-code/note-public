数据结构与算法](https://github.com/dunk-code/Datastructure-Algorithm)

# 二分查找模板

[模板](https://www.cnblogs.com/disandafeier/p/11020559.html)

# BST树

## [783. 二叉搜索树节点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 

### 方法一

```java
class Solution {
    int min = Integer.MAX_VALUE;
    public int minDiffInBST(TreeNode root) {
        execDfs(root);
        return min;
    }
    //对每个节点执行dfs
    public void execDfs(TreeNode node) {
        if(node == null) return;
        dfs(node.left, node.val);
        dfs(node.right, node.val);
        execDfs(node.left);
        execDfs(node.right);
    }
    //dfs
    public void dfs(TreeNode node, int cur) {
        if(node == null) return;
        min = Math.min(min, Math.abs(cur - node.val));
        dfs(node.left, cur);
        dfs(node.right, cur);
    }
}
```

### 方法二

```java
class Solution {
    int min = Integer.MAX_VALUE;
    int pre = -1;
    public int minDiffInBST(TreeNode root) {
        dfs(root);
        return min;
    }

    public void dfs(TreeNode node) {
        if(node == null) return;
        dfs(node.left);
        if(pre == -1) {
            pre = node.val;
        } else {
            min = Math.min(min, node.val - pre);
            pre = node.val;
        }
        dfs(node.right);
    }
}
//bst中序遍历是一个升序数组，求一个升序数组的任意量元素差的最小值，相当于相邻两个元素差的最小值
```

# 前缀树

## [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

### [什么是前缀树](https://leetcode-cn.com/leetbook/read/trie/x0gnuh/)

前缀树 是 N叉树 的一种特殊形式。通常来说，一个前缀树是用来 存储字符串 的。前缀树的每一个节点代表一个 字符串（前缀）。每一

个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的 原始字符串 ，以及 通往该子节

点路径上所有的字符 组成的。

下面是前缀树的一个例子：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210517195143.png" alt="img" style="zoom: 50%;" />

在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一

个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序

形成的。

值得注意的是，根节点表示 空字符串 。

前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 前缀树 名称的由来。

我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字

符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。

前缀树有着广泛的应用，例如自动补全，拼写检查等等。我们将在后面的章节中介绍实际应用场景。

### 如何表示一个前缀树

#### 方法一

第一种方法是用 数组 存储子节点。

例如，如果我们只存储含有字母 a 到 z 的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符 c ，

我们可以使用 c - 'a' 作为索引来查找数组中相应的子节点。

```java
class Trie {
    
    public Trie[] children;
    public boolean isEnd;

    /** Initialize your data structure here. */
    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie cur = this;
        for(char ch : word.toCharArray()) {
            if(cur.children[ch - 'a'] == null) {
                cur.children[ch - 'a'] = new Trie();
            }
            cur = cur.children[ch - 'a'];
        }
        cur.isEnd = true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }

    public Trie searchPrefix(String prefix) {
        Trie cur = this;
        for(char ch : prefix.toCharArray()) {
            if (cur.children[ch - 'a'] == null) {
                return null;
            }
            cur = cur.children[ch - 'a'];
        }
        return cur;
    }
}
```

访问子节点十分 快捷 。访问一个特定的子节点比较 容易 ，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节

点都需要这样的操作，所以这可能会导致 空间的浪费 。

#### 方法二

第二种方法是使用 `Hashmap` 来存储子节点。

我们可以在每个节点中声明一个 Hashmap 。Hashmap 的键是字符，值是相对应的子节点。

```java
class Trie {

    public boolean isEnd;
    public Map<Character, Trie> children; 

    /** Initialize your data structure here. */
    public Trie() {
        isEnd = false;
        children = new HashMap<>();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie cur = this;
        for(char ch : word.toCharArray()) {
            if(cur.children.get(ch) == null) {
                cur.children.put(ch, new Trie());
            }
            cur = cur.children.get(ch);
        }
        cur.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    public Trie searchPrefix(String prefix) {
        Trie node = this;
        for(char ch : prefix.toCharArray()) {
            if(node.children.get(ch) == null) 
            return null;
            node = node.children.get(ch);
        }
        return node;
    }
}
```

通过相应的字符来访问特定的子节点 更为容易 。但它可能比使用数组 稍慢一些 。但是，由于我们只存储我们需要的子节点，因此 节省

了空间 。这个方法也更加 灵活 ，因为我们不受到固定长度和固定范围的限制。

#### 补充

我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。

例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储

单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。

# 动态规划

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 方法一（动态规划）

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```

### 方法二（滚动数组）

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int first = nums[0];
        int second = Math.max(nums[0], nums[1]);
        for(int i = 2; i < n; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额

```
示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        if(n == 2) return Math.max(nums[0], nums[1]);
        return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }

    public int robRange(int[] nums, int start, int end) {
        int first = nums[start];
        int second = Math.max(nums[start], nums[start + 1]);
        for(int i = start + 2; i <= end; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

## 区间dp

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

>给你一个字符串 `s`，找到 `s` 中最长的回文子串。

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```


示例 3：

```
输入：s = "a"
输出："a"
```


示例 4：

```
输入：s = "ac"
输出："a"
```

#### 暴力解法

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        int maxLen = 1;
        int begin = 0;
        char[] charArray = s.toCharArray();
        for(int i = 0; i < len - 1; i++) {
            for(int j = i + 1; j < len; j++) {
                if((j - i + 1) > maxLen && isPalindrome(charArray, i, j)) {
                    maxLen = j - i + 1;
                    begin = i;
                } 
            }
        }
        return s.substring(begin, begin + maxLen);
    }
    
    //判断字符串是否为回文子串
    public boolean isPalindrome(char[] charArray, int left, int right) {
        while(left < right) {
            if(charArray[left] != charArray[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
时间：O(n^3)
空间：O(1)
```

#### 中心展开

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;

        int maxLen = 1;
        int begin = 0;
        
        char[] charArray = s.toCharArray();
        for(int i = 0; i < len - 1; i++) {
            //以charArray为奇数中心展开
            int oddLen =  expendAroundCenter(charArray, i, i);
            //以charArray为偶数中心展开
            int evenLen = expendAroundCenter(charArray, i, i + 1);

            int maxCurLen = Math.max(oddLen, evenLen);

            if(maxCurLen > maxLen) {
                maxLen = maxCurLen;
                begin = i - (maxCurLen - 1) / 2;
            }
        }
        return s.substring(begin, begin + maxLen);
    }

    //中心扩展  
    public int expendAroundCenter(char[] charArray, int left, int right) {
        while(left >= 0 && right < charArray.length &&	 
        charArray[right] == charArray[left]) {
            left--;
            right++;
        }
        //回文串长度j - i + 1 - 2;
        return (right - left - 1); 
    }
}
时间：O(n^2)
空间：O(1)
```

#### 动态规划

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        
        //dp[i][j] 表示s[i : j]的子字符串是否为回文串
        boolean[][] dp = new boolean[len][len];
        //初始化长度为1时都是回文串
        for(int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        
        int maxLen = 1;
        int begin = 0;

        char[] charArray = s.toCharArray();
        //循环遍历长度从2开始到len
        for(int L = 2; L <= len; L++) {
            //遍历所有下标
            for(int i = 0; i < len; i++) {
                //计算下标j j - i + 1 = L
                int j = L + i - 1;

                //判断是否下标越界
                if(j >= len) break;

                //判断左右下标是否相等
                if(charArray[i] == charArray[j]) {
                    //判断当前回文长度是否大于2，小于2直接赋值
                    if(L < 3) {
                        dp[i][j] = true;
                    } else {    //长度大于2，则取决于s[i + 1 : j - 1]是否为回文串
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                
                //判断长度是否超过当前最大值
                if(dp[i][j] && L > maxLen) {
                    maxLen = L;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
时间：O(n^2)
空间：O(n^2)
```

### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
>
>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```


示例 2：

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

#### 暴力

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        if(len < 2) return s.length() == 0 ? 0 : 1;
        int count = 0;
        char[] charArray = s.toCharArray();
        for(int i = 0; i < len; i++) {
            for(int j = i; j < len; j++) {
                if(isPalindrome(charArray, i, j)) count++;
            }
        }
        return count;
    }
    
    public boolean isPalindrome(char[] charArray, int left, int right) {
        while(left < right) {
            if(charArray[left] != charArray[right]) return false;
            left++;
            right--;
        }
        return true;
    }
}
//暴力
```

#### 动态规划

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        if(len < 2) return s.length() == 0 ? 0 : 1;
        int count = 0;
        //dp[i][j] 表示s[i : j]的子字符串是否为回文串
        boolean[][] dp = new boolean[len][len];
        //初始化长度为1时都是回文串
        for(int i = 0; i < len; i++) {
            dp[i][i] = true;
            count++;
        }
        
        char[] charArray = s.toCharArray();
        //循环遍历长度从2开始到len
        for(int L = 2; L <= len; L++) {
            //遍历所有下标
            for(int i = 0; i < len; i++) {
                //计算下标j j - i + 1 = L
                int j = L + i - 1;

                //判断是否下标越界
                if(j >= len) break;

                //判断左右下标是否相等
                if(charArray[i] == charArray[j]) {
                    //判断当前回文长度是否大于2，小于2直接赋值
                    if(L < 3) {
                        dp[i][j] = true;
                    } else {    //长度大于2，则取决于s[i + 1 : j - 1]是否为回文串
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                
                //判断长度是否超过当前最大值
                if(dp[i][j]) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) 

>给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

**示例 1:**
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**
输入:

```
"cbbd"
```

输出:

```
2
```

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        if(len < 2) return len;
        char[] charArray = s.toCharArray();
        //表示第i个元素到第j个元素之间的回文子序列的长度
        int[][] dp = new int[len][len];
        for(int i = len - 1; i >= 0; i--) {
            //s[i : i] = 1
            dp[i][i] = 1;
            for(int j = i + 1; j < len; j++) {
                //如果 s 的第 i 个字符和第 j 个字符相同的话
                //f[i][j] = f[i + 1][j - 1] + 2
                if(charArray[i] == charArray[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    //如果 s 的第 i 个字符和第 j 个字符不同的话
                    //f[i][j] = max(f[i + 1][j], f[i][j - 1])
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
}
//动态规划
```

## 二维数组前缀和	

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210422094916.png" alt="fig1" style="zoom:30%;" />

*f*(*i*,*j*)=*f*(*i*−1,*j*)+*f*(*i*,*j*−1)−*f*(*i*−1,*j*−1)+matrix[i] [j]

### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

> 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。
>
> <img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210422094907.png" alt="Range Sum Query 2D" style="zoom:20%; float=left;"/>
>
> 上图子矩阵左上角 (row1, col1) = **(2, 1)** ，右下角(row2, col2) = **(4, 3)，**该子矩形内元素的总和为 8。

示例：

```
给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
```

```java
class NumMatrix {
    int[][] sums;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length;
        if (m > 0) {
            int n = matrix[0].length;
            sums = new int[m + 1][n + 1];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    sums[i + 1][j + 1] = sums[i][j + 1] + sums[i + 1][j] - sums[i][j] + matrix[i][j];
                }
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
    }
}
```

### [1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。
>
>子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。
>
>如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210529101303.jpeg" alt="img" style="zoom:80%;" />

示例

```
输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
输出：4
解释：四个只含 0 的 1x1 子矩阵。
```

#### 前缀和 + 暴力枚举

时间复杂度O(m^2 * n ^ 2)

```java
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int count = 0;
        int[][]dp = new int[m + 1][n + 1];
        //System.out.println(Arrays.toString(dp[0]));
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                //if(matrix[i - 1][j - 1] == target) count++;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 
                + matrix[i - 1][j - 1] - dp[i - 1][j - 1];
            }
            //System.out.println(Arrays.toString(dp[i]));
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                for(int p = 1; p <= i; p++) {
                    for(int q = 1; q <= j; q++) {
                        if(dp[i][j] - dp[i][q - 1] - dp[p - 1][j] + dp[p - 1][q - 1] == target) count++;
                    }
                }
            }
        }
        return count;
    }
}
```

#### 前缀和 + 哈希表

```java
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][]dp = new int[m + 1][n + 1];
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 
                + matrix[i - 1][j - 1] - dp[i - 1][j - 1];
            }
        }
        int count = 0;
        for(int top = 1; top <= m; top++) {
            for(int bot = top; bot <= m; bot++) {
                int cur = 0;
                Map<Integer, Integer> map = new HashMap<>();
                for(int r = 1; r <= n ; r++) {
                    cur = dp[bot][r] - dp[top - 1][r];
                    if(cur == target) count++;
                    if(map.containsKey(cur - target)) count += map.get(cur - target);
                    map.put(cur, map.getOrDefault(cur, 0) + 1); 
                }
            }
        }
        return count;
    }
}
```

### [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

> 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
>
> 题目数据保证总会存在一个数值和不超过 k 的矩形区域。

 

示例 1：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210422094848.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
```

#### 暴力枚举

时间复杂度O(m^2 * n ^ 2)

```java
class Solution {
        public int maxSumSubmatrix(int[][] matrix, int k) {
            int m = matrix.length;
            int n = matrix[0].length;
            int[][] nums = new int[m + 1][n + 1];
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    nums[i][j] = nums[i][j - 1] + nums[i - 1][j] - nums[i - 1][j - 1] + matrix[i - 1][j - 1];
                }
            }
            int ans = Integer.MIN_VALUE;
            //枚举所有子矩阵
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    for (int p = i; p <= m; p++) {
                        for (int q = j; q <= n; q++) {
                            int curSum = nums[p][q] - nums[i - 1][q] - nums[p][j - 1] + nums[i - 1][j - 1];
                            if (curSum <= k) {
                                ans = Math.max(ans, curSum);
                            }
                        }
                    }
                }
            }
            return ans;
        }
    }
```

#### [前缀和 & 二分（抽象一维）](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/)

```java
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] nums = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                nums[i][j] = nums[i][j - 1] + nums[i - 1][j] - nums[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        int ans = Integer.MIN_VALUE;
        //子矩阵的上边界
        for (int top = 1; top <= m; top++) {
            //子矩阵的下边界
            for (int bot = top; bot <= m; bot++) {
                //使用红黑树存储当前所有遍历过的右边界
                TreeSet<Integer> set = new TreeSet<>();
                set.add(0);
                //子矩阵的右边界
                for (int r = 1; r <= n; r++) {
                    //当前子矩阵的和
                    int right = nums[bot][r] - nums[top - 1][r];
                    //right - left >= k
                    // left <= right - k
                    Integer left = set.ceiling(right - k);
                    if (left != null) {
                        ans = Math.max(ans, right - left);
                    }
                    set.add(right);
                }
            }
        }
        return ans;
    }
}
```

最大二分收益（根据m，n的大小决定是取上下边界还是左右边界）

```java
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] nums = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                nums[i][j] = nums[i][j - 1] + nums[i - 1][j] - nums[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        int ans = Integer.MIN_VALUE;
        //子矩阵的上边界
        boolean isRight = n > m;
        for(int i = 1; i <= (isRight ? m : n); i++) {
            for(int j = i; j <= (isRight ? m : n); j++) {
                TreeSet<Integer> set = new TreeSet<>();
                set.add(0);
                for(int fixed = 1; fixed <= (isRight ? n : m); fixed++) {
                    int sum = isRight ? nums[j][fixed] - nums[i - 1][fixed] :
                            nums[fixed][j] - nums[fixed][i - 1];
                    //right - left >= k
                    // left <= right - k
                    Integer a = set.ceiling(sum - k);
                    if (a != null) {
                        ans = Math.max(sum - a, ans);
                    }
                    set.add(sum);
                }
            }
        }
        return ans;
    }
}
```

### [368. 最大整除子集](https://leetcode-cn.com/problems/largest-divisible-subset/)

给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可。

示例 1：

```
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
```


示例 2：

```
输入：nums = [1,2,4,8]
输出：[1,2,4,8]
```

```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) { 
        int len = nums.length;
        int[] dp = new int[len];
        //第一步：找出最大整数和最大子集长度
        Arrays.sort(nums);
        Arrays.fill(dp, 1);
        int maxSize = 1;
        int maxVal = dp[0];
        for(int i = 1; i < len; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] % nums[j] == 0) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
                if(dp[i] > maxSize) {
                    maxSize = dp[i];
                    maxVal = nums[i];
                }
            }
        }
        List<Integer> list = new ArrayList<>();
        //第二步：倒序获得最大子集
        if(maxSize == 1) {
            list.add(nums[0]);
            return list;
        }

        for(int i = len - 1; i >= 0 && maxSize > 0; i--) {
            if(dp[i] == maxSize && maxVal % nums[i] == 0) {
                list.add(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return list;
    }
}
```

## 卡特兰数

### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

示例:

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
//卡特兰数
```

![image-20210425094735146](https://gitee.com/zhang-songyao/blog-images/raw/master/20210425094737.png)

## [1473. 粉刷房子 III](https://leetcode-cn.com/problems/paint-house-iii/)

在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。

我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 

给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：

houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。
cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。
请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。

```
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：9
解释：房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
```

### 方法一

TTL

深度优先遍历

```java
class Solution {
    int minPay = Integer.MAX_VALUE;
    int target;
    int[][]cost;
    int m;
    int n;
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        this.target = target;
        this.cost = cost;
        this.m = m;
        this.n = n;
        dfs(0, 1, 0, houses);
        return minPay == Integer.MAX_VALUE ? -1 : minPay;
    }

    public void dfs(int index, int curTarget,int curPay, int[] houses) {
        if(curTarget > target) return;
        if(index == m && curTarget == target) {
            System.out.println(curPay);
            minPay = Math.min(minPay, curPay);
            System.out.println(Arrays.toString(houses) + minPay);
            return;
        }
        if (index == m) return;
        if(houses[index] == 0) {
            for(int i = 0; i < n; i++) {
                houses[index] = i + 1;
                if(index > 0 && houses[index] != houses[index - 1]) {
                    curTarget++;
                }
                curPay += cost[index][i];
                dfs(index + 1, curTarget, curPay, houses);
                if(index > 0 && houses[index - 1] != houses[index]) curTarget--;
                curPay -= cost[index][i];
                houses[index] = 0;
            }
        } else {
            if(index > 0 && houses[index] != houses[index - 1]) {
                curTarget++;
            }
            dfs(index + 1, curTarget, curPay, houses);
        }
    }
}
```

### 方法二

三维动态规划

```java
class Solution {
    int INF = Integer.MAX_VALUE >> 1;
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        //int[i][j][k] 0-i个房子。最后一个房子上色为j，街区数为k的最下花费
        int[][][] f = new int[m + 1][n + 1][target + 1];

        //不存在分区为0的状态
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                f[i][j][0] = INF;
            }
        }

        for (int i = 1; i <= m; i++) {
            int color = houses[i - 1];
            for (int j = 1; j <= n; j++) {
                for (int k = 1; k <= target; k++) {
                    //形成分区数量大于房子数量没有意义
                    if (k > i) {
                        f[i][j][k] = INF;
                        continue;
                    }
                    int tmp;
                    //第i间房间已经上色
                    if (color != 0) {
                        if (j == color) {//只有颜色相同的状态，才允许被转移
                            tmp = INF;
                            //先找第i间房时颜色不为j的最优解
                            for (int p = 1; p <= n; p++) {
                                if (p != j) {
                                    tmp = Math.min(tmp, f[i - 1][p][k - 1]);
                                }
                            }
                            //再结合第i间房不形成新的分区，方案中取得最优解
                            f[i][j][k] = Math.min(tmp, f[i - 1][j][k]);
                        } else {
                            //其余状态无效
                            f[i][j][k] = INF;
                        }
                    } else {
                        //第i间房未上色
                        //拿到第i间房上j色的花费
                        int u = cost[i - 1][j - 1];
                        //先从所有形成新分区的方案中选择最优的
                        tmp = INF;
                        for(int p = 1; p <= n; p++) {
                            if(p != j) {
                                tmp = Math.min(tmp, f[i - 1][p][k - 1]);
                            }
                        }
                        //在结合不形成分区的方案选择
                        //加上上色的成本
                        f[i][j][k] = Math.min(tmp, f[i - 1][j][k]) + u;
                    }
                }
            }
        }
        //只考虑m间房，t个分区的最小花费
        int res = INF;
        for (int i = 1; i <= n; i++) {
            res = Math.min(res, f[m][i][target]);
        }
        return res == INF ? -1 : res;
    }
}
```

## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 ![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210511091146.png)

```
输入：m = 3, n = 7
输出：28
```

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210511091429.png" alt="image-20210511091425892" style="zoom:80%;" />

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 1; i <= m; i++) {
            dp[i][1] = 1;
        }
        for(int i = 1; i <= n; i++) {
            dp[1][i] = 1;
        }
        for(int i = 2; i <= m; i++) {
            for(int j = 2; j <= n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
时间O(m*n)
空间O(m*n)
```

> 优化空间复杂度

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n + 1];
        for(int i = 1; i <= n; i++) {
            dp[i] = 1;
        }
        for(int i = 2; i <= m; i++) {
            for(int j = 2; j <= n; j++) {
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n];
    }
}
时间O(m*n)
空间O(n)
```

## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210511100537.jpeg" alt="img" style="zoom:80%;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210511100504.png" alt="image-20210511100459637" style="zoom:80%;" />

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        //终点起点为障碍物直接返回0路径（存在这样的测试用例...）
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1)
            return 0;

        //(1)初始化第一行/列为1。当遇到障碍后，那么后续路径直接走不通改为0（因为不能往上和往左走）
        boolean isObstacle = false;
        for (int i = 0; i < m; i++) {
            if (obstacleGrid[i][0] == 1) {
                isObstacle = true;
            }
            obstacleGrid[i][0] = isObstacle ? 0 : 1;
        }
        isObstacle = false;
        for (int i = 1; i < n; i++) {
            if (obstacleGrid[0][i] == 1) {
                isObstacle = true;
            }
            obstacleGrid[0][i] = isObstacle ? 0 : 1;
        }

        //(2)遍历除第一行/列外的所有元素
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                //(3)当遇到障碍物时，处理改为0，并跳过
                if (obstacleGrid[i][j] == 1) {
                    obstacleGrid[i][j] = 0;
                    continue;
                }
                //(4)计算路径和
                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
            }
        }
        return obstacleGrid[m - 1][n - 1];
    }
}
```

## [1269. 停在原地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)

有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。

每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。

给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。

由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

```
输入：steps = 3, arrLen = 2
输出：4
解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
```

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210513091823.png" alt="image-20210513091820230" style="zoom:80%;" />

```java
class Solution {
    public static final int MOD = 1000000007;
    public int numWays(int steps, int arrLen) {
        int maxCol = Math.min(steps, arrLen - 1);
        int[][] dp = new int[steps + 1][maxCol + 1];
        dp[0][0] = 1;
        for(int i = 1; i <= steps; i++) {
            for(int j = 0; j <= maxCol; j++) {
                dp[i][j] = dp[i - 1][j];
                if(j - 1 >= 0) {
                    dp[i][j] = (dp[i][j] +dp[i - 1][j - 1]) % MOD;
                }
                if(j + 1 <= maxCol) {
                    dp[i][j] = (dp[i][j] +dp[i - 1][j + 1]) % MOD;
                }
            }
        }
        return dp[steps][0];
    }
}
```

## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[]dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for(int i = 0; i <= amount; i++) {
            for(int coin : coins) {
                if(coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 :dp[amount];
    }
}
```

## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210530231147.jpeg" alt="img" style="zoom:80%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

### 方法一（二维数组前缀和 + 暴力） 

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int max = 0;
        int[][] nums = new int[m + 1][n + 1];
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                nums[i][j] = nums[i - 1][j] + nums[i][j - 1] 
                - nums[i - 1][j - 1] + (matrix[i - 1][j - 1] - '0'); 
            }
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                for(int p = i, q = j; p <= m && q <= n; p++, q++) {
                    int sum = nums[p][q] - nums[i - 1][q] 
                    - nums[p][j - 1] + nums[i - 1][j - 1];
                    if(sum == (p - i + 1) * (p - i + 1)) {
                        max = Math.max(max, sum);
                    }
                }
            }
        }
        return max;
    }
}
```

> 稍微优化一下

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int max = 0;
        int[][] nums = new int[m + 1][n + 1];
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                nums[i][j] = nums[i - 1][j] + nums[i][j - 1] 
                - nums[i - 1][j - 1] + (matrix[i - 1][j - 1] - '0'); 
            }
        }
        for(int top = 1; top <= m; top++) {
            for(int bot = top; bot <= m; bot++) {
                for(int left = 1; left <= n; left++) {
                    int right = left + bot - top;
                    if(right > n) continue;
                    int sum = nums[bot][right] - nums[bot][left - 1] 
                    - nums[top - 1][right] + nums[top - 1][left - 1];
                    if(sum == (bot - top + 1) * (bot - top + 1))
                    max = Math.max(max, sum);
                }
            }
        }
        return max;
    }
}
```

### 动态规划

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210530231411.png" alt="fig1" style="zoom:80%;" />

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int[][]dp = new int[m][n];
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(matrix[i][j] == '1') {
                    if(i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), 
                        dp[i - 1][j - 1]) + 1;
                    }
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
```

## 背包问题

提纲：

- 01背包
  - [494. 目标和](https://leetcode-cn.com/problems/target-sum/)：转化问题以后为0-1背包方案数问题。
  - [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)：转化后为0-1背包可行性问题。
  - [最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)：转化后为0-1背包最小值问题。
  - [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)
- 完全背包
  - [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) ：完全背包最小值
  - [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)：完全背包方案数
  - [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)：完全背包最小值
  - [组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)：考虑物品顺序的完全背包方案数。每个物品可以重复拿，有几种装满背包的方案？
  - [1449. 数位成本和为目标值的最大数字](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/) 
  -  [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)
- 多维背包
  - [01 字符构成最多的字符串](https://leetcode-cn.com/problems/ones-and-zeroes/)：多维费用的 0-1 背包最大值，两个背包大小：0和1的数量
  - [盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)：多维费用的 0-1 背包最大值
- 分组背包
  - [掷骰子的N种方法](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/)：每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品

# KMP

## KMP算法介绍

> 它主要的用途就是查找字符串，查找字符串"ab"(目标字符串)在字符串"abc"(待查找字符串)中出现的位置。换句话说，就是查找字符串"abc"是否包含字符串"ab"，如果包含，返回包含的起始位置

算法由两部分组成
 1、计算subStr每一位及之前的字符串中，前缀和后缀公共部分的最大长度的next数组
 2、匹配destStr和subStr，当subStr失配时，利用next数组，实现subStr的最大后移，从而避免不必要的匹配，减少匹配次数

### BF(Brute Force)

![BF算法](https://gitee.com/zhang-songyao/blog-images/raw/master/20210420175619.gif)

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int len1 = haystack.length();
        int len2 = needle.length();
        if(len2 == 0) return 0;
        int l = 0;
        int r = 0;
        while(l < len1 && r < len2) {
            if(haystack.charAt(l) == needle.charAt(r)) {
                l++; 
                r++;
            } else {
                l = l - r + 1;
                r = 0;
            }
        } 
        if(r == len2) {
            return l - r;
        }
        return -1;
    }
}
```

### KMP算法

![KMP算法](https://gitee.com/zhang-songyao/blog-images/raw/master/20210420180334.gif)

![image-20210420180546175](https://gitee.com/zhang-songyao/blog-images/raw/master/20210420180547.png)

#### 计算next数组

```java
private static int[] getNext(String target) {
    //创建一个数组
    int[] next = new int[target.length()];
    //定义两个变量
    int len = -1;//指向当前公共前缀的前端的末尾
    int y = 0;//指向当前公共前缀的后端的末尾
    //赋初值
    next[0] = -1;
    while(y < target.length() - 1) {
        if (len == -1 || target.charAt(len) == target.charAt(y)) {
            len++;
            y++;
            next[y] = len;
        } else {
            len = next[len];
        }
    }
    return next;
}
```

#### 为什么要进行next回溯

![image-20210420181035587](https://gitee.com/zhang-songyao/blog-images/raw/master/20210420181100.png)

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210420181101.png" alt="image-20210420181043866"/>

## [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

>实现 strStr() 函数。
>
>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
>
>
>说明：
>
>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

示例 1：

```
输入：haystack = "hello", needle = "ll"
输出：2
```

示例 2：

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length() == 0) return 0;
        return kmpSearch(haystack, needle);
    }

    public int kmpSearch(String haystack, String needle) {
        int[] next = getNext(needle);
        int x = 0;
        int y = 0;
        while(x < haystack.length() && y < needle.length()) {
            if(y == -1 || haystack.charAt(x) == needle.charAt(y)) {
                x++;
                y++;
            } else {
                y = next[y];
            }
        }
        if(y == needle.length()) {
            return x - y;
        } 
        return -1;
    }

    public int[] getNext(String needle) {
        int[] next = new int[needle.length()];
        int len = -1;
        int y = 0;
        next[0] = -1;
        while(y < needle.length() - 1) {
            if(len == -1 || needle.charAt(len) == needle.charAt(y)) {
                len++;
                y++;
                next[y] = len;
            } else {
                len = next[len];
            }
        }
        return next;
    }
}
```

# 前缀和

## [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。

**示例 1：**

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```

### 前缀和 + 哈希

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int len = nums.length;
        if(len < 2) return false;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        int remainder = 0;
        for(int i = 0; i < len; i++) {
            remainder = (remainder + nums[i]) % k;
            if(map.containsKey(remainder)) {
                int index = map.get(remainder);
                if(i - index >= 2) return true;
            } else {
                map.put(remainder, i);
            }
        }
        return false;
    }
}
```



# 位图算法

> 业务场景

为了帮助公司精准精准定位用户群体，需要开发一个用户画像系统，实现用户信息的标签化

用户标签包括用户的社会属性，生活习惯，消费行为等信息

通过用户标签，可以对多样的用户群体进行统计，例如统计男女比例、统计喜欢旅游的用户数量

| Name | Sex  | Age  | Occupation | Phone |
| :--: | :--: | :--: | :--------: | :---: |
| 张三 |  男  | 90后 |   程序员   | 苹果  |
| 李四 |  男  | 90后 |   程序员   | 三星  |
| 王五 |  女  | 80后 |    学生    | 华为  |

如果快速定位90后程序员，在数据量很小的时候，可以使用SQL查询，当标签越来越多，用户越来越多的时候，需要不断的扩充行和列，最终查询效率会很慢

> 解决办法

针对用户标签建立一个个位图

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210517092422.png" alt="image-20210517092420071" style="zoom:80%;" />



> 位图的优势

每一个用户ID只占用1bit，如果存入哈希表的话，则需要至少4字节（32bit）节省了大量的内存

```java
/**
 * @author ：zsy
 * @date ：Created 2021/5/17 8:56
 * @description：Bitmap算法
 */
public class BitmapTest {
    public static void main(String[] args) {
        BitMap bitMap = new BitMap(128);
        bitMap.setBit(126);
        System.out.println(bitMap.getBit(16));
        System.out.println(bitMap.getBit(126));
    }
}

class BitMap {
    //每一个word是一个long类型的元素，对应一个64位二进制数据
    private long[] words;
    private int size;

    private int getWordIndex(int i) {
        return i >> 6;
    }

    public BitMap(int size) {
        this.size = size;
        this.words = new long[getWordIndex(size - 1) + 1];
    }

    public boolean getBit(int bitIndex) {
        if(bitIndex < 0 || bitIndex > size - 1) {
            throw new IndexOutOfBoundsException("超过Bitmap的有效范围");
        }
        int wordIndex = getWordIndex(bitIndex);
        return (words[wordIndex] & (1L << bitIndex)) != 0;
    }

    public void setBit(int bitIndex) {
        if(bitIndex < 0 || bitIndex > size - 1) {
            throw new IndexOutOfBoundsException("超过Bitmap的有效范围");
        }
        int wordIndex = getWordIndex(bitIndex);
        words[wordIndex] |= (1L << bitIndex);
    }
}
```

# 红包算法

```java
/**
 * @author ：zsy
 * @date ：Created 2021/5/17 9:27
 * @description：红包算法
 */
public class RedEnvelopesTest {
    public static void main(String[] args) {
        RedEnvelopes redEnvelopes = new RedEnvelopes(5, 100);
        System.out.println(redEnvelopes.amountList);
    }
}

class RedEnvelopes {
    List<Integer> amountList;

    public RedEnvelopes(int peopleNum, int totalAmount) {
        this.amountList = new ArrayList<>();
        Random random = new Random();
        int restAmount = totalAmount;
        int restPeopleNum = peopleNum;
        for(int i = 0; i < peopleNum - 1; i++) {
            int amount = random.nextInt(restAmount / restPeopleNum * 2 - 1) + 1;
            restAmount -= amount;
            restPeopleNum--;
            amountList.add(amount);
        }
        amountList.add(restAmount);
    }
}
```

# 二叉堆

> 什么是二叉堆

二叉堆本质上是一种完全二叉树，它分为两个类型

- 最大堆：最大堆的任何一个父节点的值，都大于等于它的左、右孩子节点的值（堆顶就是整个堆的最大元素）
- 最小堆：最小堆的任何一个父节点的值，都小于等于它的左、右孩子节点的值（堆顶就是整个堆的最小元素）

二叉堆的根节点叫做堆顶

> 二叉堆的基本操作

1. 插入节点
2. 删除节点
3. 构建二叉堆

这几种操作都基于堆的自我调整，所谓堆自我调整，就是把一个不符合堆的完全二叉树，调整成一个堆，下面以最小堆为例。

## 插入

插入节点0的过程

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210520234454.png" alt="image-20210520234450846" style="zoom:80%;" />

## 删除

删除节点的过程和插入的过程刚好相反，所删除的是处于堆顶的节点。例如删除1

- 为了维持完全二叉树的结构，把堆的最后一个元素临时补充到堆顶
- 删除原来10的位置
- 对堆顶的节点10执行下沉操作

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210521090817.png" alt="image-20210521090813943" style="zoom:80%;" />

## 构建

构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有的非叶子节点一次**下沉**

![image-20210521091253667](https://gitee.com/zhang-songyao/blog-images/raw/master/20210521091328.png)

![image-20210521091322240](https://gitee.com/zhang-songyao/blog-images/raw/master/20210521091332.png)

## 二叉堆代码实现

> 二查堆虽然是一颗完全二叉树，但它的存储方式并不是链式的，而是顺序存储，换句话说，二叉堆的所有节点都存储在数组中

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210521092649.png" alt="image-20210521092645498" style="zoom:80%;" />

当父节点为parent时，左孩子为2 * parent + 1；右孩子为2 * parent + 2

```java
public class HeapTest {

    public static void main(String[] args) {
        int[] arr = {1, 3, 2, 6, 5, 7, 8, 9, 10, 0};
        Heap heap = new Heap(arr);
        heap.upAdjust(arr);
        System.out.println(Arrays.toString(arr));
        arr = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        heap = new Heap(arr);
        heap.buildHead();
        System.out.println(Arrays.toString(arr));
    }
}

class Heap {
    private int[] arr;

    public Heap(int[] arr) {
        this.arr = arr;
    }

    public void buildHeap() {
        //从最后一个非叶子节点开始，依次下沉
        for (int i = (arr.length - 2) / 2; i >= 0; i--) {
            downAdjust(arr, i, arr.length);
        }
    }

    private void downAdjust(int[] arr, int parentIndex, int length) {
        int temp = arr[parentIndex];
        int childrenIndex = parentIndex * 2 + 1;
        while (childrenIndex < length) {
            //如果有右孩子，并且右孩子小于左孩子，那么定位到右孩子
            if (childrenIndex + 1 < length && arr[childrenIndex + 1] < arr[childrenIndex]) {
                childrenIndex++;
            }
            //如果父节点小于较小孩子节点的值，直接跳出
            if (temp <= arr[childrenIndex]) break;
            //无需交换，单向赋值
            arr[parentIndex] = arr[childrenIndex];
            parentIndex = childrenIndex;
            childrenIndex = 2 * childrenIndex + 1;
        }
        arr[parentIndex] = temp;
    }

    public void upAdjust(int[] arr) {
        int childrenIndex = arr.length - 1;
        int parentIndex = (childrenIndex - 1) / 2;
        int temp = arr[childrenIndex];
        while (childrenIndex > 0 && temp < arr[parentIndex]) {
            //单向赋值
            arr[childrenIndex] = arr[parentIndex];
            childrenIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        arr[childrenIndex] = temp;
    }
}
```

# 逆波兰计算器

本文主要是对逆波兰计算器的原理介绍和代码实现，所以对前缀、中缀、后缀表达式不做过多的赘述，下面先简单介绍一下后缀表达式

后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111558.png)

举例： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

**后缀表达式的计算机求值**

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为

表达式的结果 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1  左至右扫描，将3和4压入堆栈；

2  遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；

3  将5入栈；

4  接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 

5  将6入栈；

6  最后是-运算符，计算出35-6的值，即29，由此得出最终结果

不难看出，逆波兰计算器的重点不是计算，而是将用户输入的中缀表达式转换为后缀表达式

中缀表达式转换成后缀表达式的步骤

1 初始化两个栈：运算符栈s1和储存中间结果的栈s2；

2 从左至右扫描中缀表达式；

3 遇到操作数时，将其压s2；

4 遇到运算符时，比较其与s1栈顶运算符的优先级：

  (1) 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；

  (2) 否则，若优先级比栈顶运算符的高，也将运算符压入s1；

  (3) 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；   

5 遇到括号时：

  (1) 如果是左括号“(”，则直接压入s1

  (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6 重复步骤2至5，直到表达式的最右边

7 将s1中剩余的运算符依次弹出并压入s28 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

下面看一个实例

由用户输入 1+((2+3)*4)-5表达式，计算对应的结果

将1+((2+3)*4)-5表达式转换为后缀表达式

初始化两个栈，运算符栈s1和储存中间结果的栈s2，设置一个指针，从中缀表达式的左边开始向右边扫描

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111612.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

扫描到1，1是操作数，所以直接压入s2栈中

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105045.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到“+”，是运算符，但是因为s1栈为空，所以直接压入s1栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105048.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到两个“(”，直接压入s1栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105052.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到2，操作数，直接压入s2栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105054.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到“+”，因为s1栈顶元素不是运算符，所以继续压栈

继续扫描，扫描到操作数，直接压入s2栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105057.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到右括号，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

![img](https://img-blog.csdnimg.cn/20201123194021184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk2MjA4,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到*，因为s1栈顶元素不是运算符，所以继续压栈

继续扫描，扫描到4，直接压入s2栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105059.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到扫描到右括号，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105104.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

继续扫描，扫描到“-”，因为此时栈顶是运算符，目前元素的优先接不高于(<=)栈顶运算符优先级，所以将s1栈顶的运算符弹出并压入到s2中，再次判断目前元素与s1中新的栈顶运算符相比较

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105101.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

此时栈顶没有元素，所以将“-”压入s1

继续扫描，扫描到5，直接压入s2栈

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105135.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

此时，扫描就结束了，所以只需要将s1栈中的运算符一次压入s2中即可

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626105110.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

此时，s2栈中就是后缀表达式的逆序1 2 3 + 4 × + 5 –

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111623.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

下面看代码实现

由用户输入 1+((2+3)*4)-5表达式，首先先将用户输入的表达式转成中缀表达式对应的List

```java
 /**
     * 将中缀表达式字符串转成对应的List
     * @param s 输入字符串
     * @return
     */
    public static List<String> toInfixExpresstionList(String s){
        List<String> ls = new ArrayList<>();
        //索引，用于遍历中缀表达式字符串
        int i = 0;
        //用于多位数字的拼接
        String str;
        //每遍历到一个字符，就放入c中
        char c;
        do{
            //如果c是一个符号，直接拼接
            if ((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57){
                ls.add("" + c);
                i++;
            }else{
                //扫描到的是一个数字
                str = "";
                //考虑多位数
                while(i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57){
                    str += s.charAt(i);
                    i++;
                }
                ls.add(str);
            }
        }while(i < s.length());

        return ls;
    }
```

然后将中缀表达式的List集合转换成后缀表达式的List集合

代码优化

这里s2没有使用栈数据结构，因为s2整个过程中没有出栈的操作，使用ArrayList，不需要反转

因为这个过程需要判断优先级，所以创建一个Operation类返回运算符的优先级

```java
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;
    public static int getValue(String ch){
        int res = 0;
        switch(ch){
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
                System.out.println("没有匹配到该字符");
                break;
        }
        return res;
    }
}
```

```java
/**
     * 中缀表达式转后缀表达式
     * @param ls    中缀表达式
     * @return
     */
    public static List<String> parseSuffixExpresstion(List<String> ls){
        //定义两个栈
        Stack<String> s1 = new Stack<>();
        //因为整个过程中s2没有发生过弹栈，所以将s2栈换成一个List
        //Stack<String> s2 = new Stack<>();
        List<String> s2 = new ArrayList<>();
        for(String item : ls){
            if(item.matches("\\d+")){//数字
                s2.add(item);
            }else if(item.equals("(")){//如果是左括号“(”，则直接压入s1
                s1.push(item);
            }else if(item.equals(")")){//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while(!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();// 将“(”弹栈
            }else{//遇到运算符时，比较其与s1栈顶运算符的优先级：
                while(s1.size() != 0 && Operation.getValue(item) <= Operation.getValue(s1.peek())){
                    s2.add(s1.pop());
                }
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并压入s2
        while(s1.size() !=0){
            s2.add(s1.pop());
        }
        return s2;
    }
```

根据后缀表达式来计算结果(本文的一开始，已经将该部分的思路阐述清楚了)

```java
/**
     * 将List集合入栈，并计算值
     * @param ls
     * @return
     */
    public static int calculate(List<String> ls){
        Stack<String> stack = new Stack<String>();
        for(String item : ls){
            if (item.matches("\\d+")){
                stack.push(item);
            }else{
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                switch(item){
                    case "+" :
                        res = num1 + num2;
                        break;
                    case "-" :
                        res = num2 - num1;
                        break;
                    case "*" :
                        res = num1 * num2;
                        break;
                    case "/" :
                        res = num2 / num1;
                        break;
                    default :
                        throw new RuntimeException(item + "符号不匹配");
                }
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }
```

以上就是逆波兰计算器的实现全过程，代码仍不完整

需要优化的部分：

支持 + - * / ( )  

多位数，支持小数,

兼容处理, 过滤任何空白字符，包括空格、制表符、换页符

所有代码

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //中缀表达式"1+((2+3)×4)-5"
        String expresstion = "1+((20+3)*4)-5";
        List<String> infixExpresstion = toInfixExpresstionList(expresstion);
        System.out.println("中缀表达式字符串:" + expresstion);
        System.out.println("中缀表达式:" + infixExpresstion);
        List<String> suffixExpresstion = parseSuffixExpresstion(infixExpresstion);
        System.out.println("后缀表达式:" + suffixExpresstion);
        int res = calculate(suffixExpresstion);
        System.out.println("计算结果 = " + res);
    }

    /**
     * 将后缀表达式转换为ArrayList
     * @param suffixExpresstion 后缀表达式
     * @return
     */
    public static List<String> getList(String suffixExpresstion){
        String[] split = suffixExpresstion.split(" ");
        List<String> list = new ArrayList<String>();
        for(String ele : split){
            list.add(ele);
        }
        return list;
    }

    /**
     * 将中缀表达式字符串转成对应的List
     * @param s 输入字符串
     * @return
     */
    public static List<String> toInfixExpresstionList(String s){
        List<String> ls = new ArrayList<>();
        //索引，用于遍历中缀表达式字符串
        int i = 0;
        //用于多位数字的拼接
        String str;
        //每遍历到一个字符，就放入c中
        char c;
        do{
            //如果c是一个符号，直接拼接
            if ((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57){
                ls.add("" + c);
                i++;
            }else{
                //扫描到的是一个数字
                str = "";
                //考虑多位数
                while(i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57){
                    str += s.charAt(i);
                    i++;
                }
                ls.add(str);
            }
        }while(i < s.length());

        return ls;
    }

    /**
     * 中缀表达式转后缀表达式
     * @param ls    中缀表达式
     * @return
     */
    public static List<String> parseSuffixExpresstion(List<String> ls){
        //定义两个栈
        Stack<String> s1 = new Stack<>();
        //因为整个过程中s2没有发生过弹栈，所以将s2栈换成一个List
        //Stack<String> s2 = new Stack<>();
        List<String> s2 = new ArrayList<>();
        for(String item : ls){
            if(item.matches("\\d+")){//数字
                s2.add(item);
            }else if(item.equals("(")){//如果是左括号“(”，则直接压入s1
                s1.push(item);
            }else if(item.equals(")")){//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while(!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();// 将“(”弹栈
            }else{//遇到运算符时，比较其与s1栈顶运算符的优先级：
                while(s1.size() != 0 && Operation.getValue(item) <= Operation.getValue(s1.peek())){
                    s2.add(s1.pop());
                }
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并压入s2
        while(s1.size() !=0){
            s2.add(s1.pop());
        }
        return s2;
    }

    /**
     * 将List集合入栈，并计算值
     * @param ls
     * @return
     */
    public static int calculate(List<String> ls){
        Stack<String> stack = new Stack<String>();
        for(String item : ls){
            if (item.matches("\\d+")){
                stack.push(item);
            }else{
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                switch(item){
                    case "+" :
                        res = num1 + num2;
                        break;
                    case "-" :
                        res = num2 - num1;
                        break;
                    case "*" :
                        res = num1 * num2;
                        break;
                    case "/" :
                        res = num2 / num1;
                        break;
                    default :
                        throw new RuntimeException(item + "符号不匹配");
                }
                stack.push("" + res);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}

class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;
    public static int getValue(String ch){
        int res = 0;
        switch(ch){
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
                System.out.println("没有匹配到该字符");
                break;
        }
        return res;
    }
}
```

# 排序算法

## 排序算法介绍

排序也称排序算法
 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

排序的分类：

1) 内部排序:

指将需要处理的所有数据都加载到内部存储器中进行排序。

2) 外部排序法：

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

常见的排序的排序算法分类如图：

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110308.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

## 冒泡排序

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

原始数组：3, 9, -1, 10, 20

第一趟排序

(1)  3, 9, -1, 10, 20  // 如果相邻的元素逆序就交换

(2)  3, -1, 9, 10, 20

(3)  3, -1, 9, 10, 20

(4)  3, -1, 9, 10, 20 

第二趟排序

(1) -1, 3, 9, 10, 20 //交换

(2) -1, 3, 9, 10, 20

(3) -1, 3, 9, 10, 20

第三趟排序

(1) -1, 3, 9, 10, 20 

(2) -1, 3, 9, 10, 20 

第四趟排序

(1) -1, 3, 9, 10, 20

小结冒泡排序规则

(1) 一共进行 数组的大小-1 次 大的循环

(2)每一趟排序的次数在逐渐的减少

(3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下 来没有进行过交换，就说明序列有序，因此要在排序过程中设置 一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这

里说的优化，可以在冒泡排序写好后，在进行)

代码实现

```java
public static void bubbleSort(int[] arr){
        int temp = 0;
        //标识变量，表示是否进行过交换
        boolean flag = false;
        //时间复杂度O(n^2)
        for (int i = 0; i < arr.length - 1; i++) { //一共要排序几次
            for (int j = 0; j < arr.length - 1 - i; j++) {//每次排序需要比较的次数
                if (arr[j] > arr[j + 1]){
                    flag = true;
                    temp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }
            if (flag){//出现过交换，重置flag
                flag = false;
            }else//在上一趟排序中，一次交换也没有发生过
                break;
        }
    }
```

## 选择排序

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

选择排序思想

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列

原始的数组 ： 101, 34, 119, 1

第一轮排序 :  1, 34, 119, 101

第二轮排序 :  1, 34, 119, 101

第三轮排序 :  1, 34, 101, 119

小结选择排序的规则

\1. 选择排序一共有 数组大小 - 1 轮排序

\2. 每1轮排序，又是一个循环, 循环的规则(代码)

2.1先假定当前这个数是最小数

2.2 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标

2.3 当遍历到数组的最后时，就得到本轮最小数和下标 2.4 交换 [代码中再继续说 ]

代码实现

```java
public static void selectSort(int[]arr){
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]){
                    minIndex = j;
                    min = arr[j];
                }
            }
            //将最小值放在arr[i],即交换
            if (minIndex != i){//如果最小值的下标改变了则交换
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
    }
```

## 插入排序

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

插入排序思想

插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

原始的数组 ： (101), 34, 119, 1

橘色箭头表示待插入的元素下标

绿色箭头表示待插入元素

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110317.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

第一次插入排序

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110318.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

第二次插入排序

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110322.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

第三次插入排序

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110327.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

代码实现

```java
public static void insertSort(int[] arr){
        int insertIndex = 0;
        int insertValue = 0;
        for (int i = 1; i < arr.length; i++) {
            insertIndex = i - 1;
            insertValue = arr[i];
            while(insertIndex >= 0 && arr[insertIndex] > insertValue){
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //优化是否需要赋值
            if (insertIndex + 1 != i){
                arr[insertIndex + 1] = insertValue;
            }
        }
    }
```

分析简单插入排序存在的问题

我们看简单的插入排序可能存在的问题.

数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：

{2,3,4,5,6,6}

{2,3,4,5,5,6}

{2,3,4,4,5,6}

{2,3,3,4,5,6}

{2,2,3,4,5,6}

{1,2,3,4,5,6}

结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.

## 希尔排序

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

希尔排序基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110331.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110342.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

为了方便大家理解

希尔排序时，对有序序列在插入时先采用交换法(冒泡法)

```java
public static void shellSort(int[] arr){
        int temp = 0;
        int count = 0;
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]){//这里采用交换法
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
        }
    }
```

希尔排序时，对有序序列在插入时采用移位法（真正的希尔排序）(插入法)

```java
public static void shellSort(int[]arr){
        int count = 0;
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                int insertIndex = i - gap;
                int insertValue = arr[insertIndex + gap];
                while(insertIndex >= 0 && insertValue < arr[insertIndex]){
                    arr[insertIndex + gap] = arr[insertIndex];
                    insertIndex -= gap;
                }
                if (insertIndex != (i - gap)){
                    arr[insertIndex + gap] = insertValue;
                }
            }
        }
    }
```

## 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110345.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110357.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

代码实现

```java
 public static void quickSort(int[] arr,int left,int right){
        int r = right;
        int l = left;
        int temp = 0;
        int pivot = arr[(right + left) / 2];
        while(l < r){
            while(arr[l] < pivot){
                l++;
            }
            while(arr[r] > pivot){
                r--;
            }
            if(l == r)
                break;
            temp = arr[r];
            arr[r] = arr[l];
            arr[l] = temp;
            if (arr[l] == pivot){
                r--;
            }
            if (arr[r] == pivot){
                l++;
            }
        }
        if (l == r){
            l += 1;
            r -= 1;
        }
        //向左递归
        if(left < r){
            quickSort(arr,left,r);
        }
        //向右递归
        if(right > l){
            quickSort(arr,l,right);
        }
    }
```

### 我认为比较好理解的写法

```java
public static void quickSort(int[] arr,int left,int righ
    if(left >= right) return;
    int l = left;
    int r = right;
    int pivot = arr[l];
    while(l < r) {
        while(l < r && arr[r] >= pivot) {
            r--;
        }
        if(l < r) {
            arr[l] = arr[r];
        }
        while(l < r && arr[l] <= pivot) {
            l++;
        }
        if(l < r) {
            arr[r] = arr[l];
        }
        if(l >= r) {
            arr[l] = pivot;
        }
    }
    quickSort(arr, left, r - 1);
    quickSort(arr, r + 1, right);
}
```

## 归并排序

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110404.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

说明: 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110409.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110415.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

代码实现

治

```java
/**
     *
     * @param arr   排序的原始数组
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  中转数组
     */
    public static void merge(int[] arr,int left,int mid,int right,int[]temp){
        //System.out.println("*****");

        int i = left;
        int j = mid + 1;
        int t = 0;

        /*
        (一)
        先把两边有序的数据按照规则填充到temp数组
        指导左右两边的有序序列，有一边处理完毕
        */
        while(i <= mid && j <= right){
            temp[t++] = arr[i] > arr[j] ? arr[j++] : arr[i++];
        }

        /*
        (二)
        把所有剩余数据的一边一次全部填充到temp
         */
        while(i <= mid){
            temp[t++] = arr[i++];
        }
        while (j <= right){
            temp[t++] = arr[j++];
        }

        /*
        (三)
        将temp数组的元素拷贝到arr
         */
        t = 0;
        int tempLeft = left;
        //System.out.println("tempLeft = " + tempLeft + "right = " + right);
        while(tempLeft <= right){
            arr[tempLeft++] = temp[t++];
        }
    }
```

分（递归）

```java
public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if(left < right){
            int mid = (left + right) / 2;
            mergeSort(arr,left,mid,temp);
            mergeSort(arr,mid + 1,right,temp);
            merge(arr,left,mid,right,temp);
        }
    }
```

## 基数排序（桶排序）

1、基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用

2、基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法

3、基数排序(Radix Sort)是桶排序的扩展

4、基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

基数排序的基本思想

将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤

数组的初始状态 arr = {53, 3, 542, 748, 14, 214}

第1轮排序:

(1) 将每个元素的个位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110421.png)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

数组的第1轮排序 arr = {542, 53, 3, 14, 214, 748}  

第2轮排序:

(1) 将每个元素的十位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110424.png)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

数组的第2轮排序 arr = {3, 14, 214, 542, 748, 53} 

第3轮排序:

(1) 将每个元素百位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110428.png)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

数组的第3轮排序 arr = {3, 14, 53, 214, 542, 748}

以上就是基数排序的实现过程

代码实现

代码说明

获取数组最大元素的位数

使用二维数组bucket[10][arr.length]模拟桶

使用bucketElementCounts[10]模拟每个桶的指针

```java
 public static void redixSort(int[]arr){
        //获取数组中最大元素的位数
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if(max < arr[i])
                max = arr[i];
        }
        int maxLength = (max + "").length();
        //定义一个二维数组模拟桶
        int [][] bucket = new int[10][arr.length];
        //为了记录每个桶中的元素个数定义一个一维数组
        int [] bucketElementCounts = new int[10];
        for (int i = 0, n = 1; i < maxLength; i++,n *= 10) {
            //入桶
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n %10;
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index = 0;
            //出桶
            for (int j = 0; j < bucketElementCounts.length; j++) {
                if(bucketElementCounts[j] != 0){
                    for (int k = 0; k < bucketElementCounts[j]; k++) {
                        arr[index++] = bucket[j][k];
                    }
                }
                //取出元素后，需要将bucketElementCount中的元素清零
                bucketElementCounts[j] = 0;
            }
            //System.out.println("第" + (i + 1) + "次排序后的数组" + Arrays.toString(arr));
        }
    }
```

排序算法的速度测试

下面我创建了一个长度分别为80000的随机数组进行测试

硬件:CPU8代i7

```java
public static void main(String[] args) {
        System.out.println("测试排序算法的时间");
        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random() * 8000000);
        }
        Long startTime = System.currentTimeMillis();
        redixSort(arr);
        Long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime + "ms");
    }
```

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626110435.png)![点击并拖拽以移动]

相关术语解释：

稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；

内排序：所有排序操作都在内存中完成；

外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

时间复杂度： 一个算法执行所耗费的时间。

空间复杂度：运行完一个程序所需内存的大小。

n: 数据规模

k: “桶”的个数

In-place:   不占用额外内存

Out-place: 占用额外内存

# 赫夫曼树

##  赫夫曼树基本介绍

1、给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。

2、赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

赫夫曼树几个重要概念和举例说明

1、路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

2、结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

3、树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

4、WPL最小的就是赫夫曼树

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111335.png)

## 生成赫夫曼数的基本思路

给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树.

构成赫夫曼树的步骤：

1、从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树

2、取出根节点权值最小的两颗二叉树

3、组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  

4、再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

图解

{13, 7, 8, 3, 29, 6, 1}  

1、排序 {1, 3, 6, 7, 8, 13, 29}

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111331.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

2、重新排序，重新构建新的树

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111328.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111323.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111318.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

以此类推........

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111314.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

代码实现

构建节点

```java
class Node implements Comparable<Node>{
    public int value;
    public Node left;
    public Node right;

    public Node(int value){
        this.value = value;
    }

    public void preOrder(){
        System.out.println(this);
        if(this.left != null)
            this.left.preOrder();
        if(this.right != null)
            this.right.preOrder();
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

创建赫夫曼树

```java
public static Node createHuffmanTree(int[]arr){
        ArrayList<Node> nodes = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            nodes.add(new Node(arr[i]));
        }
        while(nodes.size() > 1){
            Collections.sort(nodes);
            Node left = nodes.get(0);
            Node right = nodes.get(1);
            Node parent = new Node(left.value + right.value);
            parent.left = left;
            parent.right = right;
            nodes.add(parent);
            nodes.remove(left);
            nodes.remove(right);
        }
        return nodes.get(0);
    }
```

## 赫夫曼编码

1、赫夫曼编码也翻译为   哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法

2、赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。

3、赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间

4、赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

通信领域中信息的处理方式1-定长编码 i like like like java do you like a java    // 共40个字符(包括空格)  

105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  //对应Ascii码

01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制

按照二进制来传递信息，总的长度是  359  (包括空格)

[在线转码工具](https://www.mokuge.com/tool/asciito16/)

通信领域中信息的处理方式2-变长编码

i like like like java do you like a java    // 共40个字符(包括空格)

d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5  :9  // 各个字符对应的个数 0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d  说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.

按照上面给各个字符规定的编码，则我们在传输  "i like like like java do you like a java" 数据时，编码就是 10010110100...  

字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码

通信领域中信息的处理方式3-赫夫曼编码

i like like like java do you like a java    // 共40个字符(包括空格)

d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5  :9  // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111311.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

//根据赫夫曼树，给各个字符 //规定编码 ， 向左的路径为0 //向右的路径为1 ， 编码如下:

o: 1000  u: 10010  d: 100110  y: 100111  i: 101 a : 110   k: 1110   e: 1111    j: 0000    v: 0001 l: 001      : 01

按照上面的赫夫曼编码，我们的"i like like like java do you like a java"  字符串对应的编码为 (注意这里我们使用的无损压缩) 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110

长度为 ： 133

说明:

1、原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%

2、此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性

注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111306.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

## 赫夫曼编码代码实现

构建节点

```java
class Node implements Comparable<Node>{
    public Byte data;
    public int weight;
    public Node left;
    public Node right;

    public Node(Byte data,int weight){
        this.data = data;
        this.weight = weight;
    }

    public void preOrder(){
        System.out.println(this);
        if (this.left != null)
            this.left.preOrder();
        if(this.right != null)
            this.right.preOrder();
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }
}
```

1、将每个数据转换成一个节点，存放在List集合中

```java
private static ArrayList<Node> getList(byte[]bytes){
        ArrayList<Node> nodes = new ArrayList<>();
        Map<Byte,Integer> map = new HashMap<>();
        for(byte b : bytes){
            Integer count = map.get(b);
            if(count == null){
                map.put(b,1);
            }else
                map.put(b,map.get(b) + 1);
        }
        //遍历map
        for(Map.Entry<Byte,Integer> entry : map.entrySet()){
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        return nodes;
    }
```

2、根据List集合获取哈夫曼树

```java
private static Node createHuffmanTree(List<Node> nodes){
        while(nodes.size() > 1){
            Collections.sort(nodes);
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            Node parent = new Node(null,leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);
        }
        return nodes.get(0);
    }
```

3、根据哈夫曼树获取哈夫曼编码表(这里使用了方法重载机制，方便传参)

```java
static Map<Byte,String> huffmanCodes = new HashMap<>();
    static StringBuilder stringBuilder = new StringBuilder();

    private static Map<Byte,String> getCodes(Node root){
        if (root == null)
            return null;
        getCodes(root,"",stringBuilder);
        return huffmanCodes;
    }

    //根据哈夫曼树获得哈夫曼编码
    private static void getCodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);
        stringBuilder1.append(code);
        if(node.data == null) {//非叶子节点
            //向左递归
            getCodes(node.left,"0",stringBuilder1);
            //向右递归
            getCodes(node.right,"1",stringBuilder1);
        }else {
            huffmanCodes.put(node.data,stringBuilder1.toString());
        }
    }
```

4、根据原字节数组和哈夫曼编码表对数据进行压缩

```java
private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
        StringBuilder builder = new StringBuilder();
        for(byte b : bytes){
            builder.append(huffmanCodes.get(b));
        }
        int length = (builder.length() + 7) / 8 ;
        byte[] by = new byte[length];
        int index = 0;
        String str;
        for (int i = 0; i < builder.length(); i += 8) {
            if((i + 8) > builder.length()){
                str = builder.substring(i);
                by[index] = (byte)Integer.parseInt(str,2);
                index++;
            }else {
                str = builder.substring(i, i + 8);
                by[index] = (byte)Integer.parseInt(str,2);
                index++;
            }
        }
        return by;
    }
```

5、为了方便后期的使用，对压缩进行一下封装

```java
private static byte[] huffmanZip(byte[] bytes){
        //获取ArrayList<Node>集合
        ArrayList<Node> nodes = getList(bytes);
        //获取哈夫曼树
        Node root = createHuffmanTree(nodes);
        //获取哈夫曼编码表
        Map<Byte,String>huffmanCodes = getCodes(root);
        //压缩数据
        byte[]huffmanCodesBytes = zip(bytes,huffmanCodes);
        return huffmanCodesBytes;
    }
```

压缩后的哈夫曼字节数组是[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]

## 解码（解压）

6、编写一个方法将字节转换成二进制，这里正数需要补全高八位，负数需要截取第八位补码，如果是最后一位，则不需要做任何操作，直接转换

```java
/**
     * 将字节类型的十进制转换为二进制的字符串类型
     * @param flag 是否是最后一位，最后一位不需要补高位
     * @param b 带转换的字节
     * @return
     */
    private static String byteToBitString(boolean flag,byte b){
        int temp = b;
        if(flag){
            temp |= 256;//正数需要补高位；
        }
        String str = Integer.toBinaryString(temp);
        if(flag){
            return str.substring(str.length() - 8);
        }else
            return str;
    }
```

7、解压，这里先将哈夫曼编码字节数组转换成StringBuilder，然后将哈夫曼编码表反转得到解码表，然后对照解码表进行解码。并封装在List集合中

```java
/**
     * 解压
     * @param huffmanCodesBytes 哈夫曼编码后的字节数组
     * @param huffmanCodes 哈夫曼编码表
     * @return 哈夫曼编码前的字节数组
     */
    public static byte[] deCode(byte[]huffmanCodesBytes,Map<Byte,String> huffmanCodes){
        boolean flag = true;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < huffmanCodesBytes.length; i++) {
            byte b = huffmanCodesBytes[i];
            if(i == huffmanCodesBytes.length - 1)
                flag = false;
            builder.append(byteToBitString(flag,b));
        }
        String str = builder.toString();
        //将hashMap反转
        Map<String,Byte> map = new HashMap<>();
        for (Map.Entry<Byte,String> entry : huffmanCodes.entrySet()){
            map.put(entry.getValue(),entry.getKey());
        }
        ArrayList<Byte> list = new ArrayList<>();
        int start = 0;
        int end = 1;
        while(start < str.length()){
            while(end < str.length() && map.get(str.substring(start,end)) == null){
                end++;
            }
            list.add(map.get(str.substring(start,end)));
            start = end;
        }
        byte[] b = new byte[list.size()];
        for (int i = 0; i < b.length; i++) {
            if(list != null) {
                b[i] = list.get(i);
            }
        }
        return b;
    }
```

测试

```java
public static void main(String[] args) {
        String constant = "i like like like java do you like a java";
        System.out.println(constant);
        byte[] constantBytes = constant.getBytes();
        byte[] huffmanCodesBytes = huffmanZip(constantBytes);
        Map<Byte, String> huffmanCodes = getCodes(createHuffmanTree(getList(constantBytes)));
        byte[] sourceBytes = deCode(huffmanCodesBytes, huffmanCodes);
        System.out.println(new String(sourceBytes));
    }
```

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111300.png)

可以看到编码前后完全一样，这就实现了整个压缩和解压过程

## 实践

实现对二进制文件的压缩和解压

压缩

```java
public static void zipFile(String srcFile,String dstFile){
        //创建输入流
        FileInputStream is = null;
        //创建输出流和对象输出流
        FileOutputStream os = null;
        ObjectOutputStream oos = null;
        try {
            is = new FileInputStream(srcFile);
            byte[] b = new byte[is.available()];
            is.read(b);
            os = new FileOutputStream(dstFile);
            oos = new ObjectOutputStream(os);
            byte[] huffmanBytes = huffmanZip(b);
            oos.writeObject(huffmanBytes);
            oos.writeObject(huffmanCodes);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

解压

```java
public static void unZipFile(String zipFile,String dstFile){
        //创建输入流和对象输入流
        FileInputStream is = null;
        ObjectInputStream ois = null;
        //创建输出流
        FileOutputStream os = null;
        try {
            is = new FileInputStream(zipFile);
            ois = new ObjectInputStream(is);
            byte[] huffmanBytes = (byte[])ois.readObject();
            Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();
            byte[] bytes = deCode(huffmanBytes,huffmanCodes);
            os = new FileOutputStream(dstFile);
            os.write(bytes);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

测试

```java
        //测试压缩文件
        /*String srcFile = "d://src.bmp";
        String dstFile = "d://src.zip";
        zipFile(srcFile,dstFile);
        System.out.println("压缩成功！");*/

        //测试解压文件
        String zipFile = "d://src.zip";
        String dstFile = "d://src1.bmp";
        unZipFile(zipFile,dstFile);
        System.out.println("解压成功！");
```

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111247.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

压缩前后图片对比

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626111245.png)

# AVL自平衡树

 因为AVL自平衡树是建立在二叉排序树的基础上的，所以这里我先简单描述一下二叉排序树和代码实现。

## 二叉排序树(Binary Sort(Search) Tree)(BST)

二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112244.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

因为二叉排序树的插入比较简单，下面就直接代码实现了

首先创建一个节点类(因为后面的自平衡也会使用这个节点，只是在节点中添加新的方法，后面就不再过多赘述了)

```java
class Node{
    public int val;
    public Node left;
    public Node right;

    public Node(int val){
        this.val = val;
    }

    public void add(Node node){
        if(node == null)
            return;
        if(node.val < this.val){
            if(this.left == null) {
                this.left = node;
            }else {
                this.left.add(node);
            }
        }else {
            if(this.right == null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "val=" + val +
                '}';
    }
}
```

创建二叉搜索树

```java
class BinarySortTree{
    private Node root;

    public void setRoot(Node root) {
        this.root = root;
    }

    public void add(Node node){
        if(root == null){
            root = node;
            return;
        }
        root.add(node);
    }

    public void infixOrder(){
        if(root != null){
            root.infixOrder();
            return;
        }
        System.out.println("二叉排序树为空~~~");
    }
    
}
```

二叉搜索树和节点类已经创建好了，如果需要添加节点，主需要遍历数组添加节点

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112252.gif)

```java
    BinarySortTree binarySortTree = new BinarySortTree();
    int[] arr = {7, 3, 10, 12, 5, 1, 9};
    for (int i = 0; i < arr.length; i++) {
    binarySortTree.add(new Node(arr[i]));
```

下面实现二叉排序树的删除节点功能

因为删除一个节点需要拿到这个节点和这个和节点的双亲节点所以在节点类中添加search()和searchParent()方法，并封装在树类中

```java
public Node search(int val){
    if(this.val == val){
        return this;
    }
    if(val < this.val){
        if (this.left != null){
            return this.left.search(val);
        }else
            return null;
    }else {
        if (this.right != null){
            return this.right.search(val);
        }else
            return null;
    }
}
```



```java
public Node search(int val){
    if(root != null){
        return root.search(val);
    }
    return null;
}
```



```java
public Node searchParent(int val){
    if(this.left != null && this.left.val == val ||
            this.right != null && this.right.val == val){
        return this;
    }
    if(val < this.val && this.left != null){
        return this.left.searchParent(val);
    }else if(val > this.val && this.right != null){
        return this.right.searchParent(val);
    }
    return null;
}
```



```java
public Node searchParent(int val){
    if(root != null){
        return root.searchParent(val);
    }
    return null;
}
```



二叉排序树的删除情况比较复杂，有下面三种情况需要考虑

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112406.png)

1、删除叶子节点 (比如：2, 5, 9, 12)



![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112353.gif)

```java
if(target.left == null && target.right == null){//叶子节点
    if (parent.left != null && parent.left.val == val){
        parent.left = null;
        return;
    }
    if(parent.right != null && parent.right.val == val){
        parent.right = null;
        return;
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

2、删除只有一颗子树的节点 (比如：1)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112422.gif)

```java
else {//有一个子树的叶子节点
   if(parent.left.val == val){
       if(target.left != null){
           parent.left = target.left;
           return;
       }
       if(target.right != null){
           parent.left = target.right;
           return;
       }
   }else {
       if(target.left != null){
           parent.right = target.left;
           return;
       }
       if(target.right != null){
           parent.right= target.right;
           return;
       }
   }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

3、删除有两颗子树的节点. (比如：7, 3，10 )

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112504.gif)

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112511.gif)

这里有两种方式，要么是删除右子树的最小值，要么是删除左子树的最大值，两种方法我都是实现，实际中只需要调用一种

```java
public int delLeftMax(Node node){
    Node target = node;
    while (target.right != null){
        target = target.right;
    }
    delNode(target.val);
    return target.val;
}
```



```java
public int delRightTreeMin(Node node){
    Node target = node;
    while(target.left != null){
        target = target.left;
    }
    delNode(target.val);
    return target.val;
}
```



```java
else if(target.left != null && target.right != null){//两颗子树的非叶子节点
   int minVal = delRightTreeMin(target.right);
   target.val = minVal;
```



删除节点代码总结

```java
public void delNode(int val){
    if (root == null){
        return;
    }
    if (root.val == val && root.left == null && root.right == null){
        root = null;
        return;
    }
    Node target = search(val);
    if (target == null)
        return;
    Node parent = searchParent(val);
    if (target.left == null && target.right == null){
        if (parent.left != null && parent.left.val == val){
            parent.left = null;
            return;
        }else{
            parent.right = null;
            return;
        }
    }else if (target.left != null && target.right != null){
        int maxVal = delLeftMax(target.left);
        target.val = maxVal;
    }else {
        if (parent.left != null && parent.left.val == val){
            if (target.left != null){
                parent.left = target.left;
                return;
            }else {
                parent.left = target.right;
                return;
            }
        }else {
            if (target.left != null){
                parent.right = target.left;
                return;
            }else {
                parent.right = target.right;
                return;
            }
        }
    }
}
```

以上就是二叉排序树的实现过程。分析二叉排序可能的问题

给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112522.png)

左边BST 存在的问题分析:

1、左子树全部为空，从形式上看，更像一个单链表.

2、插入速度没有影响

3、查询速度明显降低(因为需要依次比较), 不能发挥BST 的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢

4、解决方案-平衡二叉树(AVL) 

## 平衡二叉树

平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。

具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。

因为这里需要讨论树的深度，所以在节点类中添加了三个方法，height()、leftHeight()、rightHeight()

```java
public int leftHeight(){
    if (left != null){
        return left.height();
    }
    return 0;
}
public int rightHeight(){
    if (right != null){
        return right.height();
    }
    return 0;
}
public int height(){
    return Math.max(left == null ? 0 : left.height(),
            right == null ? 0 : right.height()) + 1;
}
```

AVL树左旋转

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112528.gif)

问题：当插入8 时 rightHeight() - leftHeight() > 1 成立，此时，不再是一颗avl树了.

怎么处理--进行左旋转.

1、 创建一个新的节点 newNode (以4这个值创建) ,创建一个新的节点，值等于当前根节点的值

//把新节点的左子树设置了当前节点的左子树

2、 newNode.left = left //把新节点的右子树设置为当前节点的右子树的左子树

3、newNode.right =right.left; ////把当前节点的值换为右子节点的值

4、value=right.value;

//把当前节点的右子树设置成右子树的右子树

5.、right=right.right;

////把当前节点的左子树设置为新节点

6、 left=newLeft;

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112602.png)

左旋转代码实现

```java
public void leftRotate(){
    Node newNode = new Node(val);
    newNode.left = left;
    newNode.right = right.left;
    val = right.val;
    right = right.right;
    left = newNode;
}
```

AVL右旋转

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112608.gif)

问题：当插入6 时 leftHeight()  - rightHeight()  > 1 成立，此时，不再是一颗avl树了.

怎么处理--进行右旋转.[就是降低左子树的高度], 这里是将 9 这个节点，通过右旋转，到右子树

1.、创建一个新的节点 newNode (以10这个值创建) ,创建一个新的节点，值等于当前根节点的值

//把新节点的右子树设置了当前节点的右子树

2、 newNode.right = right

//把新节点的左子树设置为当前节点的左子树的右子树

3、newNode.left =left.right;

////把当前节点的值换为左子节点的值

4、value=left.value;

//把当前节点的左子树设置成左子树的左子树

5、 left=left.left;

////把当前节点的右子树设置为新节点

6、 right=newLeft;

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112616.png)



右旋转代码实现

```java
public void rightRotate(){
    Node newNode = new Node(val);
    newNode.right = right;
    newNode.left = left.right;
    val = left.val;
    left = left.left;
    right = newNode;
}
```

双旋转分析

前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列 int[] arr = { 10, 11, 7, 6, 8, 9 };  运行原来的代码可以看到，并没有转成 AVL树. int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL树

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112634.png)

所以这里应该先对根节点的左节点进行左旋，再进行右旋，重写add方法

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20210626112640.gif)

```java
public void add(Node node){
    if (node.val < val){
        if (left != null){
            left.add(node);
        }else {
            left = node;
        }
    }else {
        if (right != null){
            right.add(node);
        }else {
            right = node;
        }
    }
    if((leftHeight() - rightHeight()) > 1){
        if (left != null && (left.rightHeight() - left.leftHeight()) > 1){
            left.leftRotate();
            rightRotate();
        }else {
            rightRotate();
            return;
        }
    }
    if ((rightHeight() - leftHeight()) > 1){
        if (right != null && (right.leftHeight() - right.rightHeight()) > 1){
            right.rightRotate();
            leftHeight();
        }else {
            leftRotate();
            return;
        }
    }
```











