# 2021/6/4

> 2021/6/4

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

**示例：**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210604231244.jpeg" alt="img" style="zoom:80%;" />

```tex
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```tex
输入：root = []
输出：[]
```

**示例 3：**

```tex
输入：root = [0]
输出：[0]
```

### 方法一：比较流氓了

前序遍历 + List集合

```java
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        preorderTraversal(root, list);
        int size = list.size();
        for (int i = 1; i < size; i++) {
            TreeNode prev = list.get(i - 1), curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }

    public void preorderTraversal(TreeNode root, List<TreeNode> list) {
        if (root != null) {
            list.add(root);
            preorderTraversal(root.left, list);
            preorderTraversal(root.right, list);
        }
    }
}

```

### 方法二

自己的想法比较麻烦

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        while(root != null) {
            dfs(root);
            root = root.right;
        }
    }
    public TreeNode dfs(TreeNode node) {
        //递归终止条件
        if(node == null || node.left == null) return node;
        //保存当前节点的右孩子
        TreeNode curR = node.right;
        //当前节点是否有做孩子
        //有做孩子的话，递归到最左边的孩子
        node.right = node.left != null ? dfs(node.left) : null;
        //递归完后做孩子赋值为null
        node.left = null;
        //证明当前节点的右孩子发生了变化需要整理右孩子
        if (node.right != curR) {
            TreeNode tmp = node.right;
            //遍历到当前节点最右边的孩子
            while (tmp.right != null) {
                tmp = tmp.right;
            }
            tmp.right = curR;
        }
        return node;
    }
}
```

### 方法三

思路：

对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210604233530.gif" alt="4" style="zoom:80%;" />

#### 递归做法

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null) return;
        TreeNode curL = root.left;
        TreeNode curR = root.right;
        if(curL != null) {
            root.right = curL;
            root.left = null;
            while(curL.right != null) {
                curL = curL.right;
            }
            curL.right = curR;
        } 
        flatten(root.right);
    }
}
```

#### 非递归做法

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while(cur != null) {
            if(cur.left != null) {
                TreeNode next = cur.left;
                TreeNode tmp = next;
                while(tmp.right != null) {
                    tmp = tmp.right;
                }
                tmp.right = cur.right;
                cur.left = null;
                cur.right = next;
            }
            cur = cur.right;
        }
    }
}
```

## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```


填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**示例：**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210604235920.png" alt="img" style="zoom:80%;" />

```tex
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

### 方法一

BFS 空间：O(n) ；时间O(n)

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if(root == null) return null;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            Node pre = null;
            for(int i = 0; i < size; i++) {
                Node next = queue.poll();
                if(next.left != null) {
                    queue.offer(next.left);
                }
                if(next.right != null) {
                    queue.offer(next.right);
                }
                if(pre != null) {
                    pre.next = next;
                }
                pre = next;
            }
        }
        return root;
    }
}
```

### 方法二 进阶

- 从根节点开始。因为第 0 层只有一个节点，不需要处理。可以在上一层为下一层建立next 指针。该方法最重要的一点是：位于第 x 层时为第 x+1 层建立next 指针。一旦完成这些连接操作，移至第 x + 1层为第 x + 2层建立 next 指针。
- 当遍历到某层节点时，该层节点的 next 指针已经建立。这样就不需要队列从而节省空间。每次只要知道下一层的最左边的节点，就可以从该节点开始，像遍历链表一样遍历该层的所有节点。

```.java
class Solution {
    Node last = null, nextStart = null;
    public Node connect(Node root) {
        if(root == null) return null;
        Node start = root;
        while(start != null) {
            last = null;
            nextStart = null;
            for(Node p = start; p != null; p = p.next) {
                if(p.left != null) handle(p.left);
                if(p.right != null) handle(p.right);
            }
            start = nextStart;
        }
        return root;
    }
    
    public void handle(Node p) {
        if(last != null) {
            last.next = p;
        }
        if(nextStart == null) {
            nextStart = p;
        }
        last = p;
    }
}
```

# 2021/6/5

> 2021/6/5

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

**示例 1：**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210605094413.jpeg" alt="img" style="zoom:80%;" />

```tex
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```tex
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```tex
输入：head = [7,7,7,7], val = 7
输出：[]
```

### 方法一：递归

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
```

### 方法二：遍历

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode curHead = new ListNode(-1);
        curHead.next = head;
        ListNode temp = curHead;
        while(temp != null && temp.next != null) {
            if(temp.next.val == val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return curHead.next;
    }
}
```

## [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210606001229.jpg" style="zoom:80%;" />

**示例 1：**

```tex
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

```tex
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

思路：DFS + 剪枝

- 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
- 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210606001505.png" alt="img" style="zoom:80%;" />

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 
        || j >= board[0].length || j < 0 
        || board[i][j] != word[k]) return false;

        if(k == word.length - 1) return true;
        board[i][j] = '\0';

        boolean res = dfs(board, word, i + 1, j, k + 1) 
        || dfs(board, word, i - 1, j, k + 1) 
        || dfs(board, word, i, j + 1, k + 1) 
        || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
}
```

# 2021/6/6

> 2021/6/6

## [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 **示例 1：**

```tex
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```tex
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

### 动态规划(空间复杂度O(lmn))

经典的背包问题可以使用二维数组动态规划求解，两个维度分别为物品和容量，这道题有两中容量（0、1）因此需要三维动态规划求解，三个维度分别为字符串、00 的容量和 11 的容量

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][][]dp = new int[len + 1][m + 1][n + 1];
        for(int i = 1; i <= len; i++) {
            int[] count = getZeroAndOne(strs[i - 1]);
            for(int j = 0; j <= m; j++) {
                for(int k = 0; k <= n; k++) {
                    if(count[0] <= j && count[1] <= k) {
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], 
                        dp[i - 1][j - count[0]][k - count[1]] + 1);
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k];
                    }
                }
            }
        }
        return dp[len][m][n];
    }

    public int[] getZeroAndOne(String s) {
        int[] count = new int[2];
        for(char ch : s.toCharArray()) {
            count[ch - '0']++;
        }
        return count;
    }
}
```

### 滚动数组(O(mn))

由于`dp[i][][]`的每个元素值的计算只和`dp[i - 1][][]` 的元素值有关，因此可以使用滚动数组的方式，去掉 \textit{dp}dp 的第一个维度，将空间复杂度优化到 O(mn)。

实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是`dp[i - 1][][]`中的元素值

> 因此可直接参考「01 背包的空间优化」方式：取消掉「物品维度」，然后调整容量的遍历顺序。

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        int len = strs.length;
        for(int i = 0; i < len; i++) {
            int[] count = getZeroAndOne(strs[i]);
            for(int j = m; j >= count[0]; j--) {
                for(int k = n; k >= count[1]; k--) {
                    dp[j][k] = Math.max(dp[j][k], dp[j - count[0]][k - count[1]] + 1);
                }
            }
        }
        return dp[m][n];
    }
    public int[] getZeroAndOne(String s) {
        int[] count = new int[2];
        for(char ch : s.toCharArray()) {
            count[ch - '0']++;
        }
        return count;
    }
}
```

## [在二叉树中找到两个节点的最近公共祖先](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&&tqId=38564&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

描述

给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 

示例1

输入：

```
[3,5,1,6,2,0,8,#,#,7,4],5,1
```

返回值：

```
3
```

### 利用前序遍历和后序遍历解决

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    List<Integer> preList = new ArrayList<>();
    List<Integer> postList = new ArrayList<>();
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        //最近公共祖先节点R
        //R在两个节点前序遍历的前面
        //R在两个节点后序遍历的后面
        preOrder(root);
        postOrder(root);
        //后序集合中两个节点后面的下标
        int postIndex = postList.indexOf(o1) > postList.indexOf(o2) ? 
            postList.indexOf(o1) : postList.indexOf(o2);
        //前序遍历中两个节点前面的下标
        int preIndex = preList.indexOf(o1) < preList.indexOf(o2) ? 
            preList.indexOf(o1) : preList.indexOf(o2);
        //在后序集合中从两个节点后面的节点开始遍历
        for(int i = postIndex; i < postList.size(); i++) {
            //如果当前节点在前序集合中的位置在两个节点之前，那么它一定就是最近公共祖先
            if(preList.indexOf(postList.get(i)) <= preIndex) return postList.get(i);
        }
        return -1;
    }
    
    public void preOrder(TreeNode node) {
        if(node == null) return;
        preList.add(node.val);
        preOrder(node.left);
        preOrder(node.right);
    }
    
    public void postOrder(TreeNode node) {
        if(node == null) return;
        postOrder(node.left);
        postOrder(node.right);
        postList.add(node.val);
    }
}
```

### 递归

![图片说明](https://gitee.com/zhang-songyao/blog-images/raw/master/20210606233456.gif)

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        if(root == null) return -1;
        if(o1 == root.val || o2 == root.val) return root.val;
        int left = lowestCommonAncestor(root.left, o1, o2);
        int right = lowestCommonAncestor(root.right, o1, o2);
        //都在右边
        if(left == -1) return right;
        //都在左边
        if(right == -1) return left;
        return root.val;
    }
}
```

## [两个链表生成相加链表](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&&tqId=38610&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

描述

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

例如：链表 1 为 9->3->7，链表 2 为 6->3，最后生成新的结果链表为 1->0->0->0。

示例1

输入：

```
[9,3,7],[6,3]
```

返回值：

```
{1,0,0,0}
```

### 反转反转再反转

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        //反转两个链表
        ListNode reHead1 = reserver(head1);
        ListNode reHead2 = reserver(head2);
        ListNode curHead = new ListNode(-1);
        ListNode temp = curHead;
        //负责监控是否进位
        int factor = 0;
        while(reHead1 != null || reHead2 != null) {
            int cur = (reHead1 == null ? 0 : reHead1.val)
                                     + (reHead2 == null ? 0 : reHead2.val)
                                     + factor;
            factor = cur / 10;
            cur = cur % 10;
            temp.next = new ListNode(cur);
            reHead1 = reHead1 == null ? null : reHead1.next;
            reHead2 = reHead2 == null ? null : reHead2.next;
            temp = temp.next;
        }
        if(factor == 1) {
            temp.next = new ListNode(1);
        }
        return reserver(curHead.next);
    }
    //头插法反转链表
    public ListNode reserver(ListNode head) {
        ListNode curHead = new ListNode(-1);
        ListNode temp = head;
        while(temp != null) {
            ListNode next = temp.next;
            temp.next = curHead.next;
            curHead.next = temp;
            temp = next;
        }
        return curHead.next;
    }
}
```

### 栈

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        Stack<Integer> s1 = new Stack();//用来存储两个链表的数据
        Stack<Integer> s2 = new Stack();

        while (head1 != null) {//将head1的元素放入栈1
            s1.push(head1.val);
            head1 = head1.next;
        }

        while (head2 != null) { //将head2的元素放入栈2
            s2.push(head2.val);
            head2 = head2.next;
        }
        ListNode res = null; // 用于返回的链表
        int cnt = 0; //如果两个值的加和>10，就会产生进位，这个用来存储进位
        while (!s1.empty() || !s2.empty()) { // 从两个栈中各取一位
            int x1 = s1.isEmpty() ? 0 : s1.pop();
            int x2 = s2.isEmpty() ? 0 : s2.pop();
            int sum = x1 + x2 + cnt;//当前这一位的总和
            cnt = sum / 10;//查看当前加和是否有进位
            ///进行当前节点的插入
            ListNode tempNode = new ListNode(sum % 10);
            tempNode.next = res;
            res = tempNode;
        }
        if(cnt > 0){
            ListNode tempNode = new ListNode(cnt);
            tempNode.next = res;
            res = tempNode;
        }
        return res;
    }
}
```



# 2021/6/7

> 2021/6/7

## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 

示例 1：

```tex
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

示例 2：

```tex
输入：nums = [1], target = 1
输出：1
```

### 递归yyds

```java
class Solution {
    int[] nums;
    int targetSum = 0;
    int target;
    public int findTargetSumWays(int[] nums, int target) {
        this.nums = nums;
        this.target = target;
        dfs(0, 0);
        return targetSum;
    }
    public void dfs(int index, int sum) {
        if(index == nums.length) {
            if(sum == target) {
                targetSum++;
            }
            return;
        }
        //+
        dfs(index + 1, sum + nums[index]);
        //-
        dfs(index + 1, sum - nums[index]);
    }
}
```

### 动态规划

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210607094625.png" alt="image-20210607094617110" style="zoom: 80%;" />

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //sum - neg - neg = target
        //neg = (sum - target) / 2
        int diff = sum - target;
        if(diff < 0 || diff % 2 != 0) return 0;
        int n = nums.length;
        int neg = diff / 2;
        //表示在数组nums 的前 i 个数中选取元素
        //使得这些元素之和等于 j 的方案数
        int[][] dp = new int[n + 1][neg + 1];
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for(int j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j] 
                + (j >= num ? dp[i - 1][j - num] : 0);
            }
        }
        return dp[n][neg];
    }
}
```

### 滚动数组（优化空间）

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //sum - neg - neg = target
        //neg = (sum - target) / 2
        int diff = sum - target;
        if(diff < 0 || diff % 2 != 0) return 0;
        int n = nums.length;
        int neg = diff / 2;
        //表示在数组nums 的前 i 个数中选取元素
        //使得这些元素之和等于 j 的方案数
        int[] dp = new int[neg + 1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for(int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```

## [473. 火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)

还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。

输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。

示例 1:

```tex
输入: [1,1,2,2,2]
输出: true

解释: 能拼成一个边长为2的正方形，每边两根火柴。
```

示例 2:

```tex
输入: [3,3,3,3,4]
输出: false

解释: 不能用所有火柴拼成一个正方形。
```

### dfs

>学习到两个新的方法：

通过Stream流将数组转换为List集合

- `Arrays.stream(matchsticks).boxed().collect(Collectors.toList())`

通过传入集合的反向比较器实现集合的倒序排序

- `Collections.sort(nums, Collections.reverseOrder())`

```java
class Solution {
    List<Integer> nums = new ArrayList<>();
    int[] sums;
    int possibleSquareSide;
    public boolean makesquare(int[] matchsticks) {
        if (matchsticks == null || matchsticks.length == 0) return false;
        this.sums = new int[4];
        int sum = 0;
        for(int matchstick : matchsticks) {
            sum += matchstick;
        }
        this.possibleSquareSide = sum / 4;
        if (possibleSquareSide * 4 != sum) return false;
        this.nums = Arrays.stream(matchsticks).boxed().collect(Collectors.toList());
        Collections.sort(nums, Collections.reverseOrder());
        return dfs(0);
    }
    private boolean dfs(int index) {
        if (index == nums.size()) {
            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];
        }
        int element = nums.get(index);
        for(int i = 0; i < 4; i++) {
            if (this.sums[i] + element <= possibleSquareSide) {
                this.sums[i] += element;
                if (this.dfs(index + 1)) return true;
                this.sums[i] -= element;
            }
        }
        return false;
    }
}
```

# 2021/6/11

## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：

```tex
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

示例 2：

```tex
输入：n = 13
输出：2
解释：13 = 4 + 9
```

### 动态规划

```java
class Solution {
    public int numSquares(int n) {
        int[]dp = new int[n + 1];
        for(int i = 1; i <= n; i++) {
            int minn = Integer.MAX_VALUE;
            for(int j = 1; j * j <= i; j++) {
                minn = Math.min(minn, dp[i - j * j]);
            }
            dp[i] = minn + 1;
        }
        return dp[n];
    }
}
```

# 2021/6/19

>2021/6/19

## [串联字符串的最大长度](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。

请返回所有可行解 s 中最长长度。

示例 1：

```tex
输入：arr = ["un","iq","ue"]
输出：4
解释：所有可能的串联组合是 "","un","iq","ue","uniq" 和 "ique"，最大长度为 4。
```

示例 2：

```tex
输入：arr = ["cha","r","act","ers"]
输出：6
解释：可能的解答有 "chaers" 和 "acters"。
```


示例 3：

```tex
输入：arr = ["abcdefghijklmnopqrstuvwxyz"]
输出：26
```

### 递归

> 拿或者不拿的问题

```java
class Solution {
    List<String> arr;
    int maxLen = Integer.MIN_VALUE;
    public int maxLength(List<String> arr) {
        this.arr = arr;
        dfs(new StringBuilder(), 0, new int[26]);
        return maxLen;
    }
    private void dfs(StringBuilder builder, int index, int[] count) {
        maxLen = Math.max(maxLen, builder.length());
        if (index == arr.size()) return;
        //拿
        char[] chars = arr.get(index).toCharArray();
        boolean ok = true;
        int[] curCount = Arrays.copyOf(count, count.length);
        for (char c : chars) {
            if (curCount[c - 'a'] == 1) {
                ok = false;
                break;
            } else {
                curCount[c - 'a']++;
            }
        }
        if (ok) {
            dfs(new StringBuilder(builder).append(arr.get(index)),index + 1, curCount);
        }
        //不拿
        dfs(builder, index + 1, count);
    }
}
```

## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

```tex
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

示例 2：

```tex
输入：n = 1
输出：["()"]
```

### 递归回溯

>维护一个balance
>
>每增加一个( balance + 1
>
>每增加一个) balance - 1
>
>balance的值始终不能为负数,balance的值不能超过n（这里相当于剪枝了吧，不剪枝，时间复杂度太高了）
>
>最终当balance = 0 时是满足要求的

```java
class Solution {
    List<String> list = new ArrayList<>();
    int n;
    public List<String> generateParenthesis(int n) {
        //维护一个balance
        //每增加一个( balance + 1
        //每增加一个) balance - 1
        // balance的值始终不能为负数,balance的值不能超过n
        this.n = n;
        dfs(0, new StringBuilder());
        return list;
    }
    private void dfs(int balance, StringBuilder builder) {
        if (builder.length() == n * 2) {
            if (balance == 0)
                list.add(builder.toString());
            return;
        }
        //拿(
        if (balance < n) {
            builder.append("(");
            dfs(balance + 1, builder);
            builder.deleteCharAt(builder.length() - 1);
        }
        //拿)
        if (balance > 0) {
            builder.append(")");
            dfs(balance - 1, builder);
            builder.deleteCharAt(builder.length() - 1);
        }
    }
}	
```

### 再剪枝

> 这次维护两个变量吧，一个open表示(的数量，一个close表示)的数量
>
> 于是有两种情况
>
> open < n 可以拿 (
>
> close < open 可以拿 )

```java
class Solution {
    List<String> list = new ArrayList<>();
    int n;
    public List<String> generateParenthesis(int n) {
        this.n = n;
        backtrack(new StringBuilder(), 0, 0);
        return list;
    }
    private void backtrack(StringBuilder builder, int open, int close) {
        if (builder.length() == n * 2) {
            list.add(builder.toString());
            return;
        }
        //拿(
        if (open < n) {
            builder.append("(");
            backtrack(builder, open + 1, close);
            builder.deleteCharAt(builder.length() - 1);
        }
        //拿)
        if (open > close) {
            builder.append(")");
            backtrack(builder, open, close + 1);
            builder.deleteCharAt(builder.length() - 1);
        }
    }
}
```

## [面试题 08.04. 幂集](https://leetcode-cn.com/problems/power-set-lcci/)

幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。

示例:

```tex
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 这不递归？

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    int[] nums;
    public List<List<Integer>> subsets(int[] nums) {
        this.nums = nums;
        dfs(0, new ArrayList<>());
        return ans;
    }
    private void dfs(int index, ArrayList<Integer> curList) {
        if (index == nums.length) {
            ans.add(new ArrayList<>(curList));
            return;
        }
        //不拿
        dfs(index + 1, curList);
        //拿
        curList.add(nums[index]);
        dfs(index + 1, curList);
        curList.remove(curList.size() - 1);
    }
}
```

## [八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)

设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。

注意：本题相对原题做了扩展

示例:

 输入：4
 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
 解释: 4 皇后问题存在如下两个不同的解法。

```tex
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

### 递归回溯

> leetcode题解：https://leetcode-cn.com/problems/eight-queens-lcci/solution/ba-huang-hou-by-leetcode-solution/
>
> 我的解法：https://blog.csdn.net/qq_45796208/article/details/110272260

```java
class Solution {
    int max;
    List<List<String>> ans = new ArrayList<>();
    int[] array;
    public List<List<String>> solveNQueens(int n) {
        max = n;
        array = new int[max];
        check(0);
        return ans;
    }
    public void check(int n) {
        if (n == max) {
            List<String> sub = generateList(array);
            ans.add(new ArrayList<>(sub));
            return;
        }
        for (int i = 0; i < max; i++) {
            array[n] = i;
            if (judge(n)) {
                check(n + 1);
            }
        }
    }
    private boolean judge(int n) {
        for (int i = 0; i < n; i++) {
            //array[i] == array[n]  不在同一列
            //Math.abs(array[n] - array[i]) == Math.abs(n - i)  不在同一斜线
            if (array[i] == array[n] || Math.abs(array[n] - array[i]) == Math.abs(n - i)) {
                return false;
            }
        }
        return true;
    }
    public List<String> generateList(int[] nums) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < max; i++) {
            builder.append(".");
        }
        List<String> sub = new ArrayList<>();
        for (int num : nums) {
            StringBuilder builder1 = new StringBuilder(builder);
            builder1.replace(num, num + 1, "Q");
            sub.add(builder1.toString());
        }
        return sub;
    }
}
```

# 2021/6/21

> 2021/6/21

## [ 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

- 例如，下面的二进制手表读取 `"3:25"` 。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20210621095413.jpeg" alt="img" style="zoom:80%;" />



给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

- 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。
  分钟必须由两位数组成，可能会以零开头：
- 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。

示例 1：

```tex
输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
```

示例 2：

```tex
输入：turnedOn = 9
输出：[]
```

### 方法一

> 遍历所有的时间，取满足情况的时间

```java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<String>();
        for (int h = 0; h < 12; ++h) {
            for (int m = 0; m < 60; ++m) {
                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    ans.add(h + ":" + (m < 10 ? "0" : "") + m);
                }
            }
        }
        return ans;
    }
}
```

### 方法二

>枚举所有 2^{10}=1024种灯的开闭组合，即用一个二进制数表示灯的开闭，其高 4 位为小时，低 6 位为分钟。若小时和分钟的值均在合法范围内，且二进制中 1 的个数为 turnedOn，则将其加入到答案中

```java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<String>();
        for (int i = 0; i < 1024; i++) {
            int h = i >> 6;
            int m = i & 63;
            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {
                ans.add(h + ":" + (m < 10 ? "0" : "") + m);
            }
        }
        return ans;
    }
}
```

# 2021/7/6

> 2021/7/6

## [点菜展示表](https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/)

给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。

请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。

示例 1：

```tex
输入：orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
输出：[["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] 
解释：
点菜展示表如下所示：
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
对于餐桌 3：David 点了 "Ceviche" 和 "Fried Chicken"，而 Rous 点了 "Ceviche"
而餐桌 5：Carla 点了 "Water" 和 "Ceviche"
餐桌 10：Corina 点了 "Beef Burrito" 
```


示例 2：

```tex
输入：orders = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]
输出：[["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]] 
解释：
对于餐桌 1：Adam 和 Brianna 都点了 "Canadian Waffles"
而餐桌 12：James, Ratesh 和 Amadeus 都点了 "Fried Chicken"
```

### 哈希

```java
class Solution {
    public List<List<String>> displayTable(List<List<String>> orders) {
        List<String> tableNum = new ArrayList<>();
        List<String> foods = new ArrayList<>();
        List<List<String>> ans = new ArrayList<>();
        Map<String, Map<String, Integer>> map = new HashMap<>();
        for (List<String> order : orders) {
            String tNum = order.get(1);
            String food = order.get(2);
            if (!tableNum.contains(tNum))
                tableNum.add(tNum);
            if (!foods.contains(food))
                foods.add(food);
            Map curMap = map.getOrDefault(tNum, new HashMap<>());
            int num = (int) curMap.getOrDefault(food, 0);
            num++;
            curMap.put(food, num);
            map.put(tNum, curMap);
        }
        foods.sort(String :: compareTo);
        List<String> title = new ArrayList<>();
        title.add("Table");
        for (int i = 0; i < foods.size(); i++) {
            title.add(foods.get(i));
        }
        ans.add(title);
        tableNum.sort((o1, o2) -> Integer.parseInt(o1) - Integer.parseInt(o2));
        for (String tNum : tableNum) {
            List<String> list = new ArrayList<>();
            list.add(tNum);
            Map<String, Integer> curMap = map.get(tNum);
            for (int i = 1; i < title.size(); i++) {
                String food = title.get(i);
                int num = curMap.getOrDefault(food, 0);
                list.add(num + "");
            }
            ans.add(list);
        }
        return ans;
    }
}
```

## [错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1：

```tex
输入：nums = [1,2,2,4]
输出：[2,3]
```

示例 2：

```tex
输入：nums = [1,1]
输出：[1,2]
```

### 方法一

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] errorNums = new int[2];
        int n = nums.length;
        Arrays.sort(nums);
        int prev = 0;
        for (int i = 0; i < n; i++) {
            int cur = nums[i];
            if (cur == prev) {
                errorNums[0] = cur;
            } else if (cur - prev > 1) {
                errorNums[1] = prev + 1;
            }
            prev = cur;
        }
        if (errorNums[1] == 0) {
            errorNums[1] = n;
        }
        return errorNums;
    }
}
```

# 2021/7/7

> 2021/7/7

## [1711. 大餐计数](https://leetcode-cn.com/problems/count-good-meals/)

大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。

你可以搭配 任意 两道餐品做一顿大餐。

给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。

注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。

 示例 1：

```tex
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
```


示例 2：

```tex
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
```

### 循环（TLE）

```java
class Solution {
    public int countPairs(int[] deliciousness) {
        int res = 0;
        for (int i = 0; i < deliciousness.length - 1; i++) {
            for (int j = i + 1; j < deliciousness.length; j++) {
                int num = deliciousness[i] + deliciousness[j];
                if (Integer.bitCount(num) == 1)
                    res++;
            }
        }
        return res;
    }
}
```

### 哈希

```java
class Solution {
    public int countPairs(int[] deliciousness) {
        final int MOD = 1000000007;
        int maxVal = Arrays.stream(deliciousness).max().getAsInt();
        int maxNum = maxVal * 2;
        int pairs = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < deliciousness.length; i++) {
            int val = deliciousness[i];
            for (int sum = 1; sum <= maxNum; sum <<= 1) {
                int count = map.getOrDefault(sum - val, 0);
                pairs = (pairs + count) % MOD;
            }
            map.put(val, map.getOrDefault(val, 0) + 1);
        }
        return pairs;
    }
}
```

# 2021/7/8

> 2021/7/8

## [和相同的二元子数组](https://leetcode-cn.com/problems/binary-subarrays-with-sum/)

给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。

子数组 是数组的一段连续部分。

示例 1：

 ```tex
输入：nums = [1,0,1,0,1], goal = 2
输出：4
解释：有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]
 ```

示例 2：

```tex
输入：nums = [0,0,0,0,0], goal = 0
输出：15
```

### 哈希表

```java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int sum = 0;
        HashMap<Integer, Integer> cnt = new HashMap<>();
        int ret = 0;
        for (int num : nums) {
            cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
            sum += num;
            ret += cnt.getOrDefault(sum - goal, 0);
        }
        return ret;
    }
}
```

# 2021/7/9

>2021/7/9

## [面试题 17.10. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。

示例 1：

```tex
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```


示例 2：

```tex
输入：[3,2]
输出：-1
```

### 方法一

> 流氓做法

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int length = nums.length / 2;
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
            if (map.get(num) > length) {
                return num;
            }
        }
        return -1;
    }
}
```

# 2021/7/10

> 2021/7/10

## [基于时间的键值存储](https://leetcode-cn.com/problems/time-based-key-value-store/)

创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：

1. set(string key, string value, int timestamp)

存储键 key、值 value，以及给定的时间戳 timestamp。
2. get(string key, int timestamp)

返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev <= timestamp。
如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。
如果没有值，则返回空字符串（""）。

示例 1：

```tex
输入：inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]
输出：[null,null,"bar","bar",null,"bar2","bar2"]
解释：  
TimeMap kv;   
kv.set("foo", "bar", 1); // 存储键 "foo" 和值 "bar" 以及时间戳 timestamp = 1   
kv.get("foo", 1);  // 输出 "bar"   
kv.get("foo", 3); // 输出 "bar" 因为在时间戳 3 和时间戳 2 处没有对应 "foo" 的值，所以唯一的值位于时间戳 1 处（即 "bar"）   
kv.set("foo", "bar2", 4);   
kv.get("foo", 4); // 输出 "bar2"   
kv.get("foo", 5); // 输出 "bar2"   
```

示例 2：

```tex
输入：inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]
输出：[null,null,null,"","high","high","low","low"]
```

### 方法一

> 第43用例超时，整体思路就是封装一个对象，使用哈希 + 二分查找即可

```java
class TimeMap {
    private Map<String, List<Val>> map;
    /** Initialize your data structure here. */
    public TimeMap() {
        map = new HashMap<>();
    }
    public void set(String key, String value, int timestamp) {
        List<Val> list = map.get(key);
        if (list ==  null) {
            list = new ArrayList<>();
        }
        list.add(new Val(value, timestamp));
        Collections.sort(list, (Comparator.comparingInt(o -> o.timestamp)));
        map.put(key, list);
    }
    public String get(String key, int timestamp) {
        List<Val> list = map.get(key);
        if (list == null) {
            return "";
        } else {
            Val res = binarySearch(list, timestamp);
            return res.timestamp <= timestamp ? res.value : "";
        }
    }
    private Val binarySearch(List<Val> list, int timestamp) {
        int l = 0;
        int r = list.size() - 1;
        int mid;
        while(l < r) {
            mid = l + r + 1 >> 1;
            if (list.get(mid).timestamp <= timestamp) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return list.get(l);
    }
}
class Val {
    public String value;
    public int timestamp;
    public Val(String value, int timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
```

### 方法二

> 为了减少排序的次数，我将list集合换成了优先队列，结果最后一个测试用例超时了，我服了

```java
class TimeMap {
    private Map<String, PriorityQueue<Val>> map;
    /** Initialize your data structure here. */
    public TimeMap() {
        map = new HashMap<>();
    }
    public void set(String key, String value, int timestamp) {
        PriorityQueue<Val> queue = map.get(key);
        if (queue ==  null) {
            queue = new PriorityQueue<>(Comparator.comparingInt(o -> o.timestamp));
        }
        queue.add(new Val(value, timestamp));
        map.put(key, queue);
    }
    public String get(String key, int timestamp) {
        PriorityQueue<Val> queue = map.get(key);
        if (queue == null) {
            return "";
        } else {
            Val res = binarySearch(queue, timestamp);
            return res.timestamp <= timestamp ? res.value : "";
        }
    }
    private Val binarySearch(PriorityQueue<Val> queue, int timestamp) {
        int l = 0;
        int r = queue.size() - 1;
        Val[] arr = queue.toArray(new Val[]{});
        int mid;
        while(l < r) {
            mid = l + r + 1 >> 1;
            if (arr[mid].timestamp <= timestamp) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return arr[l];
    }
}
class Val {
    public String value;
    public int timestamp;
    public Val(String value, int timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
```

### 方法三

>还是比较疑惑，貌似不需要排序，官方做法，使用了内比较器

```java
class TimeMap {
    class Pair implements Comparable<Pair> {
        int timestamp;
        String value;

        public Pair(int timestamp, String value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public int hashCode() {
            return timestamp + value.hashCode();
        }

        public boolean equals(Object obj) {
            if (obj instanceof Pair) {
                Pair pair2 = (Pair) obj;
                return this.timestamp == pair2.timestamp && this.value.equals(pair2.value);
            }
            return false;
        }

        public int compareTo(Pair pair2) {
            if (this.timestamp != pair2.timestamp) {
                return this.timestamp - pair2.timestamp;
            } else {
                return this.value.compareTo(pair2.value);
            }
        }
    }

    Map<String, List<Pair>> map;

    public TimeMap() {
        map = new HashMap<String, List<Pair>>();
    }
    
    public void set(String key, String value, int timestamp) {
        List<Pair> pairs = map.getOrDefault(key, new ArrayList<Pair>());
        pairs.add(new Pair(timestamp, value));
        map.put(key, pairs);
    }
    
    public String get(String key, int timestamp) {
        List<Pair> pairs = map.getOrDefault(key, new ArrayList<Pair>());
        // 使用一个大于所有 value 的字符串，以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置
        Pair pair = new Pair(timestamp, String.valueOf((char) 127));
        int i = binarySearch(pairs, pair);
        if (i > 0) {
            return pairs.get(i - 1).value;
        }
        return "";
    }

    private int binarySearch(List<Pair> pairs, Pair target) {
        int low = 0, high = pairs.size() - 1;
        if (high < 0 || pairs.get(high).compareTo(target) <= 0) {
            return high + 1;
        }
        while (low < high) {
            int mid = (high - low) / 2 + low;
            Pair pair = pairs.get(mid);
            if (pair.compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}
```

## [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例 1:

```tex
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```


示例 2:

```tex
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```


示例 3:

```tex
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

### 方法一

```java
class Solution {
    public String frequencySort(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        ArrayList<Letter> letters = new ArrayList<>();
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            letters.add(new Letter(entry.getKey(), entry.getValue()));
        }
        letters.sort((o1, o2) -> o2.count - o1.count);
        StringBuilder builder = new StringBuilder();
        for (Letter letter : letters) {
            for (int i = 0; i < letter.count; i++) {
                builder.append(letter.val);
            }
        }
        return builder.toString();
    }
}
class Letter {
    char val;
    int count;
    public Letter(char val, int count) {
        this.val = val;
        this.count = count;
    }
}
```

# 2021/7/12

> 2021/7/12

## [274. H 指数](https://leetcode-cn.com/problems/h-index/)

给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。

例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。

示例：

```java
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

### 方法一

> 二分查找O(logN)	

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int len = citations.length;
        if (len == 1) return citations[0] >= 1 ? 1 : 0;
        int h = 0;
        for (int i = 0; i <= len ; i++) {
            int index = binarySearch(0, len - 1, citations, i);
            if (index != -1 && i <= (len - index)) {
                h = i;
            } else {
                break;
            }
        }
        return h;
    }
    private int binarySearch(int l, int r, int[] citations, int tar) {
        while (l < r) {
            int mid = l + r >> 1;
            if (citations[mid] < tar) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return citations[r] >= tar ? r : -1;
    }
}
```

### 方法二

>O(N)

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int h = 0;
        System.out.println(Arrays.toString(citations));
        int i = citations.length - 1;
        while (i >= 0 && citations[i] > h) {
            h++;
            i--;	
        }
        return h;
    }
}	
```

## [275. H 指数 II](https://leetcode-cn.com/problems/h-index-ii/)

给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。

h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）"

示例:

```tex
输入: citations = [0,1,3,5,6]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。
```

### 方法一

> 就是上面的方法二，去掉了排序

```java
class Solution {
    public int hIndex(int[] citations) {
        int len = citations.length;
        if (len == 1) return citations[0] >= 1 ? 1 : 0;
        int h = 0;
        for (int i = 0; i <= len ; i++) {
            int index = binarySearch(0, len - 1, citations, i);
            if (index != -1 && i <= (len - index)) {
                h = i;
            } else {
                break;
            }
        }
        return h;
    }
    private int binarySearch(int l, int r, int[] citations, int tar) {
        while (l < r) {
            int mid = l + r >> 1;
            if (citations[mid] < tar) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return citations[r] >= tar ? r : -1;
    }
}
```

### 方法二

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (citations[mid] >= n - mid) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return n - left;
    }
}
```

# 2021/7/27

> 2021/7/27

## [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

数值（按顺序）可以分成以下几个部分：

1. 若干空格
2. 一个 小数 或者 整数
3. （可选）一个 'e' 或 'E' ，后面跟着一个 整数
4. 若干空格

小数（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（'+' 或 '-'）
2. 下述格式之一：
   - 至少一位数字，后面跟着一个点 '.'
   - 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
   - 一个点 '.' ，后面跟着至少一位数字

整数（按顺序）可以分成以下几个部分：

- （可选）一个符号字符（'+' 或 '-'）
- 至少一位数字

部分数值列举如下：

- ["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]

部分非数值列举如下：

- ["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]

示例 1：

```
输入：s = "0"
输出：true
```

示例 2：

```
输入：s = "e"
输出：false
```

### 方法一

```java
/**
 * @author :songyaozhang
 * @date :Created 2021/7/27 20:05
 * @description :https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/
 */
public class 剑指_20_表示数值的字符串 {
    @Test
    public void test() {
        Solution solution = new Solution();
        System.out.println(solution.isNumber("3e-10"));
    }

    class Solution {
        public boolean isNumber(String s) {
            s = s.trim();
            if (s.length() == 0) return false;
            if (isSignInt(s)) return true;
            if (isFloat(s)) return true;
            //判断是否为数值
            int index = Math.max(s.indexOf("e"), s.indexOf("E"));
            if (index == -1) return false;
            return (isFloat(s.substring(0, index)) || isSignInt(s.substring(0, index))) && isSignInt(s.substring(index + 1));
        }

        /**
         * 有符号整数
         * @param s
         * @return
         */
        private boolean isSignInt(String s) {
            if (s.length() == 0) return false;
            char[] chars = s.toCharArray();
            int i = 0;
            if (chars[i] == '+' || chars[i] == '-') i++;
            if (i >= s.length()) return false;
            for (;  i < chars.length; i++) {
                if (chars[i] < '0' || chars[i] > '9') return false;
            }
            return true;
        }

        /**
         * 无符号整数，主要用于小数点后数字判断
         * @param s
         * @return
         */
        private boolean isInt(String s) {
            if (s.length() == 0) return false;
            char[] chars = s.toCharArray();
            int i = 0;
            if (i >= s.length()) return false;
            for (;  i < chars.length; i++) {
                if (chars[i] < '0' || chars[i] > '9') return false;
            }
            return true;
        }

        /**
         * 小数判断
         * @param s
         * @return
         */
        private boolean isFloat(String s) {
            if (s.length() == 0) return false;
            int index = s.indexOf(".");
            if (index == -1) return false;
            int i = 0;
            if (s.charAt(0) == '+' || s.charAt(0) == '-') i++;
            if (index == i) {
                return isInt(s.substring(index + 1));
            } else if (index == s.length() - 1){
                return isInt(s.substring(i, index));
            } else {
                return isInt(s.substring(i, index)) && isInt(s.substring(index + 1));
            }
        }
    }

}

```

## [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

```tex
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

### 方法一

```java
class Solution {
    public int[] printNumbers(int n) {
        if (n <= 0) return new int[]{};
        StringBuilder builder = new StringBuilder();
        while (n > 0) {
            builder.append("9");
            n--;
        }
        int len = Integer.parseInt(builder.toString());
        int[] res = new int[len];
        for (int i = 0; i < res.length; i++) {
            res[i] = i + 1;
        }
        return res;
    }
}
```

### 方法二

```java
class Solution {
    public int[] printNumbers(int n) {
        if (n <= 0) return new int[]{};
        int len = (int) Math.pow(10, n) - 1;
        int[] res = new int[len];
        int m = len / 10000  + 1;
        CountDownLatch countDownLatch = new CountDownLatch(m);
        for (int i = 0; i < m; i++) {
            int finalI = i;
            new Thread(() -> {
                int start = finalI * 10000;
                int end = (finalI + 1) * 10000;
                end = Math.min(end, len);
                for (int j = start; j < end; j++) {
                    res[j] = j + 1;
                }
                countDownLatch.countDown();
            }).start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return res;
    }
}
```

# 2021/12/15

## [851. 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich/)

有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。

给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。

现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。

**示例1**

```
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。
```

**示例2**

```
输入：richer = [], quiet = [0]
输出：[0]
```

### 自己想法

以示例1为例展开描述

> 使用有向图保存人们之间的财富的关系，例如[1, 0]，preson1比person0有钱，则使1指向0

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215165955.png" alt="image-20211215165357946" style="zoom: 80%;" />

> 使用拓扑排序对每个节点处理，计算出比每个节点富有并且最安静的人(后面称为最优解)

第一轮都是叶子节点，所以他们的最优解就是自己的quiet值，并且把自己的quiet值传递给以自己为入度的节点（当然传递的时候不一定是最优解，使用`Math.min()`取最小值，并向下继续传递）

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215170156.png" alt="image-20211215170154766" style="zoom:80%;" />

第二轮，继续

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215170247.png" alt="image-20211215170244403" style="zoom:80%;" />

第三轮

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215170353.png" alt="image-20211215170350083" style="zoom:80%;" />

最终，传递结束

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215170424.png" alt="image-20211215170420153" style="zoom:80%;" />

> 由于题目中明确：quiet值唯一，所以此时根据每个节点的quiet值获得对应的人即可

```java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int len = quiet.length;
        // 存储有向图
        List<List<Integer>> edges = new ArrayList<>();
        // 存储每个节点的入度
        int[] inDeg = new int[len];
        // 存储quiet和person的对应关系
        Map<Integer, Integer> map = new HashMap<>();
        int[] ans = new int[len];
        for (int i = 0; i < len; i++) {
            edges.add(new ArrayList<>());
        }
        for (int i = 0; i < len; i++) {
            map.put(quiet[i], i);
        }
        for (int[] nums : richer) {
            edges.get(nums[0]).add(nums[1]);
            inDeg[nums[1]]++;
        }
        for (int i = 0; i < ans.length; i++) {
            ans[i] = quiet[i];
        }
        // 临时存储入度为0的节点
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            if (inDeg[i] == 0) {
                queue.offer(i);
            }
        }
        while (!queue.isEmpty()) {
            Integer cur = queue.poll();
            // 获取当前节点的最优解
            int curQuiet = Math.min(ans[cur], quiet[cur]);
            ans[cur] = curQuiet;
            // 向下传递
            for (Integer in : edges.get(cur)) {
                ans[in] = Math.min(ans[in], curQuiet);
                if (--inDeg[in] == 0) {
                    queue.offer(in);
                }
            }
        }
        // 根据quiet获取person
        for (int i = 0; i < ans.length; i++) {
            ans[i] = map.get(ans[i]);
        }
        return ans;
    }
}
```

### 官方题解

> 差不多，使用的是List<Integer>数组，课程表用的可不是数组

```java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int n = quiet.length;
        List<Integer>[] g = new List[n];
        for (int i = 0; i < n; ++i) {
            g[i] = new ArrayList<Integer>();
        }
        int[] inDeg = new int[n];
        for (int[] r : richer) {
            g[r[0]].add(r[1]);
            ++inDeg[r[1]];
        }

        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            ans[i] = i;
        }
        Queue<Integer> q = new ArrayDeque<Integer>();
        for (int i = 0; i < n; ++i) {
            if (inDeg[i] == 0) {
                q.offer(i);
            }
        }
        while (!q.isEmpty()) {
            int x = q.poll();
            for (int y : g[x]) {
                if (quiet[ans[x]] < quiet[ans[y]]) {
                    ans[y] = ans[x]; // 更新 x 的邻居的答案
                }
                if (--inDeg[y] == 0) {
                    q.offer(y);
                }
            }
        }
        return ans;
    }
}
```

# 2021/12/16

## [1610. 可见点的最大数目](https://leetcode-cn.com/problems/maximum-number-of-visible-points/)

给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。

最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211216161724.gif" style="zoom:80%;" />

对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。

同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。

返回你能看到的点的最大数目。

**示例1**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211216161847.png" alt="img" style="zoom:80%;" />

```
输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
输出：3
解释：阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。
```

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211216161906.png" alt="img" style="zoom:80%;" />

```
输入：points = [[1,0],[2,1]], angle = 13, location = [1,1]
输出：1
解释：如图所示，你只能看到两点之一。
```

提示：

- 1 <= points.length <= 105
- points[i].length == 2
- location.length == 2
- 0 <= angle < 360
- 0 <= posx, posy, xi, yi <= 100

## 解题

> 题目要求我们找出一个角度为angle的、可无限延伸的覆盖面。使得该覆盖面可以覆盖points中的点最多

令points[i] = (x1,y1) ，与极点的关系：dx = x1 - x， dy = y1 - y

我们将二维平面直角坐标系转换成以location点为极点的极坐标系，求极角的方式有两种：

- $$
  atan(\frac{dx}{dy})
  $$

值域范围为 [-90°,90°]，需要对 dxdx 与 dydy 进行象限讨论，从而将值域范围转化为我们希望的 [0°,360°]，同时需要注意 dx = 0dx=0 的边界情况

- $$
  atan2(dy, dx)
  $$

值域范围为 [-180°,180°]，与我们期望的 [0°,360°] 相差一个固定的值，可进行统一转换，也可以直接使用



得到夹角数组 listlist 后，对其进行排序，问题初步转换为：在夹角数组中找到连续一段 [i, j][i,j]，使得 list[i]list[i] 和 list[j]list[j] 的角度差不超过 angleangle。

但直接在原数组 listlist 操作，会漏掉夹角横跨一四象限的情况

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211216163137.png" alt="image-20211216163134165" style="zoom:80%;" />

因此，另外一个细节是，在求连续段长度时，先对夹角数组进行拷贝拼接，并对拼接部分增加偏移量（确保数组仍具有单调性）。

具体的，设夹角数组长度为 n，此时令 list[n + i] = list[i] + 2 * PI，从而将问题彻底转换为求连续段问题。

> 题目规定了与 location 重合的点在任意角度都能看到，因此我们需要对这些点进行特殊处理

```java
class Solution {
    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {
        int x = location.get(0), y = location.get(1);
        double pi = Math.PI, t = angle * pi / 180;
        int count = 0;
        ArrayList<Double> list = new ArrayList<>();
        for (List<Integer> point : points) {
            Integer x1 = point.get(0);
            Integer y1 = point.get(1);
            if (x == x1 && y == y1) {
                count++;
                continue;
            }
            list.add(Math.atan2(x1 - x, y1 - y) + pi);
        }
        Collections.sort(list);
        int n = list.size();
        int max = 0;
        for (int i = 0; i < n; i++) {
            list.add(list.get(i) + 2 * pi);
        }
        for (int i = 0, j = 0; j < n * 2; j++) {
            while (i < j && list.get(j) - list.get(i) > t) i++;
            max = Math.max(max, j - i + 1);
        }
        return max + count;
    }
}
```

# 2021/12/17

## [1518换酒问题](https://leetcode-cn.com/problems/water-bottles/)

小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。

如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。

请你计算 **最多** 能喝到多少瓶酒。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211217115536.png" alt="img" style="zoom:80%;" />

**示例1**

```
输入：numBottles = 9, numExchange = 3
输出：13
解释：你可以用 3 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 9 + 3 + 1 = 13 瓶酒。
```

### 模拟

```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        int sum = 0;
        int emptyNumBottles = 0;
        while (numBottles > 0) {
            sum += numBottles;
            int curEmptyBottles = numBottles + emptyNumBottles;
            numBottles = curEmptyBottles / numExchange;
            emptyNumBottles = curEmptyBottles % numExchange;
        }
        return sum;
    }
}
```

### 数学

第一步，首先我们一定可以喝到 bb 瓶酒，剩下 bb 个空瓶。

第二步，接下来我们来考虑空瓶换酒，换完再喝，喝完再换的过程——每次换到一瓶酒就意味着多一个空瓶，所以每次损失的瓶子的数量为 e - 1，我们要知道这个过程能得到多少瓶酒，即希望知道第一个打破下面这个条件的 n 是多少：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211217115733.png" alt="image-20211217115730658" style="zoom:80%;" />

即我们要找到最小的 n 使得：

<img src="C:/Users/dell/AppData/Roaming/Typora/typora-user-images/image-20211217115744453.png" alt="image-20211217115744453" style="zoom:80%;" />

我们得到：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211217115817.png" alt="image-20211217115814240" style="zoom:80%;" />

当然我们要特别注意这里的前提条件是 b≥e，试想如果 b < e，没有足够的瓶子再换酒了，就不能进行第二步了

```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        return numBottles >= numExchange ? (numBottles - numExchange) / (numExchange - 1) + 1 + numBottles : numBottles;
    }
}
```

# 2021/12/19

## [997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足条件 1 和条件 2 。

给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。

**示例1**

```
输入：n = 2, trust = [[1,2]]
输出：2
```

**示例2**

```
输入：n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```

> 统计入度出度即可，简单题不解释了

```java
class Solution {
    public int findJudge(int n, int[][] trusts) {
        int[] inDeg = new int[n + 1];
        int[] outDeg = new int[n + 1];
        for (int[] trust : trusts) {
            inDeg[trust[1]]++;
            outDeg[trust[0]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (inDeg[i] == n - 1 && outDeg[i] == 0) return i;
        }
        return -1;
    }
}
```

# 2021/12/21

## [1705. 吃苹果的最大数目](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

**实例1**

```
输入：apples = [1,2,3,5,2], days = [3,2,1,4,2]
输出：7
解释：你可以吃掉 7 个苹果：
- 第一天，你吃掉第一天长出来的苹果。
- 第二天，你吃掉一个第二天长出来的苹果。
- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。
- 第四天到第七天，你吃的都是第四天长出来的苹果。
```

**实例2**

```
输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
输出：5
解释：你可以吃掉 5 个苹果：
- 第一天到第三天，你吃的都是第一天长出来的苹果。
- 第四天和第五天不吃苹果。
- 第六天和第七天，你吃的都是第六天长出来的苹果。
```

### 自己的想法

> 使用一个优先队列保存第i天的苹果信息(苹果数量和腐烂时间)[apples[i]，days[i] + i]，优先队列根据腐烂时间排序，最先腐烂的最先吃掉
>
> 当queue为空时分为两种情况
>
> - 当前天数已经超过了`apples.length`，证明已经没有苹果加入了，没得吃了，退出，返回结果即可
> - 当天天数不足`apples.length`，证明后面还会有苹果加进来，今天没得吃了，等加入后再吃

```java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[1]));
        int count = 0;
        int day = 0;
        while (true) {
            if (day < apples.length && apples[day] != 0) {
                queue.offer(new int[]{apples[day], days[day] + day});
            }
            while (!queue.isEmpty() && queue.peek()[1] <= day) {
                queue.poll();
            }
            if (queue.isEmpty() && day > apples.length) break;
            if(!queue.isEmpty()) {
                int[] cur = queue.peek();
                if (--cur[0] == 0) {
                    queue.poll();
                }
                count++;
            }
            day++;
        }
        return count;
    }
}
```

### 官方题解

> 将上述的两种情况分为了两个阶段，并且对第二个阶段进行了优化，因为苹果不会添加了，所以可以一次性计算出能吃到的最多苹果，下面看题解吧

在第一阶段，由于每天树上都可能长出苹果，因此需要对每一天分别计算是否能吃到苹果，并更新优先队列。具体做法如下：

- 将优先队列中的所有腐烂日期小于等于当前日期的元素取出，这些元素表示已经腐烂的苹果，无法食用；
- 根据 \textit{days}days 和 \textit{apples}apples 的当前元素计算当天长出的苹果的腐烂日期和数量，如果数量大于 00，则将腐烂日期和数量加入优先队列；
- 如果优先队列不为空，则当天可以吃 11 个苹果，将优先队列的队首元素的数量减 11，如果队首元素的数量变成 00 则将队首元素取出。

在第二阶段，由于树上不会再长出苹果，因此只需要考虑能吃到的苹果数量。由于优先队列中的每个元素的数量可能很大，因此需要根据当前日期和优先队列的队首元素的腐烂日期和数量计算能吃到的苹果数量。

```java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        int ans = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
        int n = apples.length;
        int i = 0;
        while (i < n) {
            while (!pq.isEmpty() && pq.peek()[0] <= i) {
                pq.poll();
            }
            int rottenDay = i + days[i];
            int count = apples[i];
            if (count > 0) {
                pq.offer(new int[]{rottenDay, count});
            }
            if (!pq.isEmpty()) {
                int[] arr = pq.peek();
                arr[1]--;
                if (arr[1] == 0) {
                    pq.poll();
                }
                ans++;
            }
            i++;
        }
        while (!pq.isEmpty()) {
            while (!pq.isEmpty() && pq.peek()[0] <= i) {
                pq.poll();
            }
            if (pq.isEmpty()) {
                break;
            }
            int[] arr = pq.poll();
            int curr = Math.min(arr[0] - i, arr[1]);
            ans += curr;
            i += curr;
        }
        return ans;
    }
}
```

# 2021/12/22

## [1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)

如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：

二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。

**示例1**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20211225221908.png)

```
输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出：true
解释：每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
```

**示例2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20211225221929.png)

```
输入：root = [5,4,2,3,3,7]
输出：false
解释：每一层的节点值分别是：
0 层：[5]
1 层：[4,2]
2 层：[3,3,7]
2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。
```

### 直接广搜

> 模板就不讲了哈

```java
class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null) return true;
        queue.offer(root);
        int index = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            int pre = index % 2 == 0 ? -1 : Integer.MAX_VALUE;
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue.poll();
                if (index % 2 == 0) {
                    if (cur.val <= pre || cur.val % 2 == 0) return false;
                } else {
                    if (cur.val >= pre || cur.val % 2 == 1) return false;
                }
                pre = cur.val;
                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            index++;
        }
        return true;
    }
}
```

### 送上DFS

```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public boolean isEvenOddTree(TreeNode root) {
        return dfs(root, 0);
    }
    boolean dfs(TreeNode root, int idx) {
        boolean flag = idx % 2 == 0;
        int prev = map.getOrDefault(idx, flag ? 0 : 0x3f3f3f3f), cur = root.val;
        if (flag && (cur % 2 == 0 || cur <= prev)) return false;
        if (!flag && (cur % 2 != 0 || cur >= prev)) return false;
        map.put(idx, root.val);
        if (root.left != null && !dfs(root.left, idx + 1)) return false;
        if (root.right != null && !dfs(root.right, idx + 1)) return false;
        return true;
    }
}
```

# 2021/12/23

## [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)

>最难最难的路，大都是一个人走的，在黑暗中走

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

- age[y] <= 0.5 * age[x] + 7
- age[y] > age[x]
- age[y] > 100 && age[x] < 100

否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

**示例 1**

```
输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。
```

**示例 2**

```
输入：ages = [16,17,18]
输出：2
解释：产生的好友请求为 17 -> 16 ，18 -> 17 。
```

**示例 3**

```
输入：ages = [20,30,100,110,120]
输出：3
解释：产生的好友请求为 110 -> 100 ，120 -> 110 ，120 -> 100 。
```

### 自己的想法

>读完题后发现，第二个条件涵盖了第三个条件，因此只需要满足第一个和第二个条件，最简单的，时间复杂度：O(n^2)，直接模拟
>
>TTL

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        int ans = 0;
        int n = ages.length;
        for (int x = 0; x < n; x++) {
            for (int y = 0; y < n; y++) {
                if (x == y) continue;
                int ageX = ages[x];
                int ageY = ages[y];
                if (ageY > ageX || ageY <= 0.5 * ageX + 7) continue;
                ans++;
            }
        }
        return ans;
    }
}
```

> 发现可以不需要第二层循环，假设当前发请求的人是x，那么x可以给那些y发送请求呢？时间复杂度：*O*(nlogn)12ms

显然可以得出，y的取值范围：

0.5 * ages[x] + 7 <= ages[y] <= ages[x]

- 二分查找ages[x]的下限
- 0.5 * ages[x] + 7的上限

防止频繁调用查找函数，如果x和x - 1的值相同，那么不需要调用

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        int ans = 0;
        int n = ages.length;
        Arrays.sort(ages);
        int tail = 0;
        int head = 0;
        for (int x = 0; x < n; x++) {
            if (x == 0 || ages[x] != ages[x - 1]) {
                tail = upK(ages, ages[x]);
                head = downK(ages, (int) (0.5 * ages[x] + 7) + 1);
            }
            ans += tail > head ? tail - head : 0;
        }
        return ans;
    }
    public int upK(int[] arr, int tar) {
        int l = 0;
        int r = arr.length - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (arr[mid] <= tar) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
    public int downK(int[] arr, int tar) {
        int l = 0;
        int r = arr.length - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (arr[mid] < tar) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return r;
    }
}
```

> 继续优化，发现相等的情况可以一起处理，直接将x跳转到不相等的地方即可 10ms

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        int ans = 0;
        int n = ages.length;
        Arrays.sort(ages);
        for (int x = 0; x < n; x++) {
            int tail = upK(ages, ages[x]);
            int head = downK(ages, (int) (0.5 * ages[x] + 7) + 1);
            ans += tail > head ? (tail - head) * (tail + 1 - x) : 0;
            x = tail;
        }
        return ans;
    }
    public int upK(int[] arr, int tar) {
        int l = 0;
        int r = arr.length - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (arr[mid] <= tar) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
    public int downK(int[] arr, int tar) {
        int l = 0;
        int r = arr.length - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (arr[mid] < tar) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return r;
    }
}
```

### 官方题解

#### 排序 + 双指针

> 没啥说的，确实比双二分简单，但是没有我双二分快 时间复杂度：*O*(nlogn)

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        int n = ages.length;
        Arrays.sort(ages);
        int left = 0, right = 0, ans = 0;
        for (int age : ages) {
            if (age < 15) {
                continue;
            }
            while (ages[left] <= 0.5 * age + 7) {
                ++left;
            }
            while (right + 1 < n && ages[right + 1] <= age) {
                ++right;
            }
            ans += right - left;
        }
        return ans;
    }
}
```

#### 计数排序 + 前缀和

> 桶排序YYDS

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211227200308.png" alt="image-20211227200304720" style="zoom:80%;" />

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        int[] cnt = new int[121];
        for (int age : ages) {
            ++cnt[age];
        }
        int[] pre = new int[121];
        for (int i = 1; i <= 120; ++i) {
            pre[i] = pre[i - 1] + cnt[i];
        }
        int ans = 0;
        for (int i = 15; i <= 120; ++i) {
            if (cnt[i] > 0) {
                int bound = (int) (i * 0.5 + 8);
                ans += cnt[i] * (pre[i] - pre[bound - 1] - 1);
            }
        }
        return ans;
    }
}
```

# 2021/12/24

## [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)

> 懂的怎样生活，人生更容易出彩

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

**示例 1：**

```
输入：words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
输出：["catsdogcats","dogcatsdog","ratcatdogcat"]
解释："catsdogcats" 由 "cats", "dog" 和 "cats" 组成; 
     "dogcatsdog" 由 "dog", "cats" 和 "dog" 组成; 
     "ratcatdogcat" 由 "rat", "cat", "dog" 和 "cat" 组成。
```

**示例 2：**

```
输入：words = ["cat","dog","catdog"]
输出：["catdog"]
```

### 字典树 + DFS

> 想到了字典树，但是，，针对：当words中存在cat，cats也会被输出的问题没有解决，所以需要使用DFS，确保每一种较短单词的会被用到

> 使用数组

```java
class Solution {
    Trie root = new Trie();
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();
        Arrays.sort(words, Comparator.comparingInt(String::length));
        for (String word : words) {
            if (word.length() == 0) continue;;
            if (dfs(word, 0)) {
                ans.add(word);
            } else {
                insert(word);
            }
        }
        return ans;
    }
    private boolean dfs(String word, int start) {
        if (start == word.length()) return true;
        Trie node = root;
        for (int i = start; i < word.length(); i++) {
            int index = word.charAt(i)- 'a';
            node = node.children[index];
            if (node == null) return false;
            if (node.isEnd) {
                if (dfs(word, i + 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    public void insert(String word) {
        Trie cur = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (cur.children[index] == null) {
                cur.children[index] = new Trie();
            }
            cur = cur.children[index];
        }
        cur.isEnd = true;
    }
}
class Trie {
    public boolean isEnd;
    public Trie[] children;
    public Trie() {
        this.isEnd = false;
        this.children = new Trie[26];
    }
}
```

> 使用哈希表

```java
class Solution {
    Trie root = new Trie();
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();
        Arrays.sort(words, Comparator.comparingInt(String::length));
        for (String word : words) {
            if (word.length() == 0) continue;
            if (dfs(word, 0)) {
                ans.add(word);
            } else {
                root.insert(word);
            }
        }
        return ans;
    }
    private boolean dfs(String word, int start) {
        if (word.length() == start) return true;
        Trie node = root;
        for (int i = start; i < word.length(); i++) {
            char ch = word.charAt(i);
            node = node.children.get(ch);
            if (node == null) {
                return false;
            }
            if (node.isEnd) {
                if (dfs(word, i + 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    class Trie {
        private boolean isEnd;
        Map<Character, Trie> children;
        public Trie() {
            isEnd = false;
            children = new HashMap<>();
        }
        public void insert(String word) {
            Trie cur = this;
            for (char c : word.toCharArray()) {
                if (!cur.children.containsKey(c)) {
                    cur.children.put(c, new Trie());
                }
                cur = cur.children.get(c);
            }
            cur.isEnd = true;
        }
    }
}
```

# 2021/12/29

## [1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

- nums[a] + nums[b] + nums[c] == nums[d] ，且
- a < b < c < d

**示例 1**

```
输入：nums = [1,2,3,6]
输出：1
解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。
```

**示例 2**

```
输入：nums = [3,3,6,4,5]
输出：0
解释：[3,3,6,4,5] 中不存在满足要求的四元组。
```

**示例 3**

```
输入：nums = [1,1,1,3,5]
输出：4
解释：满足要求的 4 个四元组如下：
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
```

### 暴力遍历

> 时间复杂度:*O(n^4)*

```java
class Solution {
    // 直接枚举
    public int countQuadruplets(int[] nums) {
        int n = nums.length;
        int ans = 0;;
        for (int a = 0; a < n; a++) {
            for (int b = a + 1; b < n; b++) {
                for (int c = b + 1; c < n; c++) {
                    for (int d = c + 1; d < n; d++) {
                        if (nums[a] + nums[b] + nums[c] == nums[d]) {
                            ans++;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```

### 哈希表

由原始式子推导出

`nums[a] + nums[b] = nums[d] - nums[c]`

> 使用哈希表保存`nums[d] - nums[c]` 时间复杂度:*O(n^2)*

```java
class Solution {
    // 哈希
    public int countQuadruplets(int[] nums) {
        int n = nums.length;
        int ans = 0;
        HashMap<Integer, Integer> cnt = new HashMap<>();
        for (int b = n - 3; b >= 1 ; b--) {
            for (int d = b + 2; d < n; d++) {
                cnt.put(nums[d] - nums[b + 1],
                        cnt.getOrDefault(nums[d] - nums[b + 1], 0) + 1);
            }
            for (int a = 0; a < b; a++) {
                ans += cnt.getOrDefault(nums[a] + nums[b], 0);
            }
        }
        return ans;
    }
}
```

# 2021/12/30

## [846. 一手顺子](https://leetcode-cn.com/problems/hand-of-straights/)

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。

给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。

**示例 1**

```
输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
```

**示例 2**

```
输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。
```

### 自己的想法

>首先对数组进行排序，然后使用HashMap统计每一个数出现的次数，然后从小到大取数，每次取groupSize个，如果没有或者为0返回false即可，处理细节，一开始需要判断hand.length()是否是groupSize的整数倍即可 时间复杂度:*O(nlogn)*

```java
class Solution {
    public boolean isNStraightHand(int[] hand, int groupSize) {
        int n = hand.length;
        if (n % groupSize != 0) return false;
        Arrays.sort(hand);
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : hand) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        for (int cur : hand) {
            if (map.get(cur) == 0) continue;
            for (int j = cur; j < cur + groupSize; j++) {
                if (!map.containsKey(j) || map.get(j) == 0) {
                    return false;
                } else {
                    map.put(j, map.get(j) - 1);
                }
            }
        }
        return true;
    }
}	
```

> 想着用数组进行优化一下，因为数组按照索引查询*O(1)*的时间复杂度，比HashMap查询时间复杂度*O(logn)*快不少，但是当最大载太大时超内存了

```java
public boolean isNStraightHand(int[] hand, int groupSize) {
  int n = hand.length;
  if (n % groupSize != 0) return false;
  Arrays.sort(hand);
  int max = hand[n - 1];
  int[] count = new int[max + 1];
  for (int cur : hand) {
      count[cur]++;
  }
  for (int cur : hand) {
      if (count[cur] == 0) continue;
      count[cur]--;
      for (int i = cur + 1; i < cur + groupSize; i++) {
          if (i > max || count[i] == 0) {
              return false;
          } else {
              count[i]--;
          }
      }
  }
  return true;
```

### 官方题解

> 第一次和官网想法完全一样

```java
class Solution {
    public boolean isNStraightHand(int[] hand, int groupSize) {
        int n = hand.length;
        if (n % groupSize != 0) {
            return false;
        }
        Arrays.sort(hand);
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (int x : hand) {
            cnt.put(x, cnt.getOrDefault(x, 0) + 1);
        }
        for (int x : hand) {
            if (!cnt.containsKey(x)) {
                continue;
            }
            for (int j = 0; j < groupSize; j++) {
                int num = x + j;
                if (!cnt.containsKey(num)) {
                    return false;
                }
                cnt.put(num, cnt.get(num) - 1);
                if (cnt.get(num) == 0) {
                    cnt.remove(num);
                }
            }
        }
        return true;
    }
}
```

> 使用优先队列 + 哈希表模拟

```java
class Solution {
    public boolean isNStraightHand(int[] hand, int m) {
        Map<Integer, Integer> map = new HashMap<>();
        // 小顶堆
        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a));
        for (int cur : hand) {
            map.put(cur, map.getOrDefault(cur, 0) + 1);
            queue.offer(cur);
        }
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            if (map.get(cur) == 0) continue;
            for (int i = 0; i < m; i++) {
                int cnt = map.getOrDefault(cur + i, 0);
                if (cnt == 0) return false;
                map.put(cur + i, cnt - 1);
            }
        }
        return true;
    }
}
```

# 2021/12/31

## [507. 完美数](https://leetcode-cn.com/problems/perfect-number/)

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

**示例 1**

```
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
```

**示例 2**

```
输入：num = 496
输出：true
```

### 枚举试除法

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num == 1) return false;
        int ans = 1;
        for (int i = 2; i <= num / i; i++) {
            if (num % i == 0) {
                ans += i;
                ans += num / i;
            }
        }
        return ans == num;
    }
}
```

### 数学

根据欧几里得-欧拉定理，每个偶完全数都可以写成

`2^(p−1) * (2^p−1)`

的形式，其中 p为素数且 2^p-1为素数。

由于目前奇完全数还未被发现，因此题目范围 [1,10^8]内的完全数都可以写成上述形式。

这一共有如下5个：

6,28,496,8128,33550336

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        return num == 6 || num == 28 || num == 496 || num == 8128 || num == 33550336;
    }
}
```

# 2022/1/1

## [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

> 一转二（2021-2022），简单快乐

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

**示例 1**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220101130150.png" alt="img" style="zoom: 80%;" />

```
输入：original = [1,2,3,4], m = 2, n = 2
输出：[[1,2],[3,4]]
解释：
构造出的二维数组应该包含 2 行 2 列。
original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。
original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。
```

**示例 2**

```
输入：original = [1,2,3], m = 1, n = 3
输出：[[1,2,3]]
解释：
构造出的二维数组应该包含 1 行 3 列。
将 original 中所有三个元素放入第一行中，构成要求的二维数组。
```

### 自己的想法

> 寻找二维数组与一位数组之间的关系，二维数组的`row = i / n`，`col = i % n `   时间复杂度：*O(mn)*

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) return  new int[0][];
        int[][] ans = new int[m][n];
        for (int i = 0; i < original.length; i++) {
            int row = i / n;
            int col = i % n;
            ans[row][col] = original[i];
        }
        return ans;
    }
}
```

### 官方题解

> 使用`System.arraycopy()`函数  时间复杂度*O(m)*

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) {
            return new int[0][];
        }
        int[][] ans = new int[m][n];
        for (int i = 0; i < original.length; i += n) {
            System.arraycopy(original, i, ans[i / n], 0, n);
        }
        return ans;
    }
}
```

# 2022/1/2

## [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。

**示例 1**

```
输入：n = 9
输出：6
解释：
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]
```

**示例 2**

```
输入：n = 1
输出：1
```

> 等差数列模拟，题解看官网吧

```java
class Solution {
    public int lastRemaining(int n) {
        int a1 = 1, an = n;
        int k = 0, cnt = n, step = 1;
        while (cnt > 1) {
            // 正向
            if (k % 2 == 0) {
                a1 += step;
                an -= cnt % 2 == 0 ? 0 : step;
            } else {
                a1 += cnt % 2 == 0 ? 0 : step;
                an -= step;
            }
            step *= 2;
            cnt >>= 1;
            k++;
        }
        return a1;
    }
}
```

# 2022/1/3

> 要继续做关于未来的梦，人生就是爱上自己的未来...

## [1154. 一年中的第几天](https://leetcode-cn.com/problems/day-of-the-year/)

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

**示例 1**

```
输入：date = "2019-01-09"
输出：9
```

**示例 2**

```
输入：date = "2019-02-10"
输出：41
```

> 使用Calendar类

```java
class Solution {
    public int dayOfYear(String date) {
        String[] strings = date.split("-");
        Calendar calendar = new GregorianCalendar();
        calendar.set(Integer.parseInt(strings[0]), Integer.parseInt(strings[1]) - 1, Integer.parseInt(strings[2]));
        long curTime = calendar.getTime().getTime();
        calendar.set(Integer.parseInt(strings[0]), Calendar.JANUARY, 1);
        long preTime = calendar.getTime().getTime();
        int ans = (int) ((curTime - preTime) / 1000 / 60 / 60 / 24) + 1;
        return ans;
    }
}
```

> 模拟

```java
class Solution {
    public int dayOfYear(String date) {
        int year = Integer.parseInt(date.substring(0, 4));
        int month = Integer.parseInt(date.substring(5, 7));
        int day = Integer.parseInt(date.substring(8));

        int[] amount = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        if (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) {
            ++amount[1];
        }

        int ans = 0;
        for (int i = 0; i < month - 1; ++i) {
            ans += amount[i];
        }
        return ans + day;
    }
}
```

## [1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

**示例 1**

```
输入：day = 31, month = 8, year = 2019
输出："Saturday"
```

**示例 2**

```
输入：day = 18, month = 7, year = 1999
输出："Sunday"
```

> 使拥Calender类

```java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        String[] ans = new String[]{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        Calendar calendar = new GregorianCalendar();
        calendar.set(year, month - 1, day);
        return ans[calendar.get(Calendar.DAY_OF_WEEK) - 1];
    }
}
```

### 官方题解

题目规定输入的日期一定是在 19711971 到 21002100 年之间的有效日期，即在 19711971 年 11 月 11 日，到 21002100 年 1212 月 3131 日之间。通过查询日历可知，19701970 年 1212 月 3131 日是星期四，我们只需要算出输入的日期距离 19701970 年 1212 月 3131 日有几天，再加上 33 后对 77 求余，即可得到输入日期是一周中的第几天。

求输入的日期距离 19701970 年 1212 月 3131 日的天数，可以分为三部分分别计算后求和：

（1）输入年份之前的年份的天数贡献；
（2）输入年份中，输入月份之前的月份的天数贡献；
（3）输入月份中的天数贡献。

```java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        String[] weeks = new String[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
        // 1971年以前第一个闰年是1968，所以是year - （1968 + 1)
        int days = 365 * (year - 1971) + (year - 1969) / 4;
        for (int i = 0; i < month - 1; i++) {
            days += months[i];
        }
        if ((year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) && month > 2) {
            day++;
        }
        days += day;
        return weeks[(days + 3) % 7];
    }
}
```

# 2022/1/5

## [1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

**示例 1**

```
输入：s = "?zs"
输出："azs"
解释：该示例共有 25 种解决方案，从 "azs" 到 "yzs" 都是符合题目要求的。只有 "z" 是无效的修改，因为字符串 "zzs" 中有连续重复的两个 'z' 。
```

**示例 2**

```
输入：s = "ubv?w"
输出："ubvaw"
解释：该示例共有 24 种解决方案，只有替换成 "v" 和 "w" 不符合题目要求。因为 "ubvvw" 和 "ubvww" 都包含连续重复的字符。
```

> 找到替换即可

```java
class Solution {
    public String modifyString(String s) {
        StringBuilder builder = new StringBuilder();
        char pre = ' ';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '?') {
                for (int j = 0; j < 26; j++) {
                    char cur = (char) (j + 'a');
                    if (cur == pre) continue;
                    if (i + 1 < s.length() && cur == s.charAt(i + 1)) {
                        continue;
                    } else {
                        builder.append(cur);
                        pre = cur;
                        break;
                    }
                }
            } else {
                builder.append(c);
                pre = c;
            }
        }
        return builder.toString();
    }
}
```

> 官方题解类似

# 2022/1/6

## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

- 始终以斜杠 '/' 开头。
- 两个目录名之间必须只有一个斜杠 '/' 。
- 最后一个目录名（如果存在）不能 以 '/' 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
- 返回简化后得到的 规范路径 。

**示例 1**

```
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```

**示例 2**

```
输入：path = "/a/./b/../../c/"
输出："/c"
```

### 自己想法

>直接用栈模拟，不难

```java
class Solution {
    public String simplifyPath(String path) {
        String[] strings = path.split("/");
        Deque<String> stack = new ArrayDeque<>();
        for (String string : strings) {
            if (string.equals("") || string.equals(".")) continue;
            if (string.equals("..")) {
                if (!stack.isEmpty())
                    stack.pop();
            } else {
                stack.push(string);
            }
        }
        if (stack.isEmpty()) return "/";
        StringBuilder builder = new StringBuilder();
        while (!stack.isEmpty()) {
            builder.append("/");
            builder.append(stack.pollLast());
        }
        return builder.toString();
    }
}
```

### 官方题解

> 没啥区别，不贴了

# 2022/1/7

> 最美的不是你生如夏花，而是在时光的长河里波澜不惊

## [1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：

- 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
- 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
- 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

- depth("") = 0
- depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
- depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
- depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串

例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。

**示例 1**

```
输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
```

**示例 2**

```
输入：s = "(1)+((2))+(((3)))"
输出：3
```

> 思路：主要统计出现过最大的左括号数

```java
class Solution {
    public int maxDepth(String s) {
        int lCount = 0;
        int max = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                lCount++;
                max = Math.max(max, lCount);
            } else if (c == ')') {
                lCount--;
            }
        }
        return max;
    }
}
```

## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
  返回整数作为最终结果。

注意：

- 本题中的空白字符只包括空格字符 ' ' 。
- 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

**示例 1**

```
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```

**示例 2**

```
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。
```

**示例 3**

```
输入：s = "-91283472332"
输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。
```

### 自己想法

>模拟：先确定符号位，再去除所有的首项零，然后判断大小是否在 [−2^31,  2^31 − 1] 

```java
class Solution {
    public int myAtoi(String s) {
        s = s.trim();
        StringBuilder ans = new StringBuilder();
        if (s.length() == 0) return 0;
        int index = 0;
        if (s.charAt(index) == '+' || s.charAt(index) == '-') {
            ans.append(s.charAt(index++));
        }
        if (ans.length() == 0) {
            ans.append("+");
        }
        for (; index < s.length(); index++) {
            char c = s.charAt(index);
            if (c == '0' && ans.length() == 0) continue;
            if (c >= '0' && c <= '9') {
                ans.append(c);
                if (ans.length() > 10) {
                    long l = Long.parseLong(ans.toString());
                    if (l < Integer.MIN_VALUE) return Integer.MIN_VALUE;
                    if (l > Integer.MAX_VALUE) return Integer.MAX_VALUE;
                }
            } else {
                break;
            }
        }
        return ans.length() == 1 ? 0 : Integer.parseInt(ans.toString());
    }
}
```

### 官方题解

> 自动机

**思路**

字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。

因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：

我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s'。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s' 的表格即可解决题目中的问题。

**算法**

本题可以建立如下图所示的自动机：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220107150057.png" alt="fig1" style="zoom:80%;" />

我们也可以用下面的表格来表示这个自动机：

|           |  ' '  |  +/-   |  number   | other |
| :-------: | :---: | :----: | :-------: | :---: |
|   start   | start | signed | in_number |  end  |
|  signed   |  end  |  end   | in_number |  end  |
| in_number |  end  |  end   | in_number |  end  |
|    end    |  end  |  end   |    end    |  end  |

接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。

另外自动机也需要记录当前已经输入的数字，只要在 s' 为 in_number 时，更新我们输入的数字，即可最终得到输入的数字。

```java
class Solution {
    public int myAtoi(String s) {
        Automaton automaton = new Automaton();
        for (char c : s.toCharArray()) {
            automaton.get(c);
        }
        return (int) (automaton.sign * automaton.ans);
    }
}
class Automaton {
    // 1:+
    // -1:-
    public int sign = 1;
    public long ans = 0L;
    private String state = "start";
    private Map<String, String[]> tables = new HashMap<>();
    {
        tables.put("start", new String[]{"start", "signed", "in_number", "end"});
        tables.put("signed", new String[]{"end", "end", "in_number", "end"});
        tables.put("in_number", new String[]{"end", "end", "in_number", "end"});
        tables.put("end", new String[]{"end", "end", "end", "end"});
    }
    public void get(char c) {
        if (state.equals("end")) return;
        state = tables.get(state)[get_col(c)];
        if ("in_number".equals(state)) {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? Math.min(ans, Integer.MAX_VALUE)
                    : Math.min(ans, -(long)Integer.MIN_VALUE);
        } else if ("signed".equals(state)) {
            sign = c == '+' ? 1 : -1;
        }
    }
    private int get_col(char c) {
        if (c == ' ') return 0;
        if (c == '+' || c == '-') return 1;
        if (Character.isDigit(c)) return 2;
        return 3;
    }
}
```

# 2022/1/9

> 人生若只如初见，何事秋风悲画扇。等闲变却故人心，却道故人心易变。

## [1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)

LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。

给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 **下标都从 0 开始** 。第 0 个键在时间为 0 时被按下，接下来每个键都 **恰好** 在前一个键松开时被按下。

测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。

注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。

请返回按键 **持续时间最长** 的键，如果有多个这样的键，则返回 **按字母顺序排列最大** 的那个键。

**示例 1**

```java
输入：releaseTimes = [9,29,49,50], keysPressed = "cbcd"
输出："c"
解释：按键顺序和持续时间如下：
按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）
按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）
按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）
按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）
按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20
'c' 按字母顺序排列比 'b' 大，所以答案是 'c'
```

**示例 2	**

````java
输入：releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
输出："a"
解释：按键顺序和持续时间如下：
按下 's' ，持续时间 12
按下 'p' ，持续时间 23 - 12 = 11
按下 'u' ，持续时间 36 - 23 = 13
按下 'd' ，持续时间 46 - 36 = 10
按下 'a' ，持续时间 62 - 46 = 16
按键持续时间最长的键是 'a' ，持续时间 16
````

> 直接一次遍历模拟

```java
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
        int maxTime = releaseTimes[0];
        char maxChar = keysPressed.charAt(0);
        for (int i = 1; i < keysPressed.length(); i++) {
            char c = keysPressed.charAt(i);
            int curTime = releaseTimes[i] - releaseTimes[i - 1];
            if (curTime >= maxTime && (curTime > maxTime || c > maxChar)) {
                maxChar = c;
                maxTime = curTime;
            }
        }
        return maxChar;
    }
}
```

# 2022/1/10

> 仰天长笑出门去，我辈岂是蓬蒿人

## [306. 累加数](https://leetcode-cn.com/problems/additive-number/)

**累加数** 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。

说明：累加序列里的数 **不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。

**示例 1**

```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

**示例 2**

```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

> 穷举累加序列第一个数字和第二个数字的所有可能性

==java==

```java
class Solution {
    public boolean isAdditiveNumber(String num) {
        int n = num.length();
        int secondStart = 1;
        for (; secondStart < n - 1; ++secondStart) {
            if (num.charAt(0) == '0' && secondStart != 1) break;
            for (int secondEnd = secondStart; secondEnd < n - 1; secondEnd++) {
                if (num.charAt(secondStart) == '0' && secondStart != secondEnd) break;
                if (valid(secondStart, secondEnd, num)) {
                    return true;
                }
            }
        }
        return false;
    }
    private boolean valid(int secondStart, int secondEnd, String num) {
        int n = num.length();
        int firstStart = 0, firstEnd = secondStart - 1;
        while (secondEnd <= n - 1) {
            String third = StringAdd(num, firstStart, firstEnd, secondStart, secondEnd);
            int thirdStart = secondEnd + 1;
            int thirdEnd = secondEnd + third.length();
            if (thirdEnd >= n || !num.substring(thirdStart, thirdEnd + 1).equals(third)) break;
            if (thirdEnd == n - 1) return true;
            firstStart = secondStart;
            firstEnd = secondEnd;
            secondStart = thirdStart;
            secondEnd = thirdEnd;
        }
        return false;
    }
    private String StringAdd(String num, int firstStart, int firstEnd, int secondStart, int secondEnd) {
        StringBuilder builder = new StringBuilder();
        int factor = 0;
        while (firstEnd >= firstStart || secondEnd >= secondStart) {
            int cur = factor;
            cur += firstEnd >= firstStart ? num.charAt(firstEnd--) - '0' : 0;
            cur += secondEnd >= secondStart ? num.charAt(secondEnd--) - '0' : 0;
            factor = cur / 10;
            cur = cur % 10;
            builder.append(cur);
        }
        if (factor != 0) {
            builder.append(factor);
        }
        return builder.reverse().toString();
    }
}
```

==go==

```go
func isAdditiveNumber(num string) bool {
	n := len(num)
	for secondStart := 1; secondStart < n-1; secondStart++ {
		if num[0] == '0' && secondStart != 1 {
			break
		}
		for secondEnd := secondStart; secondEnd < n-1; secondEnd++ {
			if num[secondStart] == '0' && secondStart != secondEnd {
				break
			}
			if ok := valid(secondStart, secondEnd, num); ok {
				return true
			}
		}
	}
	return false
}

func valid(secondStart int, secondEnd int, num string) bool {
	n := len(num)
	firstStart, firstEnd := 0, secondStart-1
	for secondEnd <= n-1 {
		third := stringAdd(num, firstStart, firstEnd, secondStart, secondEnd)
		thirdStart, thirdEnd := secondEnd+1, secondEnd+len(third)
		if thirdEnd >= n || num[thirdStart:thirdEnd+1] != third {
			break
		}
		if thirdEnd == n-1 {
			return true
		}
		firstStart = secondStart
		firstEnd = secondEnd
		secondStart = thirdStart
		secondEnd = thirdEnd
	}
	return false
}

func stringAdd(num string, firstStart int, firstEnd int, secondStart int, secondEnd int) string {
	factor := 0
	ans := [...]byte{}
	for firstStart <= firstEnd || secondStart <= secondEnd || factor != 0 {
		cur := factor
		if firstEnd >= firstStart {
			cur += (int)(num[firstEnd] - '0')
			firstEnd--
		}
		if secondStart <= secondEnd {
			cur += (int)(num[secondEnd] - '0')
			secondEnd--
		}
		factor = cur / 10
		cur %= 10
		ans = append(ans, byte(cur)+'0')
	}
	for i, n := 0, len(ans); i < n/2; i++ {
		ans[i], ans[n-1-i] = ans[n-1-i], ans[i]
	}
	return string(ans)
}
```

# 2022/1/11

## [1036. 逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/)

> 日落跌入昭昭星野，人间忽晚，山河以秋

在一个 10^6 x 10^6 的网格中，每个网格上方格的坐标为 `(x, y)` 。

现在从源方格 `source = [sx, sy]` 开始出发，意图赶往目标方格 `target = [tx, ty]` 。数组 `blocked` 是封锁的方格列表，其中每个 blocked[i] = [xi, yi] 表示坐标为 `(xi, yi)` 的方格是禁止通行的。

每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 **不** 在给出的封锁列表 blocked 上。同时，不允许走出网格。	

**示例 1**

```
输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
输出：false
解释：
从源方格无法到达目标方格，因为我们无法在网格中移动。
无法向北或者向东移动是因为方格禁止通行。
无法向南或者向西移动是因为不能走出网格。
```

**示例 2**

```
输入：blocked = [], source = [0,0], target = [999999,999999]
输出：true
解释：
因为没有方格被封锁，所以一定可以到达目标方格。
```

> 有限步数的广搜    	时间复杂度：O(n^2)	空间复杂度：O(n^2)

**思路**：

注意到障碍的个数不超过 200 个，这说明网格中大部分的位置都不是障碍，只有极少一部分的位置是障碍。分析从 source 无法走到 target 的情况，无非就是以下两种：

- source 被障碍完全包围，并且 target 不在包围圈中；
- target 被障碍完全包围，并且 source 不在包围圈中。

在「障碍的个数不超过 200 个前提下」，我们可以猜测「包围圈」的大小也不会很大。也就是说，如果障碍的个数为 n 个，那么我们希望得到「包围圈」中包含的非障碍位置的数量的上界，假设其为limit，那么

>如果我们从source 开始进行广度优先搜索，搜索到的非障碍位置的数量严格大于limit，那么说明 source 一定不在任何包围圈中。同时，如果从target 开始进行广度优先搜索也是如此，那么同样说明target 一定也不在任何包围圈中。此时我们就可以断定，一定能从 source 走到 target。

最优的包围方法一定是选择：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220111120302.png" alt="image-20220111120257166" style="zoom:80%;" />

这 n个位置，此时「包围圈」组成一个等腰直角三角形，如下图所示

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220111120332.png" alt="fig1" style="zoom:80%;" />

其中包含的非障碍位置的数量为 n * (n - 1) / 2

最优性可以通过构造法证明。可以发现，上面给出的包围方法保证了每一行和每一列不会有超过 1 个障碍。对于其它的包围方法，不失一般性，设某一行有 2 个或以上的障碍，此时有两种情况：

- 如果这两个障碍不八连通，那么其中一个障碍的设置是无意义的，因为它不和「包围圈」的外界连通，放置该障碍只会减少「包围圈」中非障碍位置的数量；
- 如果这两个障碍八连通，如下图所示，我们可以将从第一个障碍开始，到离第二个障碍最近的并且行坐标小于等于它为止的所有障碍的行坐标增加 11，这样就可以构造出一个包含非障碍位置数量更多的「包围圈」。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220111134340.png" alt="fig2" style="zoom:80%;" />

因此，最优的包围方法一定保证每一行和每一列不会有超过 11 个障碍。由于我们需要包围住左上角，因此列坐标的必须取 0, 1, 2,  n-1 这 n 个位置（如果取 ≥n，那么该障碍就无法与「包围圈」连通，因为它至少还需要借助 n 个障碍来连接到左边界）。同时，每一行只有一个障碍，因此每个障碍右侧的所有位置是不可能被包围的，只有左侧的位置才可能被包围。而左侧位置的总数为

因此最多包含非障碍位置的数量为 n * (n - 1) / 2

**算法**

我们从 source 开始进行广度优先搜索。如果经过了不超过 n * (n - 1) / 2个非障碍位置就已经结束搜索，说明source 在「包围圈」中。但如果我们在过程中经过了target，那么说明它们是可达的，否则一定不可达。

我们再从target 开始进行广度优先搜索。如果经过了不超过 n * (n - 1) / 2个非障碍位置就已经结束搜索，说明 target 在「包围圈」中。否则说明source 和 target 均不在「包围圈」中，此时一定可达。

==java==

```java
class Solution {
    // 在包围圈中
    static final int BLOCKED = -1;
    // 不在包围圈
    static final int VALID = 0;
    // target和source在一起
    static final int FOUND = 1;
    final int[][] dirs = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    static final int BOUNDARY = 1000000;
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        if (blocked.length < 2) return true;
        Set<Pair> blockedSet = new HashSet<>();
        for (int[] nums : blocked) {
            blockedSet.add(new Pair(nums[0], nums[1]));
        }
        int res = check(blocked, source, target, blockedSet);
        if (res == FOUND) return true;
        if (res == BLOCKED) return false;
        return check(blocked, target, source, blockedSet) != BLOCKED;
    }
    private int check(int[][] blocked, int[] source, int[] target, Set<Pair> blockedSet) {
        int sx = source[0], sy = source[1];
        int tx = target[0], ty = target[1];
        int n = blocked.length;
        int countdown = n * (n - 1) / 2;
        Pair sN = new Pair(sx, sy);
        Queue<Pair> queue = new ArrayDeque<>();
        queue.offer(sN);
        Set<Pair> visited = new HashSet<>();
        visited.add(sN);
        while (!queue.isEmpty() && countdown > 0) {
            Pair cur = queue.poll();
            for (int i = 0; i < 4; i++) {
                int curx = cur.x + dirs[i][0];
                int cury = cur.y + dirs[i][1];
                Pair curN = new Pair(curx, cury);
                if (curx >= 0 && curx < BOUNDARY
                        && cury >= 0 && cury < BOUNDARY
                        && !blockedSet.contains(curN)
                        && !visited.contains(curN)) {
                    if (curx == tx && cury == ty) {
                        return FOUND;
                    }
                    countdown--;
                    queue.offer(curN);
                    visited.add(curN);
                }
            }
        }
        if (countdown > 0) return BLOCKED;
        return VALID;
    }
}
class Pair {
    int x;
    int y;
    public Pair(int x, int y) {
        this.x = x;
        this.y = y;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Pair pair = (Pair) o;
        return x == pair.x &&
                y == pair.y;
    }
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
}
```

==go==

```go
const (
	BLOCKED  = -1      // 圈中
	VALID    = 0       // 不在圈中
	FOUND    = 1       // 搜source时搜到了target
	BOUNDARY = 1000000 // 边界
)

type Pair struct {
	x, y int
}

var dirs = []Pair{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}

func isEscapePossible(blocked [][]int, source []int, target []int) bool {
	n := len(blocked)
	if n < 2 {
		return true
	}
	blockSet := map[Pair]bool{}
	for _, nums := range blocked {
		blockSet[Pair{nums[0], nums[1]}] = true
	}
	check := func(start, finish []int) int {
		sx, sy := start[0], start[1]
		fx, fy := finish[0], finish[1]
		countdown := n * (n - 1) / 2
		q := []Pair{{sx, sy}}
		visited := map[Pair]bool{{sx, sy}: true}
		for len(q) > 0 && countdown > 0 {
			cur := q[0]
			q = q[1:]
			for _, dir := range dirs {
				nx, ny := cur.x+dir.x, cur.y+dir.y
				np := Pair{nx, ny}
				if 0 <= nx && nx < BOUNDARY && 0 <= ny && ny < BOUNDARY &&
					!(visited[np]) && !(blockSet[np]) {
					if nx == fx && ny == fy {
						return FOUND
					}
					countdown--
					visited[np] = true
					q = append(q, np)
				}
			}
		}
		if countdown > 0 {
			return BLOCKED
		}
		return VALID
	}
	res := check(source, target)
	return res == FOUND || res == VALID && check(target, source) != BLOCKED
}
```

# 2022/1/12

## [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

> 南风知我意，吹梦到西洲

给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `	3` 的递增子序列。

如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

**示例 1**

```
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意
```

**示例 2**

```
输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
```

### 自己的想法

> 贪心：规定first为数组第一个元素，然后开始遍历数组，当前数字出现的可能	时间复杂度*O(n)*：

- 小于first，替换first
- 大于first小于second，替换second
- 大于second并且second已经付过值了，证明已经找到递增三元组了，返回即可

==java==

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int first = nums[0];
        int second = -1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > first) {
                if (nums[i] > second && second != -1) return true;
                second = nums[i];
            } else {
                first = nums[i];
            }
        }
        return false;
    }
}
```

==go==

```go
func increasingTriplet(nums []int) bool {
	first, second := nums[0], -1
	for i := 1; i < len(nums); i++ {
		if nums[i] > first {
			if nums[i] > second && second != -1 {
				return true
			}
			second = nums[i]
		} else {
			first = nums[i]
		}
	}
	return false
}
```

### 官方

> 双向遍历

**思路**

如果数组 `nums` 中存在一个下标 i 满足 1 ≤ i < n−1，使得在`nums[i]` 的左边存在一个元素小于 `nums[i]` 且在`nums[i]` 的右边存在一个元素大于`nums[i]`，则数组`nums` 中存在递增的三元子序列

创建两个长度为 n 的数组 `leftMin` 和 `rightMax`，对于0 ≤ i < n，`leftMin[i]` 表示 `nums[0]` 到`nums[i]` 中的最小值，`rightMax[i]` 表示 `nums[i]` 到 ·中的最大值

==java==

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int n = nums.length;
        if (n < 3) return false;
        int[] leftNs = new int[n];
        leftNs[0] = nums[0];
        int[] rightNs = new int[n];
        rightNs[n - 1] = nums[n - 1];
        for (int i = 1; i < n; i++) {
            leftNs[i] = Math.min(leftNs[i - 1], nums[i]);
        }
        for (int i = n - 2; i >= 0; i--) {
            rightNs[i] = Math.max(rightNs[i + 1], nums[i]);
        }
        for (int i = 1; i < n - 1; i++) {
            if (nums[i] > leftNs[i - 1] && nums[i] < rightNs[i + 1]) return true;
        }
        return false;
    }
}
```

==go==

```go
func increasingTriplet(nums []int) bool {
	n := len(nums)
	if n < 3 {
		return false
	}
	leftNs, rightNs := make([]int, n), make([]int, n)
    leftNs[0] = nums[0]
	rightNs[n-1] = nums[n-1]
	for i := 1; i < n; i++ {
		leftNs[i] = min(leftNs[i-1], nums[i])
	}
	for i := n - 2; i >= 0; i-- {
		rightNs[i] = max(rightNs[i+1], nums[i])
	}
	for i := 1; i < n-1; i++ {
		if nums[i] > leftNs[i-1] && nums[i] < rightNs[i+1] {
			return true
		}
	}
	return false
}

func max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a int, b int) int {
	if a < b {
		return a
	}
	return b
}
```

# 2022/1/13

## [747. 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)

给你一个整数数组 `nums` ，其中总是存在 **唯一的** 一个最大整数 。

请你找出数组中的最大元素并检查它是否 **至少是数组中每个其他数字的两倍** 。如果是，则返回 **最大元素的下标** ，否则返回 `-1` 。

**示例 1**

```
输入：nums = [3,6,1,0]
输出：1
解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
```

**示例 2**

```
输入：nums = [1,2,3,4]
输出：-1
解释：4 没有超过 3 的两倍大，所以返回 -1 。
```

### 自己的想法

> 循环数组一次，找出最大的数和次大的数，进行判断

==java==

```java
class Solution {
    public int dominantIndex(int[] nums) {
        int pre = 0, max = 0, maxIdx = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > max) {
                pre = max;
                max = nums[i];
                maxIdx = i;
            } else if (nums[i] > pre) {
                pre = nums[i];
            }
        }
        return max >= pre * 2 ? maxIdx : -1;
    }
}
```

==go==

```go
func dominantIndex(nums []int) int {
    m1, m2, idx := -1, -1, 0
    for i, num := range nums {
        if num > m1 {
            m1, m2, idx = num, m1, i
        } else if num > m2 {
            m2 = num
        }
    }
    if m1 >= m2*2 {
        return idx
    }
    return -1
}
```

### 官方题解

> 类似

# 2022/1/14

> 是微风，是晚霞，是心跳，是无可替代

## [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`,  `(u2,v2)`  ...  `(uk,vk)` 。

**示例 1**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**示例 2**

```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

### 优先队列

==java==

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        int m = nums1.length;
        int n = nums2.length;

        /*二分查找第 k 小的数对和的大小*/
        int left = nums1[0] + nums2[0];
        int right = nums1[m - 1] + nums2[n - 1];
        int pairSum = right;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            long cnt = 0;
            int start = 0;
            int end = n - 1;
            while (start < m && end >= 0) {
                if (nums1[start] + nums2[end] > mid) {
                    end--;
                } else {
                    cnt += end + 1;
                    start++;
                }
            }
            if (cnt < k) {
                left = mid + 1;
            } else {
                pairSum = mid;
                right = mid - 1;
            }
        }

        List<List<Integer>> ans = new ArrayList<>();
        int pos = n - 1;
        /*找到小于目标值 pairSum 的数对*/
        for (int i = 0; i < m; i++) {
            while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {
                pos--;
            }
            for (int j = 0; j <= pos && k > 0; j++, k--) {
                List<Integer> list = new ArrayList<>();
                list.add(nums1[i]);
                list.add(nums2[j]);
                ans.add(list);
            }
        }

        /*找到等于目标值 pairSum 的数对*/
        pos = n - 1;
        for (int i = 0; i < m && k > 0; i++) {
            while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {
                pos--;
            }
            for (int j = i; k > 0 && j >= 0 && nums1[j] + nums2[pos] == pairSum; j--, k--) {
                List<Integer> list = new ArrayList<>();
                list.add(nums1[j]);
                list.add(nums2[pos]);
                ans.add(list);
            }
        }
        return ans;
    }
}
```

==go==

```go
func kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {
    m, n := len(nums1), len(nums2)
    h := hp{nil, nums1, nums2}
    for i := 0; i < k && i < m; i++ {
        h.data = append(h.data, pair{i, 0})
    }
    for h.Len() > 0 && len(ans) < k {
        p := heap.Pop(&h).(pair)
        i, j := p.i, p.j
        ans = append(ans, []int{nums1[i], nums2[j]})
        if j+1 < n {
            heap.Push(&h, pair{i, j + 1})
        }
    }
    return
}

type pair struct{ i, j int }
type hp struct {
    data         []pair
    nums1, nums2 []int
}
func (h hp) Len() int            { return len(h.data) }
func (h hp) Less(i, j int) bool  { a, b := h.data[i], h.data[j]; return h.nums1[a.i]+h.nums2[a.j] < h.nums1[b.i]+h.nums2[b.j] }
func (h hp) Swap(i, j int)       { h.data[i], h.data[j] = h.data[j], h.data[i] }
func (h *hp) Push(v interface{}) { h.data = append(h.data, v.(pair)) }
func (h *hp) Pop() interface{}   { a := h.data; v := a[len(a)-1]; h.data = a[:len(a)-1]; return v }
```

### 二分查找

==java==

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(k, (o1, o2)->{
            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];
        });
        List<List<Integer>> ans = new ArrayList<>();
        int m = nums1.length;
        int n = nums2.length;
        for (int i = 0; i < Math.min(m, k); i++) {
            pq.offer(new int[]{i,0});
        }
        while (k-- > 0 && !pq.isEmpty()) {
            int[] idxPair = pq.poll();
            List<Integer> list = new ArrayList<>();
            list.add(nums1[idxPair[0]]);
            list.add(nums2[idxPair[1]]);
            ans.add(list);
            if (idxPair[1] + 1 < n) {
                pq.offer(new int[]{idxPair[0], idxPair[1] + 1});
            }
        }
        
        return ans;
    }
}
```

# 2022/1/15

## [1716. 计算力扣银行的钱](https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/)

Hercy 想要为购买第一辆车存钱。他 **每天** 都往力扣银行里存钱。

最开始，他在周一的时候存入 `1` 块钱。从周二到周日，他每天都比前一天多存入 `1` 块钱。在接下来每一个周一，他都会比 **前一个周一** 多存入 `1` 块钱。

给你 `n` ，请你返回在第 `n` 天结束的时候他在力扣银行总共存了多少块钱。

**示例 1**

```
输入：n = 4
输出：10
解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。
```

**示例 2**

```
输入：n = 20
输出：96
解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。
```

### 数学

> 等差数列

==go==

```go
func totalMoney(n int) int {
	sums := []int{0, 1, 3, 6, 10, 15, 21, 28}
	factor := n / 7
	return factor*28 + (factor-1)*factor/2*7 + factor*(n%7) + sums[n%7]
}
```

==java==

```java
class Solution {
    int[] sums = new int[]{0, 1, 3, 6, 10, 15, 21, 28};
    public int totalMoney(int n) {
        int ans = 0;
        int factor = n / 7;
        // factor * 28:够7个的部分
        // 1 - 7； 2 - 8； 3 - 9 他们每七项的差值是一个公差为7的等差数列，求出他们的差值总和
        // factor * (n % 7) + sums[n % 7] 最后不够的项数和
        ans += factor * 28 + (factor - 1) * factor / 2 * 7 + factor * (n % 7) + sums[n % 7];
        return ans;
    }
}
```

# 2022/1/16

## [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。

实现 `Solution` 类：

- `Solution(ListNode head)` 使用整数数组初始化对象。
- `int getRandom()` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

**示例**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220116125608.png" alt="image-20220116125600537" style="zoom: 80%;" />

```
输入
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
输出
[null, 1, 3, 2, 2, 3]

解释
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // 返回 1
solution.getRandom(); // 返回 3
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 3
// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。
```

### 自己的想法

> Random函数

==java==

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    private List<Integer> list;
    private Random random;
    public Solution(ListNode head) {
        list = new ArrayList<>();
        ListNode tmp = head;
        while (tmp != null) {
            list.add(tmp.val);
            tmp = tmp.next;
        }
        random = new Random();
    }
    public int getRandom() {
        return list.get(random.nextInt(list.size()));
    }
}
```

==go==

```go
type Solution struct {
	nodes []int
}

func Constructor(head *ListNode) (s Solution) {
	for node := head; node != nil; node = node.Next {
		s.nodes = append(s.nodes, node.Val)
	}
	return s
}

func (s *Solution) GetRandom() int {
	return s.nodes[rand.Intn(len(s.nodes))]
}
```

### 官方解法

方法一需要花费 O(n) 的空间存储链表中的所有元素，那么能否做到 O(1) 的空间复杂度呢？

我们可以设计如下算法：

从链表头开始，遍历整个链表，对遍历到的第 i 个节点，随机选择区间 [0,i)内的一个整数，如果其等于 0，则将答案置为该节点值，否则答案不变。

该算法会保证每个节点的值成为最后被返回的值的概率均为 1 / n，证明如下

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220116133411.png" alt="image-20220116133407373" style="zoom:80%;" />

==java==

```java
class Solution {
    ListNode head;
    Random random;

    public Solution(ListNode head) {
        this.head = head;
        random = new Random();
    }

    public int getRandom() {
        int i = 1, ans = 0;
        for (ListNode node = head; node != null; node = node.next) {
            if (random.nextInt(i) == 0) { // 1/i 的概率选中（替换为答案）
                ans = node.val;
            }
            ++i;
        }
        return ans;
    }
}
```

==go==

```go
type Solution struct {
	head *ListNode
}

func Constructor(head *ListNode) (s Solution) {
	s.head = head
	return s
}

func (s *Solution) GetRandom() int {
	ans := 0
	for i, node := 1, s.head; node != nil; node = node.Next {
		if rand.Intn(i) == 0 {
			ans = node.Val
		}
		i++
	}
	return ans
}
```

# 2022/1/17

> 唤起一天明月，照我满杯冰雪 步履浩荡...

## [1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/)

给你一个整数 `n`，请你帮忙统计一下我们可以按下述规则形成多少个长度为 `n` 的字符串：

- 字符串中的每个字符都应当是小写元音字母（`'a'`, `'e'`, `'i'`, `'o'`, `'u'`）
- 每个元音 `'a'` 后面都只能跟着 `'e'`
- 每个元音 `'e'` 后面只能跟着 `'a'` 或者是 `'i'`
- 每个元音 `'i'` 后面 不能 再跟着另一个 `'i'`
- 每个元音 `'o'` 后面只能跟着 `'i'` 或者是 `'u'`
- 每个元音 `'u'` 后面只能跟着 `'a'`

由于答案可能会很大，所以请你返回 模 `10^9 + 7` 之后的结果。

**示例 1**

```
输入：n = 1
输出：5
解释：所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。
```

**示例 2**

```
输入：n = 2
输出：10
解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
```

### 自己的想法

> 动态规划，因为当前字符串的个数只与前一种情况的末尾原因字母是什么有关系，只用记录上一次的末尾字母元素的个数 
>
> 时间复杂度：*O*(C×n)

- 元音字母 a 前面只能跟着 e i u
- 元音字母 e 前面只能跟着 a i
- 元音字母 i 前面只能跟着 e o
- 元音字母 o 前面只能跟着 i
- 元音字母 u 前面只能跟着 o i

==java==

```java
class Solution {
    private int MOD = (int)Math.pow(10, 9) + 7;
    public int countVowelPermutation(int n) {
        long[] count = new long[5];
        Arrays.fill(count, 1);
        for (int i = 1; i < n; i++) {
            long countA = count[0];
            long countE = count[1];
            long countI = count[2];
            long countO = count[3];
            long countU = count[4];
            Arrays.fill(count, 0);
            count[0] = (countE + countI + countU) % MOD;
            count[1] = (countA + countI) % MOD;
            count[2] = (countE + countO) % MOD;
            count[3] = countI;
            count[4] = (countI + countO) % MOD;
        }
        long sum = 0;
        for (long i : count) {
            sum = (i + sum) % MOD;
        }
        return (int) sum;
    }
}
```

==go==

```go
func countVowelPermutation(n int) (ans int) {
	const MOD int = 1e9 + 7
	count := [5]int{1, 1, 1, 1, 1}
	for i := 1; i < n; i++ {
		countA, countE, countI, countO, countU := count[0], count[1], count[2], count[3], count[4]
		for i := 0; i < 5; i++ {
			count[i] = 0
		}
		count = [5]int{
			(countE + countI + countU) % MOD,
			(countA + countI) % MOD,
			(countE + countO) % MOD,
			countI,
			(countI + countO) % MOD,
		}
	}
	for _, num := range count {
		ans = (ans + num) % MOD
	}
	return
}
```

### 官方题解

> 矩阵快速幂

已经知道上述的递推公式，可以转将其转化为矩阵乘法，设 *f*(*n*) 表示长度为 *n* 的字符串且以不同元音字母为结尾的组合数矩阵，构造矩阵的递推关系如下

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220117134331.png" alt="image-20220117134327106" style="zoom:80%;" />

==java==

```java
class Solution {
    private int MOD = (int) Math.pow(10, 9) + 7;
    public int countVowelPermutation(int n) {
        // 由动态规划解法可以获取矩阵如下
        long[][] factor =
                {
                        {0, 1, 0, 0, 0},
                        {1, 0, 1, 0, 0},
                        {1, 1, 0, 1, 1},
                        {0, 0, 1, 0, 1},
                        {1, 0, 0, 0, 0}
                };
        long[][] res = fastPow(factor, n - 1);
        long ans = 0;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                ans = (ans + res[i][j]) % MOD;
            }
        }
        return (int) ans;
    }
    private long[][] fastPow(long[][] factor, int n) {
        int m = factor.length;
        long[][] res = new long[m][m];
        long[][] cur = factor;
        // 将res矩阵初始化为单位矩阵
        for (int i = 0; i < m; i++) {
            res[i][i] = 1;
        }
        
        // 快速幂
        for (int i = n; i != 0; i >>= 1) {
            if ((i % 2) == 1) {
                res = multiply(cur, res);
            }
            cur = multiply(cur, cur);
        }
        return res;
    }
    private long[][] multiply(long[][] matrixA, long[][] matrixB) {
        int m = matrixA.length;
        int n = matrixB[0].length;
        long[][] res = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < matrixA.length; k++) {
                    res[i][j] = (res[i][j] + matrixA[i][k] * matrixB[k][j]) % MOD;
                }
            }
        }
        return res;
    }
}
```

==go==

```go
const mod int = 1e9 + 7

type matrix [5][5]int

func (a matrix) mul(b matrix) matrix {
    c := matrix{}
    for i, row := range a {
        for j := range b[0] {
            for k, v := range row {
                c[i][j] = (c[i][j] + v*b[k][j]) % mod
            }
        }
    }
    return c
}

func (a matrix) pow(n int) matrix {
    res := matrix{}
    for i := range res {
        res[i][i] = 1
    }
    for ; n > 0; n >>= 1 {
        if n&1 > 0 {
            res = res.mul(a)
        }
        a = a.mul(a)
    }
    return res
}

func countVowelPermutation(n int) (ans int) {
    m := matrix{
        {0, 1, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 1, 0, 1, 1},
        {0, 0, 1, 0, 1},
        {1, 0, 0, 0, 0},
    }
    res := m.pow(n - 1)
    for _, row := range res {
        for _, v := range row {
            ans = (ans + v) % mod
        }
    }
    return
}
```

# 2022/1/18

> 有趣的人生，一半是山川湖海

## [539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

给定一个 24 小时制（小时:分钟 **"HH:MM"**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。

**示例 1**

```
输入：timePoints = ["23:59","00:00"]
输出：1
```

**示例 2**

```
输入：timePoints = ["00:00","23:59","00:00"]
输出：0
```

### 自己的想法

> 排序，求相邻的时间差，最后在计算第一个和最后一个的时间差即可

==java==

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        Collections.sort(timePoints);
        int min = Integer.MAX_VALUE;
        int t0Min = getMinutes(timePoints.get(0));
        int preMin = t0Min;
        for (int i = 1; i < timePoints.size(); i++) {
            int curMin = getMinutes(timePoints.get(i));
            // 相邻的时间差
            min = Math.min(min, curMin - preMin);
            preMin = curMin;
        }
        // 首尾的时间差
        min = Math.min(min, t0Min + 24 * 60 - preMin);
        return min;
    }
    private int getMinutes(String s) {
        return ((s.charAt(0) - '0') * 10 + s.charAt(1) - '0') * 60
                + (s.charAt(3) - '0') * 10 + s.charAt(4) - '0';
    }
}
```

### 官方题解

> 鸽巢原理

根据题意，一共有 `24×60=1440` 种不同的时间。由鸽巢原理可知，如果 `timePoints` 的长度超过 `1440`，那么必然会有两个相同的时间，此时可以直接返回 `0`。

==java==

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        int n = timePoints.size();
        if (n > 1440) return 0;
        Collections.sort(timePoints);
        int ans = Integer.MAX_VALUE;
        int t0Minutes = getMinutes(timePoints.get(0));
        int preMinutes = t0Minutes;
        for (int i = 1; i < n; ++i) {
            int minutes = getMinutes(timePoints.get(i));
            ans = Math.min(ans, minutes - preMinutes); // 相邻时间的时间差
            preMinutes = minutes;
        }
        ans = Math.min(ans, t0Minutes + 1440 - preMinutes); // 首尾时间的时间差
        return ans;
    }
    public int getMinutes(String t) {
        return ((t.charAt(0) - '0') * 10 + (t.charAt(1) - '0')) * 60 + (t.charAt(3) - '0') * 10 + (t.charAt(4) - '0');
    }
}
```

==go==

```go
func findMinDifference(timePoints []string) int {
	n := len(timePoints)
	if n > 1440 {
		return 0
	}
	sort.Strings(timePoints)
	ans := math.MaxInt32
	t0Min := getMinutes(timePoints[0])
	preMin := t0Min
	for i := 1; i < n; i++ {
		curMin := getMinutes(timePoints[i])
		ans = min(ans, curMin-preMin)
		preMin = curMin
	}
	ans = min(ans, t0Min+1440-preMin)
	return ans
}

func min(a int, b int) int {
	if a < b {
		return a
	}
	return b
}

func getMinutes(t string) int {
	return (int(t[0]-'0')*10+int(t[1]-'0'))*60 + int(t[3]-'0')*10 + int(t[4]-'0')
}
```

# 2022/1/19

## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

> 待到秋来九月八，我花开后百花杀

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例 1**

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

**示例 2**

```
输入：nums = [1,0,1,1], k = 1
输出：true
```

## 自己的想法

> 滑动数组 + 哈希

==java==

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        if (k == 0) return false;
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (i >= k) {
                if (set.contains(nums[i])) {
                    return true;
                }
                set.remove(nums[i - k]);
            }
            if (!set.add(nums[i])) return true;
        }
        return false;
    }
}
```

==go==

```go
func containsNearbyDuplicate(nums []int, k int) bool {
	set := map[int]struct{}{}
	for i, num := range nums {
		if i > k {
			delete(set, nums[i-k-1])
		}
		if _, ok := set[num]; ok {
			return true
		}
		set[num] = struct{}{}
	}
	return false
}
```

> 还有直接使用哈希表

==java==

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int length = nums.length;
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            if (map.containsKey(num) && i - map.get(num) <= k) {
                return true;
            }
            map.put(num, i);
        }
        return false;
    }
}
```

==go==

```go
func containsNearbyDuplicate(nums []int, k int) bool {
	pos := map[int]int{}
	for i, num := range nums {
		if p, ok := pos[num]; ok && i-p <= k {
			return true
		}
		pos[num] = i
	}
	return false
}
```

# 2022/1/20

## [2029. 石子游戏 IX](https://leetcode-cn.com/problems/stone-game-ix/)

Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 `stones` ，其中 `stones[i]` 是第 `i` 个石子的价值。

Alice 和 Bob 轮流进行自己的回合，**Alice** 先手。每一回合，玩家需要从 `stones` 中移除任一石子。

如果玩家移除石子后，导致 **所有已移除石子** 的价值 **总和** 可以被 3 整除，那么该玩家就 **输掉游戏** 。
如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
假设两位玩家均采用 **最佳** 决策。如果 Alice 获胜，返回 `true` ；如果 Bob 获胜，返回 `false` 。

**示例 1**

```
输入：stones = [2,1]
输出：true
解释：游戏进行如下：
- 回合 1：Alice 可以移除任意一个石子。
- 回合 2：Bob 移除剩下的石子。 
已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
```

**示例 2**

```
输入：stones = [5,1,2,4,3]
输出：false
解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：
- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
```

### 官方题解

由于玩家的目标是使得已经被移除的石子的价值总和不是 3 的倍数，因此我们可以把石子分成三类，它们的价值除以 3 的余数分别为 0,1,2。我们可以直接用 0,1,2 代表它们的价值，对应的石子数量分别为 `cnt0`,`cnt1` ,`cnt2`

可以发现，移除类型 0 的石子并不会对总和产生影响，因此类型 0 的石子可以看成是「先后手」交换。具体地，例如当前是 Alice 在进行操作，它发现如果自己选择移除类型 1 或 2 的石子，那么她在最后一定不能获胜。这时它就可以选择移除一个类型 0 的石子，将同样的局面交给 Bob。如果类型 0 的石子还没有移除完，那么 Bob 同样可以通过移除一个类型 0 的石子将局面重新交给 Alice。这样不断地往复下去，我们可以得到结论

- 如果类型 0 的石子的个数为**偶数**，那么胜负情况等价于没有类型 0 的石子的胜负情况；
- 如果类型 0 的石子个数为**奇数**，那么胜负情况等价于只有 1 个类型 0 的石子的胜负情况。注意这里不能单纯地等价于「没有类型 00 的石子的胜负情况」的相反情况，这是因为如果所有的石子都被移除完，无论谁移除了最后一个石子，都算 Alice 输。因此如果 Alice 发现自己选择移除类型 1 或 2 的石子不能获胜，于是选择移除类型 0 的石子，并且它不能获胜的原因是「石子会移除完」，那么 Alice 仍然会输

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220120174649.png" alt="image-20220120174639092" style="zoom:80%;" />

==java==

```java
class Solution {
    public boolean stoneGameIX(int[] stones) {
        int cnt0 = 0, cnt1 = 0, cnt2 = 0;
        for (int val : stones) {
            int type = val % 3;
            if (type == 0) {
                ++cnt0;
            } else if (type == 1) {
                ++cnt1;
            } else {
                ++cnt2;
            }
        }
        if (cnt0 % 2 == 0) {
            return cnt1 >= 1 && cnt2 >= 1;
        }
        return cnt1 - cnt2 > 2 || cnt2 - cnt1 > 2;
    }
}
```

==go==

```go
func stoneGameIX(stones []int) bool {
    cnt0, cnt1, cnt2 := 0, 0, 0
    for _, val := range stones {
        val %= 3
        if val == 0 {
            cnt0++
        } else if val == 1 {
            cnt1++
        } else {
            cnt2++
        }
    }
    if cnt0%2 == 0 {
        return cnt1 >= 1 && cnt2 >= 1
    }
    return cnt1-cnt2 > 2 || cnt2-cnt1 > 2
}
```

# 2022/3/6

> 信手拈来的从容，都是厚积薄发的沉淀

## [2100. 适合打劫银行的日子](https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/)

你和一群强盗准备打劫银行。给你一个下标从 **0** 开始的整数数组 `security` ，其中 `security[i]` 是第 `i` 天执勤警卫的数量。日子从 `0` 开始编号。同时给你一个整数 `time` 。

如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：

- 第 i 天前和后都分别至少有 `time` 天。
- 第 i 天前连续 `time` 天警卫数目都是非递增的。
- 第 i 天后连续 `time` 天警卫数目都是非递减的。

更正式的，第 `i` 天是一个合适打劫银行的日子当且仅当：`security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].`

请你返回一个数组，包含 **所有** 适合打劫银行的日子（下标从 **	** 开始）。返回的日子可以 **任意** 顺序排列。

**示例 1**

```
输入：security = [5,3,3,3,5,6,2], time = 2
输出：[2,3]
解释：
第 2 天，我们有 security[0] >= security[1] >= security[2] <= security[3] <= security[4] 。
第 3 天，我们有 security[1] >= security[2] >= security[3] <= security[4] <= security[5] 。
没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。
```

**示例 2**

```
输入：security = [1,1,1,1,1], time = 0
输出：[0,1,2,3,4]
解释：
因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。
```

### 动态规划

> 维护两个数组left和right，left[i]表示在i下标前非递增元素的个数；right[i]表示在i下标后非递减元素的个数
>
> 从time遍历到len - time统计可以打劫的下标

==java==

```java
class Solution {
    public List<Integer> goodDaysToRobBank(int[] security, int time) {
        int len = security.length;
        int[] left = new int[len];
        int[] right = new int[len];
        for (int i = 1; i < len; i++) {
            if (security[i] <= security[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
            if (security[len - 1 - i] <= security[len - i]) {
                right[len - 1 - i] = right[len - i] + 1;
            }
        }
        List<Integer> ans = new ArrayList<>();
        for (int i = time; i < len - time; i++) {
            if (left[i] >= time && right[i] >= time) {
                ans.add(i);
            }
        }
        return ans;
    }
}
```

==go==

```go
func goodDaysToRobBank(security []int, time int) (ans []int) {
    n := len(security)
    left := make([]int, n)
    right := make([]int, n)
    for i := 1; i < n; i++ {
        if security[i] <= security[i-1] {
            left[i] = left[i-1] + 1
        }
        if security[n-i-1] <= security[n-i] {
            right[n-i-1] = right[n-i] + 1
        }
    }

    for i := time; i < n-time; i++ {
        if left[i] >= time && right[i] >= time {
            ans = append(ans, i)
        }
    }
    return
}
```

## [521. 最长特殊序列 Ⅰ](https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/)

给你两个字符串 `a` 和 `b`，请返回 这两个字符串中 **最长的特殊序列**  的长度。如果不存在，则返回 `-1` 。

**「最长特殊序列」** 定义如下：该序列为 **某字符串独有的最长子序列（即不能是其他字符串的子序列）** 。

字符串 `s` 的子序列是在从 `s` 中删除任意数量的字符后可以获得的字符串。

- 例如，`"abc"` 是 `"aebdc"` 的子序列，因为删除 `"aebdc"` 中斜体加粗的字符可以得到 `"abc"` 。 `"aebdc"` 的子序列还包括 `"aebdc"` 、 `"aeb"` 和 `""` (空字符串)。


**示例 1**

```
输入: a = "aba", b = "cdc"
输出: 3
解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。
```

**示例 2**

```
输入：a = "aaa", b = "bbb"
输出：3
解释: 最长特殊序列是 "aaa" 和 "bbb" 。
```

### 官方题解

字符串的子序列的长度不会超过该字符串的长度。若子序列的长度等于字符串的长度，那么子序列就是该字符串。

若两字符串不相同，那么我们可以选择较长的字符串作为最长特殊序列，显然它不会是较短的字符串的子序列。特别地，当两字符串长度相同时（但不是同一字符串），我们仍然可以选择其中的一个字符串作为最长特殊序列，它不会是另一个字符串的子序列。

若两字符串相同，那么任一字符串的子序列均会出现在两个字符串中，此时应返回 -1−1。

==java==

```java
class Solution {
    public int findLUSlength(String a, String b) {
        return !a.equals(b) ? Math.max(a.length(), b.length()) : -1;
    }
}
```

==go==

```go
func findLUSlength(a, b string) int {
    if a != b {
        return max(len(a), len(b))
    }
    return -1
}

func max(a, b int) int {
    if b > a {
        return b
    }
    return a
}
```

# 2022/3/8

> 努力的过程本身就是孤岛

## [504. 七进制数](https://leetcode-cn.com/problems/base-7/)

给定一个整数 `num`，将其转化为 **7 进制**，并以字符串形式输出。

**示例 1**

```
输入: num = 100
输出: "202
```

**示例 2**

```
输入: num = -7
输出: "-10"
```

### 解法

> 取模运算，余数即为七进制数，注意符号和0

==java==

```java
class Solution {
    public String convertToBase7(int num) {
        if (num == 0) return "0";
        StringBuilder ans = new StringBuilder();
        boolean symbol = num > 0;
        num = Math.abs(num);
        while (num > 0) {
            ans.append(num % 7);
            num /= 7;
        }
        if (!symbol) {
            ans.append("-");
        }
        return ans.reverse().toString();
    }
}
```

==go==

```go
func convertToBase7(num int) string {
	if num == 0 {
		return "0"
	}
	symbol := num < 0
	if symbol {
		num = -num
	}
	s := []byte{}
	for num > 0 {
		s = append(s, '0'+byte(num%7))
		num /= 7
	}
	if symbol {
		s = append(s, '-')
	}
	for i, n := 0, len(s); i < n/2; i++ {
		s[i], s[n-i-1] = s[n-1-i], s[i]
	}
	return string(s)
}
```

## [2055. 蜡烛之间的盘子](https://leetcode-cn.com/problems/plates-between-candles/)

给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 **0** 开始的字符串 `s` ，它只包含字符 `'*'` 和 `'|'` ，其中 `'*'` 表示一个 **盘子** ，`'|'` 表示一支 **蜡烛** 。

同时给你一个下标从 **0** 开始的二维整数数组 `queries` ，其中 `queries[i] = [lefti, righti]` 表示 **子字符串** `s[lefti...righti]` （**包含左右端点的字符**）。对于每个查询，你需要找到 **子字符串中** 在 **两支蜡烛之间** 的盘子的 **数目** 。如果一个盘子在 **子字符串中** 左边和右边 **都** 至少有一支蜡烛，那么这个盘子满足在 **两支蜡烛之间** 。

- ​	比方说，`s = "||**||**|*"` ，查询 `[3, 8]` ，表示的是子字符串 `"*||**|"` 。子字符串中在两支蜡烛之间的盘子数目为 `2` ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。

请你返回一个整数数组 `answer` ，其中 `answer[i]` 是第 `i` 个查询的答案。

**示例 1**

![ex-1](https://gitee.com/zhang-songyao/blog-images/raw/master/20220308140756.png)

```
输入：s = "**|**|***|", queries = [[2,5],[5,9]]
输出：[2,3]
解释：
- queries[0] 有两个盘子在蜡烛之间。
- queries[1] 有三个盘子在蜡烛之间。
```

**示例 2**

![ex-2](https://gitee.com/zhang-songyao/blog-images/raw/master/20220308140820.png)

```
输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
输出：[9,0,0,0,0]
解释：
- queries[0] 有 9 个盘子在蜡烛之间。
- 另一个查询没有盘子在蜡烛之间。
```

### 自己的想法

统计出s字符串中所有`'|'`的下标保存在`nums`数组中

对于每个query[i]

- left = query[0]：`nums`中二分查找寻找大于等于left的下标即从左开始第一个`'|'`的位置
- right = query[1]：`nums`中二分查找寻找小于等于right的下标即从右开始第一个`'|'`的位置
- 邻接处理，`leftCandleIdx`、`rightCandleIdx`不能等于-1并且`nums[rightCandleIdx] > nums[leftCandleIdx]`

计算盘子数量：

- 满足条件的蜡烛和盘子总数量：`nums[rightCandleIdx] + 1 - nums[leftCandleIdx]`

- 蜡烛数量：`rightCandleIdx + 1 - leftCandleIdx`

作差即可

==java==

```java
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        List<Integer> list = new ArrayList<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '|') {
                list.add(i);
            }
        }
        int[] ans = new int[queries.length];
        int size = list.size();
        if (size == 0) {
            return ans;
        }
        int[] nums = new int[size];
        for (int i = 0; i < size; i++) {
            nums[i] = list.get(i);
        }
        int index = 0;
        for (int[] query : queries) {
            int left = query[0];
            int right = query[1];
            int leftCandleIdx = binary_search0(nums, left);
            int rightCandleIdx = binary_search1(nums, right);
            if (leftCandleIdx == -1
                    || rightCandleIdx == -1
                    || nums[rightCandleIdx] <= nums[leftCandleIdx]) {
                ans[index++] = 0;
                continue;
            }
            int candleNum = nums[rightCandleIdx] + 1 - nums[leftCandleIdx]
                    - (rightCandleIdx + 1 - leftCandleIdx);
            ans[index++] = Math.max(0, candleNum);
        }
        return ans;
    }
    private int binary_search0(int[] nums, int tar) {
        int l = 0;
        int r = nums.length - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] < tar) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return nums[r] >= tar ? r : -1;
    }
    private int binary_search1(int[] nums, int tar) {
        int l = 0;
        int r = nums.length - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (nums[mid] <= tar) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return nums[l] <= tar ? l : -1;
    }
}
```

==go==

```go
func platesBetweenCandles(s string, queries [][]int) []int {
	ans, nums := []int{}, []int{}
	for i, idx := 0, 0; i < len(s); i++ {
		if s[i] == '|' {
			nums = append(nums, i)
			idx++
		}
	}
	if len(nums) == 0 {
        ans = append(ans, 0)
		return ans
	}
	for i := 0; i < len(queries); i++ {
		query := queries[i]
		left, right := query[0], query[1]
		leftCandleIdx, rightCandleIdx := binarySearch0(nums, left), binarySearch1(nums, right)
		if leftCandleIdx == -1 || rightCandleIdx == -1 || nums[rightCandleIdx] <= nums[leftCandleIdx] {
			ans = append(ans, 0)
			continue
		}
		candleNum := nums[rightCandleIdx] + 1 - nums[leftCandleIdx] - (rightCandleIdx + 1 - leftCandleIdx)
		if candleNum > 0 {
			ans = append(ans, candleNum)
		} else {
			ans = append(ans, 0)
		}
	}
	return ans
}

func binarySearch1(nums []int, tar int) int {
	l, r := 0, len(nums)-1
	for l < r {
		mid := (l + r + 1) >> 1
		if nums[mid] <= tar {
			l = mid
		} else {
			r = mid - 1
		}
	}
	if nums[l] <= tar {
		return l
	}
	return -1
}

func binarySearch0(nums []int, tar int) int {
	l, r := 0, len(nums)-1
	for l < r {
		mid := (l + r) >> 1
		if nums[mid] < tar {
			l = mid + 1
		} else {
			r = mid
		}
	}
	if nums[r] >= tar {
		return r
	}
	return -1
}
```

### 官方题解

#### 预处理 + 前缀和

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220308162802.png" alt="image-20220308162758581" style="zoom:80%;" />

==java==

```java
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        int n = s.length();
        int len = queries.length;
        int[] preSum = new int[n];
        int[] left = new int[n];
        int[] right = new int[n];
        char[] chars = s.toCharArray();
        int l = -1;
        int r = -1;
        int sum = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '*') {
                sum++;
            } else {
                l = i;
            }
            preSum[i] = sum;
            left[i] = l;
        }
        for (int i = n - 1; i >= 0; i--) {
            if (chars[i] == '|') {
                r = i;
            }
            right[i] = r;
        }
        int[] ans = new int[len];
        int idx = 0;
        for (int[] query : queries) {
            int x = right[query[0]];
            int y = left[query[1]];
            ans[idx++] = x == -1 || y == -1 || x >= y ? 0 : preSum[y] - preSum[x];
        }
        return ans;
    }
}
```

==go==

```go
func platesBetweenCandles(s string, queries [][]int) []int {
	n := len(s)
	preSum, left, right, ans := make([]int, n), make([]int, n), make([]int, n), make([]int, len(queries))
	for i, sum, l := 0, 0, -1; i < n; i++ {
		if s[i] == '*' {
			sum++
		} else {
			l = i
		}
		preSum[i] = sum
		left[i] = l
	}
	for i, r := n-1, -1; i >= 0; i-- {
		if s[i] == '|' {
			r = i
		}
		right[i] = r
	}
	for i, q := range queries {
		x, y := right[q[0]], left[q[1]]
		if x >= 0 && y >= 0 && x < y {
			ans[i] = preSum[y] - preSum[x]
		}
	}
	return ans
}
```

# 2022/3/9

> 喧闹任其喧闹，自由我自为之

## [1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

这里有 `n` 个航班，它们分别从 `1` 到 `n` 进行编号。

有一份航班预订表 `bookings` ，表中第 `i` 条预订记录 `bookings[i] = [firsti, lasti, seatsi]` 意味着在从 `firsti` 到 `lasti` （包含 `firsti` 和 `lasti` ）的 **每个航班** 上预订了 `seatsi` 个座位。

请你返回一个长度为 `n` 的数组 `answer`，里面的元素是每个航班预定的座位总数。

**示例 1**

```
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```

**示例 2**

```
输入：bookings = [[1,2,10],[2,2,15]], n = 2
输出：[10,25]
解释：
航班编号        1   2
预订记录 1 ：   10  10
预订记录 2 ：       15
总座位数：      10  25
因此，answer = [10,25]
```

### [差分数组](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490329&idx=1&sn=6d448a53cd722bbd990fda82bd262857&chksm=fd9cb006caeb3910758522054564348b7eb4bde333889300bd5d249950be12a5b990b5d2c059&token=168273153&lang=zh_CN#rd)

本题只涉及「区间修改 + 单点查询」，因此是一道「差分」的模板题。

「差分」可以看做是求「前缀和」的逆向过程。

对于一个「将区间 [l,r] 整体增加一个值 v」操作，我们可以对差分数组 c 的影响看成两部分：

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220309103835.png" alt="image-20220309103831492" style="zoom:80%;" />

对于最后的构造答案，可看做是对每个下标做“单点查询”操作，只需要对差分数组求前缀和即可

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] c = new int[n + 1];
        for (int[] booking : bookings) {
            int l = booking[0] - 1, r = booking[1] - 1, v = booking[2];
            c[l] += v;
            c[r + 1] -= v;
        }
        int[] ans = new int[n];
        ans[0] = c[0];
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i - 1] + c[i];
        }
        return ans;
    }
}
```



## [798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

给你一个数组 `nums`，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]` 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

- 例如，数组为 `nums = [2,4,1,3,0]`，我们按 `k = 2` 进行轮调后，它将变成 `[1,3,0,2,4]`。这将记为 `3` 分，因为 `1 > 0` [不计分]、`3 > 1` [不计分]、`0 <= 2` [计 1 分]、`2 <= 3` [计 1 分]，`4 <= 4` [计 1 分]。

在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 `k` 。如果有多个答案，返回满足条件的最小的下标 `k` 。

**示例 1**

```
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
```

**示例 2**

```
输入：nums = [1,3,0,2,4]
输出：0
解释：
nums 无论怎么变化总是有 3 分。
所以我们将选择最小的 k，即 0。
```

### 暴力*O(n^2)*

> TTL

==java==

```java
class Solution {
    public int bestRotation(int[] nums) {
        int maxScore = 0;
        int len = nums.length;
        int maxK = 0;
        for (int k = 0; k < len; k++) {
            int score = 0;
            for (int i = 0; i < len; i++) {
                if (nums[(k + i) % len] <= i) {
                    score++;
                }
            }
            if (score > maxScore) {
                maxK = k;
                maxScore = score;
            }
        }
        return maxK;
    }
}
```

### 官方题解

> 差分数组

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220309102317.png" alt="image-20220309102313201" style="zoom:80%;" />

```java
class Solution {
    static int N = 100010;
    static int[] c = new int[N];
    void add(int l, int r) {
        c[l] += 1; c[r + 1] -= 1;
    }
    public int bestRotation(int[] nums) {
        Arrays.fill(c, 0);
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            int a = (i - (n - 1) + n) % n, b = (i - nums[i] + n) % n;
            if (a <= b) {
                add(a, b);
            } else {
                add(0, b);
                add(a, n - 1);
            }
        }
        for (int i = 1; i <= n; i++) c[i] += c[i - 1];
        int ans = 0, k = c[0];
        for (int i = 1; i <= n; i++) {
            if (c[i] > k) {
                k = c[i]; ans = i;
            }
        }
        return ans;
    }
}
```

# 2022/3/13

> 昔日龌龊不足夸，今朝放荡思天涯。春风得意马蹄疾，一日看尽长安花

## [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

给定一个 n 叉树的根节点 `root` ，返回 其节点值的 **后序遍历** 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

**示例 1**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220313193104.png" alt="img" style="zoom:80%;" />

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[5,6,3,2,4,1]
```

**示例 2**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220313193131.png" alt="img" style="zoom:80%;" />

````
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]
````

> 后序遍历，递归即可

==java==

```java
class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> ans = new ArrayList<>();
        order(root, ans);
        return ans;
    }
    private void order(Node node, List<Integer> ans) {
        if (node == null) return;
        if (node.children != null) {
            for (Node child : node.children) {
                order(child, ans);
            }
        }
        ans.add(node.val);
    }
}
```

==go==

```go
type Node struct {
	Val      int
	Children []*Node
}

func postorder(root *Node) (ans []int) {
	var dfs func(*Node)
	dfs = func(node *Node) {
		if node == nil {
			return
		}
		for _, child := range node.Children {
			dfs(child)
		}
		ans = append(ans, node.Val)
	}
	dfs(root)
	return
}
```

## [393. UTF-8 编码验证](https://leetcode-cn.com/problems/utf-8-validation/)

给定一个表示数据的整数数组 `data` ，返回它是否为有效的 **UTF-8** 编码。

**UTF-8** 中的一个字符可能的长度为 **1 到 4 字节**，遵循以下的规则：

- 对于 **1 字节** 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。
- 对于 **n 字节** 的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。

这是 UTF-8 编码的工作方式：

```
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

**注意：**输入是整数数组。只有每个整数的 **最低 8 个有效位** 用来存储数据。这意味着每个整数只表示 1 字节的数据。

**示例 1**

```
输入：data = [197,130,1]
输出：true
解释：数据表示字节序列:11000101 10000010 00000001。
这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。
```

**示例 2**

```
输入：data = [235,140,4]
输出：false
解释：数据表示 8 位的序列: 11101011 10001100 00000100.
前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
```

### 转换为二进制计算

==java==

```java
class Solution {
    public boolean validUtf8(int[] data) {
        int len = data.length;
        String[] dataStrs = new String[len];
        for (int i = 0; i < len; i++) {
            if (data[i] < 128) {
                StringBuilder s = new StringBuilder(Integer.toBinaryString((1 << 8) | data[i]));
                s.replace(0, 1, "0");
                dataStrs[i] = s.toString();
            } else {
                dataStrs[i] = Integer.toBinaryString(data[i]);
            }
        }
        int idx = 0;
        while (idx < len) {
            String curStr = dataStrs[idx];
            int indexOfZero = curStr.indexOf("0");
            if (indexOfZero == 0) {
                idx++;
                continue;
            }
            if (indexOfZero == -1 || indexOfZero > 4 || indexOfZero == 1) return false;
            int nextIdx = idx + indexOfZero;
            if (nextIdx > len) return false;
            idx++;
            while (idx < nextIdx) {
                if (dataStrs[idx].charAt(0) != '1' || dataStrs[idx].charAt(1) != '0') {
                    return false;
                }
                idx++;
            }
        }
        return true;
    }
}
```

### 遍历 + 位运算

==java==

```java
class Solution {
    static final int MASK1 = 1 << 7;
    static final int MASK2 = (1 << 7) + (1 << 6);
    public boolean validUtf8(int[] data) {
        int len = data.length;
        int idx = 0;
        while (idx < len) {
            int num = data[idx];
            int n = getBytes(num);
            if (n < 0 || n + idx > len) {
                return false;
            }
            for (int i = 1; i < n; i++) {
                if(!isValid(data[idx + i])) {
                    return false;
                }
            }
            idx += n;
        }
        return true;
    }
    private int getBytes(int num) {
        if ((num & MASK1) == 0) {
            return 1;
        }
        int n = 0;
        int mask = MASK1;
        while ((num & mask) != 0) {
            n++;
            if (n > 4) {
                return -1;
            }
            mask >>= 1;
        }
        // 过滤n = 1的情况
        return n >= 2 ? n : -1;
    }
    private boolean isValid(int num) {
        return (num & MASK2) == MASK1;
    }
}
```

==go==

```go
const (
	MASK2 = (1 << 7) + (1 << 6)
	MASK1 = 1 << 7
)

func getBytes(num int) int {
	if (num & MASK1) == 0 {
		return 1
	}
	n := 0
	mask := MASK1
	for (mask & num) != 0 {
		n++
		if n > 4 {
			return -1
		}
		mask >>= 1
	}
	if n < 2 {
		return -1
	} else {
		return n
	}
}

func validUtf8(data []int) bool {

	var idx, m = 0, len(data)
	for idx < m {
		num := data[idx]
		n := getBytes(num)
		if n < 0 || (n+idx) > m {
			return false
		}
		for i := 1; i < n; i++ {
			if !isValid(data[idx+i]) {
				return false
			}
		}
		idx += n
	}
	return true
}

func isValid(num int) bool {
	return (num & MASK2) == MASK1
}
```

# 2022/3/14

> 人间骄阳正好，风过林梢，彼时他们正当年少

## [599. 两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)

假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用**最少的索引**和找出他们**共同喜爱的餐厅**。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。

**示例 1**

```
输入: list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
输出: ["Shogun"]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。
```

**示例 2**

```
输入:list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["KFC", "Shogun", "Burger King"]
输出: ["Shogun"]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。
```

### 时间换空间

> 时间复杂度*O(n)*

==java==

```java
class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        int minIdx = Integer.MAX_VALUE;
        List<String> ans = new ArrayList<>();
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < list1.length; i++) {
            map.put(list1[i], i);
        }
        for (int i = 0; i < list2.length; i++) {
            String s = list2[i];
            if (map.containsKey(s)) {
                int sumIdx = map.get(s) + i;
                if (sumIdx < minIdx) {
                    minIdx = sumIdx;
                    ans.clear();
                    ans.add(s);
                } else if (sumIdx == minIdx){
                    ans.add(s);
                }
            }
        }
        if (ans.size() == 1) {
            return new String[]{ans.get(0)};
        }
        String[] res = new String[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            res[i] = ans.get(i);
        }
        return res;
    }
}
```

==go==

```go
func findRestaurant(list1 []string, list2 []string) []string {
	var ans []string
	set := make(map[string]int)
	for i, s := range list1 {
		set[s] = i
	}
	minIdx := math.MaxInt32
	for i, s := range list2 {
		if j, ok := set[s]; ok {
			if i+j < minIdx {
				minIdx = i + j
				ans = []string{s}
			} else if i+j == minIdx {
				ans = append(ans, s)
			}
		}
	}
	return ans
}
```

# 2022/3/15

> 人与人之间，差距最小的是智商，差距最大的是努力

## [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 

**示例 1**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220315155029.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```

**示例 2**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220315155046.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

### 显示中序遍历

==java==

```java
class Solution {
    public void recoverTree(TreeNode root) {
        if (root == null) return;
        List<Integer> list = new ArrayList<>();
        infixOrder(root, list);
        int[] swapped = findTwoSwapped(list);
        recover(root, 2, swapped[0], swapped[1]);
    }

    private void recover(TreeNode node, int count, int x, int y) {
        if (node != null) {
            if (node.val == x || node.val == y) {
                node.val = node.val == x ? y : x;
                if (--count == 0) {
                    return;
                }
            }
            recover(node.left, count, x, y);
            recover(node.right, count, x, y);
        }
    }

    private int[] findTwoSwapped(List<Integer> list) {
        int n = list.size();
        int index2 = -1, index1 = -1;
        for (int i = 0; i < n - 1; i++) {
            if (list.get(i + 1) < list.get(i)) {
                index2 = i + 1;
                if (index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }
        return new int[]{list.get(index1), list.get(index2)};
    }

    private void infixOrder(TreeNode node, List<Integer> list) {
        if (node.left != null) {
            infixOrder(node.left, list);
        }
        list.add(node.val);
        if (node.right != null) {
            infixOrder(node.right, list);
        }
    }
}
```

==go==

```go
func recoverTree(root *TreeNode) {
	nums := []int{}
	var infixOrder func(root *TreeNode)
	infixOrder = func(root *TreeNode) {
		if root == nil {
			return
		}
		infixOrder(root.Left)
		nums = append(nums, root.Val)
		infixOrder(root.Right)
	}
	infixOrder(root)
	x, y := findTwoSwapped(nums)
	recoverNode(root, 2, x, y)
}

func recoverNode(node *TreeNode, count int, x int, y int) {
	if node != nil {
		if node.Val == x || node.Val == y {
			if node.Val == x {
				node.Val = y
			} else {
				node.Val = x
			}
			count--
			if count == 0 {
				return
			}
		}
		recoverNode(node.Left, count, x, y)
		recoverNode(node.Right, count, x, y)
	}
}

func findTwoSwapped(nums []int) (x int, y int) {
	index1, index2 := -1, -1
	n := len(nums)
	for i := 0; i < n-1; i++ {
		if nums[i+1] < nums[i] {
			index2 = i + 1
			if index1 == -1 {
				index1 = i
			} else {
				break
			}
		}
	}
	x, y = nums[index1], nums[index2]
	return
}

```

### 隐式中序遍历

==java==

```java
class Solution {
    public void recoverTree(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode x = null, y = null, pred = null;
        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (pred != null && root.val < pred.val) {
                y = root;
                if (x != null) {
                    x = pred;
                } else {
                    break;
                }
            }
            pred = root;
            root = root.right;
        }
        swap(x, y);
    }
    private void swap(TreeNode x, TreeNode y) {
        int tmp = x.val;
        x.val = y.val;
        y.val = tmp;
    }
}
```

==go==

```go
func recoverTree(root *TreeNode) {
	stack := []*TreeNode{}
	var x, y, pred *TreeNode
	for len(stack) > 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if pred != nil && root.Val < pred.Val {
			y = root
			if x == nil {
				x = pred
			} else {
				break
			}
		}
		pred = root
		root = root.Right
	}
	x.Val, y.Val = y.Val, x.Val
}
```

## [2044. 统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)

给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目** 。

如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 **子集** 。如果选中的元素下标位置不一样，则认为两个子集 **不同** 。

对数组 a 执行 按位或 ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 **0** 开始）。

**示例 1**

```
输入：nums = [3,1]
输出：2
解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：
- [3]
- [3,1]
```

**示例 2**

```
输入：nums = [2,2,2]
输出：7
解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。
```

### 回溯

==java==

```java
class Solution {
    int maxOrVal = Integer.MIN_VALUE;
    int count = 0;
    public int countMaxOrSubsets(int[] nums) {
        dfs(nums,0, 0);
        return count;
    }
    private void dfs(int[] nums, int idx, int orVal) {
        if (idx == nums.length) {
            if (orVal > maxOrVal) {
                maxOrVal = orVal;
                count = 1;
            } else if (orVal == maxOrVal) {
                count++;
            }
            return;
        }
        // 拿
        dfs(nums, idx + 1, orVal | nums[idx]);
        // 不拿
        dfs(nums, idx + 1, orVal);
    }
}
```

==go==

```go
func countMaxOrSubsets(nums []int) int {
	maxOrVal := math.MinInt32
	var dfs func(idx int, orVal int)
	count := 0
	dfs = func(idx int, orVal int) {
		if idx == len(nums) {
			if orVal > maxOrVal {
				maxOrVal = orVal
				count = 1
			} else if orVal == maxOrVal {
				count++
			}
			return
		}
		dfs(idx+1, orVal|nums[idx])
		dfs(idx+1, orVal)
	}
	dfs(0, 0)
	return count
}
```

# 2022/3/16

> 莫道桑榆晚，为霞尚满天

## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

### 辅助栈

```go
type MinStack struct {
	stack    []int
	minStack []int
}

func Constructor() MinStack {
	return MinStack{
		stack:    []int{},
		minStack: []int{math.MaxInt32},
	}
}

func min(x int, y int) int {
	if x < y {
		return x
	}
	return y
}

func (this *MinStack) Push(val int) {
	this.stack = append(this.stack, val)
	curMin := this.minStack[len(this.minStack)-1]
	this.minStack = append(this.minStack, min(curMin, val))
}

func (this *MinStack) Pop() {
	this.stack = this.stack[:len(this.stack)-1]
	this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
	return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
	return this.minStack[len(this.minStack)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```

## [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)

请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。

实现 `AllOne` 类：

- `AllOne()` 初始化数据结构的对象。
- `inc(String key)` 字符串 `key` 的计数增加 `1` 。如果数据结构中尚不存在 `key` ，那么插入计数为 `1` 的 `key` 。
- `dec(String key)` 字符串 `key` 的计数减少 `1` 。如果 `key` 的计数在减少后为 `0` ，那么需要将这个 `key` 从数据结构中删除。测试用例保证：在减少计数前，`key` 存在于数据结构中。
- `getMaxKey()` 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 `""` 。
- `getMinKey()` 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 `""` 。

**示例**

```
输入
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
输出
[null, null, null, "hello", "hello", null, "hello", "leet"]

解释
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "hello"
allOne.inc("leet");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "leet"
```

### 哈希表 + 双向链表

> 使用哈希表对字符串进行计数
>
> 使用双向链表进行最大值最小值的获取



==java==

```java
class AllOne {
    Node head, tail;
    Map<String, Node> map;
    int count;
    public AllOne() {
        head = new Node("head");
        tail = new Node("tail");
        head.next = tail;
        tail.prev = head;
        map = new HashMap<>();
        count = 0;
    }
    public void inc(String key) {
        if (!map.containsKey(key)) {
            count++;
            Node node = new Node(key, 1);
            map.put(key, node);
            head.next.prev = node;
            node.next = head.next;
            head.next = node;
            node.prev = head;
        } else {
            Node node = map.get(key);
            node.count++;
            Node next = node.next;
            while (next != null && next != tail) {
                if (next.count < node.count) {
                    replace(node, next);
                } else {
                    break;
                }
                next = next.next.next;
            }
        }
    }
    public void dec(String key) {
        if (!map.containsKey(key)) {
            throw new RuntimeException("不存在的key：" + key);
        }
        Node node = map.get(key);
        if (node.count == 1) {
            count--;
            map.remove(key);
            node.prev.next = node.next;
            node.next.prev = node.prev;
        } else {
            node.count--;
            Node prev = node.prev;
            while (prev != null && prev != head) {
                if (prev.count > node.count) {
                    replace(prev, node);
                }
                prev = prev.prev.prev;
            }
        }
    }
    public String getMaxKey() {
        if (count == 0) {
            return "";
        }
        return tail.prev.key;
    }
    public String getMinKey() {
        if (count == 0) {
            return "";
        }
        return head.next.key;
    }
    private void replace(Node node, Node next) {
        node.prev.next = next;
        next.prev = node.prev;
        node.prev = next;
        node.next = next.next;
        next.next.prev = node;
        next.next = node;
    }
}
class Node {
    String key;
    Node prev;
    Node next;
    int count;
    public Node(String s) {
        this.key = s;
    }
    public Node(String key, int count) {
        this.key = key;
        this.count = count;
    }
}
```

==go==

```go
type Node struct {
	key   string
	count int
	prev  *Node
	next  *Node
}

type AllOne struct {
	head  *Node
	tail  *Node
	set   map[string]*Node
	count int
}

func Constructor() AllOne {
	one := AllOne{
		head:  &Node{key: "head", count: 0, prev: nil, next: nil},
		tail:  &Node{key: "tail", count: 0, prev: nil, next: nil},
		count: 0,
		set:   map[string]*Node{},
	}
	one.head.next = one.tail
	one.tail.prev = one.head
	return one
}

func (this *AllOne) Inc(key string) {
	if _, ok := this.set[key]; !ok {
		this.count++
		node := &Node{key: key, count: 1}
		this.set[key] = node
		this.head.next.prev = node
		node.next = this.head.next
		this.head.next = node
		node.prev = this.head
	} else {
		node := this.set[key]
		node.count++
		next := node.next
		for next != nil && next != this.tail {
			if next.count < node.count {
				replace(node, next)
			} else {
				break
			}
			next = next.next.next
		}
	}
}

func (this *AllOne) Dec(key string) {
	node := this.set[key]
	if node.count == 1 {
		this.count--
		delete(this.set, key)
		node.prev.next = node.next
		node.next.prev = node.prev
	} else {
		node.count--
		prev := node.prev
		for prev != nil && prev != this.head {
			if prev.count > node.count {
				replace(prev, node)
			}
			prev = prev.prev
		}
	}
}

func (this *AllOne) GetMaxKey() string {
	if this.count == 0 {
		return ""
	}
	return this.tail.prev.key
}

func (this *AllOne) GetMinKey() string {
	if this.count == 0 {
		return ""
	}
	return this.head.next.key
}

func replace(node *Node, next *Node) {
	node.prev.next = next
	next.prev = node.prev
	node.prev = next
	node.next = next.next
	next.next.prev = node
	next.next = node
}

/**
 * Your AllOne object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Inc(key);
 * obj.Dec(key);
 * param_3 := obj.GetMaxKey();
 * param_4 := obj.GetMinKey();
 */
```

# 2022/3/17

## [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 x 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 ans 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

**示例 2**

```
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

### 单调栈

==java==

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Stack<Integer> stack = new Stack<>();
        Map<Integer, Integer> map = new HashMap<>();
        int len = nums2.length;
        for (int i = len - 1; i >= 0; i--) {
            int num = nums2[i];
            while (!stack.isEmpty() && stack.peek() <= num) {
                stack.pop();
            }
            map.put(num, stack.isEmpty() ? -1 : stack.peek());
            stack.push(num);
        }
        int length = nums1.length;
        int[] ans = new int[length];
        for (int i = 0; i < length; i++) {
            ans[i] = map.get(nums1[i]);
        }
        return ans;
    }
}
```

==go==

```go
// 单调栈
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	stack := []int{}
	set := map[int]int{}
	n := len(nums2)
	for i := n - 1; i >= 0; i-- {
		num := nums2[i]
		for len(stack) > 0 && stack[len(stack)-1] <= num {
			stack = stack[:len(stack)-1]
		}
		if len(stack) > 0 {
			set[num] = stack[len(stack)-1]
		} else {
			set[num] = -1
		}
		stack = append(stack, num)
	}
	ans := make([]int, len(nums1))
	for i, num := range nums1 {
		ans[i] = set[num]
	}
	return ans
}
```

## [720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)

给出一个字符串数组 `words` 组成的一本英语词典。返回 `words` 中最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。

若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

**示例 1**

```
输入：words = ["w","wo","wor","worl", "world"]
输出："world"
解释： 单词"world"可由"w", "wo", "wor", 和 "worl"逐步添加一个字母组成。
```

**示例 2**

```
输入：words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出："apple"
解释："apply" 和 "apple" 都能由词典中的单词组成。但是 "apple" 的字典序小于 "apply" 
```

### 哈希表

==go==

```go
func longestWord(words []string) string {
	sort.Slice(words, func(i, j int) bool {
		s, t := words[i], words[j]
		return len(s) < len(t) || (len(s) == len(t) && s < t)
	})
	mp := map[string]bool{}
	maxStr := ""
	mp[maxStr] = true
	for _, word := range words {
		if mp[word[:len(word)-1]] {
			mp[word] = true
			if len(word) > len(maxStr) {
				maxStr = word
			}
		}
	}
	return maxStr
}

```

### 字典树

==java==

```java
class Trie {
    boolean isEnd;
    Trie[] children;
    public Trie() {
        this.isEnd = false;
        this.children = new Trie[26];
    }
    public void insert(String word) {
        Trie node = this;
        for (char ch : word.toCharArray()) {
            ch -= 'a';
            if (node.children[ch] == null) {
                node.children[ch] = new Trie();
            }
            node = node.children[ch];
        }
        node.isEnd = true;
    }
    public boolean search(String word) {
        Trie node = this;
        for (char ch : word.toCharArray()) {
            ch -= 'a';
            if (node.children[ch] == null || !node.children[ch].isEnd) {
                return false;
            }
            node = node.children[ch];
        }
        return true;
    }
}
class Solution {
    public String longestWord(String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }
        String maxStr = "";
        for (String word : words) {
            if (trie.search(word)) {
                if (word.length() > maxStr.length() || (word.length() == maxStr.length() && word.compareTo(maxStr) < 0)) {
                    maxStr = word;
                }
            }
        }
        return maxStr;
    }
}
```

==go==

```go
type Trie struct {
	isEnd    bool
	children [26]*Trie
}

func (t *Trie) insert(word string) {
	node := t
	for _, ch := range word {
		ch -= 'a'
		if node.children[ch] == nil {
			node.children[ch] = &Trie{}
		}
		node = node.children[ch]
	}
	node.isEnd = true
}

func (t *Trie) search(word string) bool {
	node := t
	for _, ch := range word {
		ch -= 'a'
		if node.children[ch] == nil || !node.children[ch].isEnd {
			return false
		}
		node = node.children[ch]
	}
	return true
}

func longestWord(words []string) string {
	t := &Trie{}
	ans := ""
	for _, word := range words {
		t.insert(word)
	}
	for _, word := range words {
		if t.search(word) && (len(word) > len(ans) || len(word) == len(ans) && word < ans) {
			ans = word
		}
	}
	return ans
}
```

# 2022/3/18

> 读书不觉已春深,一寸光阴一寸金

## [481. 神奇字符串](https://leetcode-cn.com/problems/magical-string/)

神奇字符串 `s` 仅由 `'1'` 和 `'2'` 组成，并需要遵守下面的规则：

- 神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。

s 的前几个元素是 s = `"1221121221221121122……"` 。如果将 `s` 中连续的若干 `1` 和 `2` 进行分组，可以得到 `"1 22 11 2 1 22 1 22 11 2 11 22 ......"` 。每组中 1 或者 2 的出现次数分别是 `"1 2 2 1 1 2 1 2 2 1 2 2 ......"` 。上面的出现次数正是 `s` 自身。

给你一个整数 `n` ，返回在神奇字符串 `s` 的前 `n` 个数字中 `1` 的数目。

**示例 1**

```
输入：n = 6
输出：3
解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 
```

**示例 2**

```
输入：n = 1
输出：1
```

### 模拟

==go==

```go
func magicalString(n int) int {
	if n == 0 {
		return 0
	}
	s := make([]byte, 0, n+2)
	s = append(s, '1', '2', '2')
	next := 2
	ans := 1
	for i := 2; i < n; i++ {
		if s[i] == '1' {
			ans++
			if s[next] == '2' {
				s = append(s, '1')
			} else {
				s = append(s, '2')
			}
		} else {
			if s[next] == '2' {
				s = append(s, '1', '1')
			} else {
				s = append(s, '2', '2')
			}
			next++
		}
		next++
	}
	return ans
}
```

==java==

```java
class Solution {
    public int magicalString(int n) {
        if (n == 0) return 0;
        StringBuilder builder = new StringBuilder("122");
        int ans = 1;
        int next = 2;
        for (int i = 2; i < n; i++) {
            if (builder.charAt(i) == '1') {
                ans++;
                if (builder.charAt(next) == '1') {
                    builder.append("2");
                } else {
                    builder.append("1");
                }
            } else {
                if (builder.charAt(next) == '1') {
                    builder.append("22");
                } else {
                    builder.append("11");
                }
                next++;
            }
            next++;
        }
        return ans;
    }
}
```

## [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；

- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

**示例**

```
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```

### 大顶堆

==java==

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> queue = new PriorityQueue<>((o1, o2) -> o2 - o1);
        for (int stone : stones) {
            queue.offer(stone);
        }
        while (queue.size() > 1) {
            int x = queue.poll();
            int y = queue.poll();
            if (x != y) {
                queue.offer(Math.abs(x - y));
            }
        }
        return queue.isEmpty() ? 0 : queue.poll();
    }
}
```

==go==

```go
type hp struct {
	sort.IntSlice
}

func (h hp) Less(i, j int) bool {
	return h.IntSlice[i] > h.IntSlice[j]
}

func (h *hp) Push(v interface{}) {
	// 类型断言，用来进行类型转换
	h.IntSlice = append(h.IntSlice, v.(int))
}

func (h *hp) Pop() interface{} {
	a := h.IntSlice
	v := a[len(a)-1]
	h.IntSlice = a[:len(a)-1]
	return v
}

func (h *hp) push(v int) {
	heap.Push(h, v)
}

func (h *hp) pop() int {
	return heap.Pop(h).(int)
}
func lastStoneWeight(stones []int) int {
	q := &hp{stones}
	heap.Init(q)
	for q.Len() > 1 {
		x := q.pop()
		y := q.pop()
		if x > y {
			q.push(x - y)
		}
	}
	if q.Len() > 0 {
		return q.pop()
	}
	return 0
}

```

# 2022/3/19

>夜色难免微凉，前行必有曙光......

## [2043. 简易银行系统](https://leetcode-cn.com/problems/simple-bank-system/)

你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 `n` 个账户，编号从 `1` 到 `n` 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 `balance` 中，其中第 `(i + 1)` 个账户的初始余额是 `balance[i]` 。

请你执行所有 **有效的** 交易。如果满足下面全部条件，则交易 **有效** ：

- 指定的账户数量在 `1` 和 `n` 之间，且
- 取款或者转账需要的钱的总数 **小于或者等于** 账户余额。

实现 `Bank` 类：

- `Bank(long[] balance)` 使用下标从 **0** 开始的整数数组 `balance` 初始化该对象。

- `boolean transfer(int account1, int account2, long money)` 从编号为 `account1` 的账户向编号为`account2` 的账户转帐 `money` 美元。如果交易成功，返回 `true` ，否则，返回 `false` 。

- `boolean deposit(int account, long money)` 向编号为 `account` 的账户存款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。

- `boolean withdraw(int account, long money)` 从编号为 `account` 的账户取款 `money` 美元。如果交易成功，返回 `true` ；否则，返回 `false` 。

**示例**

```	
输入：
["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]
输出：
[null, true, true, true, false, false]

解释：
Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。
                         // 账户 3 余额为 $20 - $10 = $10 。
bank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。
                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。
bank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。
                         // 账户 5 的余额为 $10 + $20 = $30 。
bank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。
                         // 所以无法转账 $15 。
bank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。
```

### 模拟

==java==

```java
class Bank {
    long[] balance;
    public Bank(long[] balance) {
        this.balance = balance;
    }
    public boolean transfer(int account1, int account2, long money) {
        if (!isValid(account1) || !isValid(account2)) {
            return false;
        }
        long balance1 = balance[account1 - 1];
        if (balance1 < money) {
            return false;
        }
        balance[account1 - 1] -= money;
        balance[account2 - 1] += money;
        return true;
    }
    public boolean deposit(int account, long money) {
        if (!isValid(account)) return false;
        balance[account - 1] += money;
        return true;
    }
    public boolean withdraw(int account, long money) {
        if (!isValid(account)) return false;
        if (balance[account - 1] < money) {
            return false;
        }
        balance[account - 1] -= money;
        return true;
    }
    public boolean isValid(int account) {
        return balance != null && balance.length > 0 && account > 0 && account <= balance.length;
    }
}

/**
 * Your Bank object will be instantiated and called as such:
 * Bank obj = new Bank(balance);
 * boolean param_1 = obj.transfer(account1,account2,money);
 * boolean param_2 = obj.deposit(account,money);
 * boolean param_3 = obj.withdraw(account,money);
 */
```

==go==

```golang
type Bank struct {
	balance []int64
}

func Constructor(balance []int64) Bank {
	return Bank{balance: balance}
}

func (this *Bank) Transfer(account1 int, account2 int, money int64) bool {
	if !this.isValid(account1) || !this.isValid(account2) {
		return false
	}
	balance1 := this.balance[account1-1]
	if balance1 < money {
		return false
	}
	this.balance[account1-1] -= money
	this.balance[account2-1] += money
	return true
}

func (this *Bank) Deposit(account int, money int64) bool {
	if !this.isValid(account) {
		return false
	}
	this.balance[account-1] += money
	return true
}

func (this *Bank) Withdraw(account int, money int64) bool {
	if !this.isValid(account) {
		return false
	}
	if this.balance[account-1] < money {
		return false
	}
	this.balance[account-1] -= money
	return true
}

func (this *Bank) isValid(account int) bool {
	return len(this.balance) > 0 && account > 0 && account <= len(this.balance)
}

/**
 * Your Bank object will be instantiated and called as such:
 * obj := Constructor(balance);
 * param_1 := obj.Transfer(account1,account2,money);
 * param_2 := obj.Deposit(account,money);
 * param_3 := obj.Withdraw(account,money);
 */
```



## [剑指 Offer II 088. 爬楼梯的最少成本](https://leetcode-cn.com/problems/GzCJIP/)

数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 `0` 开始）。

每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。

请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

**示例 1**

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

**示例 2**

```
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```

### 动态规划

==go==

```golang
func minCostClimbingStairs(cost []int) int {
	n := len(cost)
	dp := make([]int, n+1)
	dp[0] = 0
	dp[1] = 0
	for i := 2; i <= n; i++ {
		dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
	}
	return dp[n]
}

func min(x, y int) int {
	if x < y {
		return x
	} else {
		return y
	}
}
```

==java==

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2]  + cost[i - 2]);
        }
        return dp[n];
    }
}
```

## [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

**示例 1**

```
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: "1(2(4))(3)"

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
```

**示例 2**

```
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: "1(2()(4))(3)"

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
```

### 递归

==java==

```java
class Solution {
    public String tree2str(TreeNode root) {
        StringBuilder builder = new StringBuilder();
        if (root == null) return "";
        builder.append(root.val);
        if (root.left != null || root.right != null) {
            builder.append("(");
            builder.append(tree2str(root.left));
            builder.append(")");
        }
        if (root.right != null) {
            builder.append("(");
            builder.append(tree2str(root.right));
            builder.append(")");
        }
        return builder.toString();
    }
}
```

==go==

```golang
func tree2str(root *TreeNode) string {
	if root == nil {
		return ""
	}
	if root.Left == nil && root.Right == nil {
		return strconv.Itoa(root.Val)
	}
	if root.Right == nil {
		return fmt.Sprintf("%d(%s)", root.Val, tree2str(root.Left))
	}
	return fmt.Sprintf("%d(%s)(%s)", root.Val, tree2str(root.Left), tree2str(root.Right))
}
```

# 2022/3/20

> 须知少年凌云志，曾许人间第一流

## [771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

 给你一个字符串 `jewels` 代表石头中宝石的类型，另有一个字符串 `stones` 代表你拥有的石头。 `stones` 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

字母区分大小写，因此 `"a"` 和 `"A"` 是不同类型的石头。

**示例 1**

```
输入：jewels = "aA", stones = "aAAbbbb"
输出：3
```

**示例 2**

```
输入：jewels = "z", stones = "ZZ"
输出：0
```

### 哈希

==go==

```golang
func numJewelsInStones(jewels string, stones string) int {
	set := make(map[byte]bool)
	for i := range jewels {
		set[jewels[i]] = true
	}
	ans := 0
	for i := range stones {
		if set[stones[i]] {
			ans++
		}
	}
	return ans
}
```

==java==

```java
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        HashSet<Character> set = new HashSet<>();
        for (char ch : jewels.toCharArray()) {
            set.add(ch);
        }
        int ans = 0;
        for (char ch : stones.toCharArray()) {
            if (set.contains(ch)) {
                ans++;
            }
        }
        return ans;
    }
}
```

## [2039. 网络空闲的时刻](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/)

给你一个有 `n` 个服务器的计算机网络，服务器编号为 `0` 到 `n - 1` 。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ui, vi]` 表示服务器 `ui` 和 `vi` 之间有一条信息线路，在 **一秒** 内它们之间可以传输 **任意** 数目的信息。再给你一个长度为 `n` 且下标从 **0** 开始的整数数组 `patience` 。

题目保证所有服务器都是 **相通** 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。

编号为 `0` 的服务器是 **主** 服务器，其他服务器为 **数据** 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 **最优** 线路传输，也就是说每个信息都会以 **最少时间** 到达主服务器。主服务器会处理 **所有** 新到达的信息并 **立即** 按照每条信息来时的路线 **反方向** 发送回复信息。

在 `0` 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 `1` 秒开始，**每** 一秒最 **开始** 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：

- 如果还没收到任何回复信息，那么该服务器会周期性 **重发** 信息。数据服务器 `i` 每 `patience[i]` 秒都都会重发一条信息，也就是说，数据服务器 `i` 在上一次发送信息给主服务器后的 `patience[i]` 秒 **后** 会重发一条信息给主服务器。

- 否则，该数据服务器 **不会重发** 信息。

当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 **空闲** 状态。

请返回计算机网络变为 **空闲** 状态的 **最早秒数** 。

**示例 1**

![example 1](https://gitee.com/zhang-songyao/blog-images/raw/master/20220320163933.png)

```
输入：edges = [[0,1],[1,2]], patience = [0,2,1]
输出：8
解释：
0 秒最开始时，
- 数据服务器 1 给主服务器发出信息（用 1A 表示）。
- 数据服务器 2 给主服务器发出信息（用 2A 表示）。

1 秒时，
- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。
- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 < patience[1] = 2），所以不会重发信息。
- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。

2 秒时，
- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。
- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。
- 服务器 2 重发一条信息（用 2C 表示）。
...
4 秒时，
- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。
...
7 秒时，回复信息 2D 到达服务器 2 。

从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。
所以第 8 秒是网络变空闲的最早时刻。
```

**示例 2**

![example 2](https://gitee.com/zhang-songyao/blog-images/raw/master/20220320163954.png)

```
输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
输出：3
解释：数据服务器 1 和 2 第 2 秒初收到回复信息。
从第 3 秒开始，网络变空闲。
```

### 自己的做法

> 广度优先遍历 + 时间计算

```java
class Solution {
    public int networkBecomesIdle(int[][] edges, int[] patience) {
        int n = patience.length;
        int[] minTimePath = new int[n];
        List<Integer>[] gaps = new List[n];
        for (int i = 0; i < n; i++) {
            gaps[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            gaps[edge[0]].add(edge[1]);
            gaps[edge[1]].add(edge[0]);
        }
        bfs(gaps, minTimePath);
        return competeTime(minTimePath, patience);
    }
    private int competeTime(int[] minTimePath, int[] patience) {
        int max = 0;
        int n = patience.length;
        for (int i = 1; i < n; i++) {
            int time = minTimePath[i] * 2;
            if (time < patience[i]) {
                max = Math.max(max, time + 1);
                continue;
            }
            // 最大空闲时间 = 最后一次发送时间 + 一次来回的时间
            // 总共发送次数 0秒的不算
            int nums = time / patience[i] - 1;
            nums = nums + (time % patience[i] == 0 ? 0 : 1);
            // 最后一次发送的时间
            int tailTime = nums * patience[i];
            // 最大空闲时间
            int maxFreeTime = tailTime + time;
            max = Math.max(max, maxFreeTime + 1);
        }
        return max;
    }
    private void bfs(List<Integer>[] gaps, int[] minTimePath) {
        int n = minTimePath.length;
        boolean[] visit = new boolean[n];
        visit[0] = true;
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        int step = 1;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                for (int next : gaps[cur]) {
                    if (visit[next]) {
                        continue;
                    }
                    queue.offer(next);
                    visit[next] = true;
                    minTimePath[next] = step;
                }
            }
            step++;
        }
    }
}
```

### 官方题解

==java==

```java
class Solution {
    public int networkBecomesIdle(int[][] edges, int[] patience) {
        int n = patience.length;
        List<Integer>[] lists = new List[n];
        for (int i = 0; i < n; i++) {
            lists[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            lists[edge[0]].add(edge[1]);
            lists[edge[1]].add(edge[0]);
        }
        int step = 1;
        int max = 0;
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visit = new boolean[n];
        queue.offer(0);
        visit[0] = true;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                for (int next : lists[cur]) {
                    if (visit[next]) {
                        continue;
                    }
                    queue.offer(next);
                    visit[next] = true;
                    // 最后一次发送的时间
                    int tailTime = patience[next] * ((2 * step - 1) / patience[next]);
                    // 总时间
                    int time = tailTime + 2 * step + 1;
                    max = Math.max(max, time);
                }
            }
            step++;
        }
        return max;
    }
```

==go==

```go
func networkBecomesIdle(edges [][]int, patience []int) int {
	n := len(patience)
	lists := make([][]int, n)
	for _, edge := range edges {
		x, y := edge[0], edge[1]
		lists[x] = append(lists[x], y)
		lists[y] = append(lists[y], x)
	}
	visit := make([]bool, n)
	queue := []int{0}
	visit[0] = true
	ans := 0
	for dist := 1; queue != nil; dist++ {
		tmp := queue
		queue = nil
		for _, cur := range tmp {
			for _, next := range lists[cur] {
				if visit[next] {
					continue
				}
				visit[next] = true
				queue = append(queue, next)
				ans = max(ans, (dist*2-1)/patience[next]*patience[next]+dist*2+1)
			}
		}
	}
	return ans
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

# 2022/3/21

## [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)	

给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

**示例 1**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220321141719.jpeg)

```
输入: root = [5,3,6,2,4,null,7], k = 9
输出: true
```

**示例 2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220321141739.jpeg)

```
输入: root = [5,3,6,2,4,null,7], k = 28
输出: false
```

### 自己的做法

> dfs + 哈希

==java==

```java
class Solution {
    HashSet<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (!set.add(root.val)) {
            return true;
        }
        set.add(k - root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}
```

> bfs + 哈希

==go==

```go
func findTarget(root *TreeNode, k int) bool {
	if root == nil {
		return false
	}
	mp := make(map[int]bool)
	q := []*TreeNode{root}
	for q != nil {
		tmp := q
		q = nil
		for _, cur := range tmp {
			if mp[cur.Val] {
				return true
			}
			mp[k-cur.Val] = true
			if cur.Left != nil {
				q = append(q, cur.Left)
			}
			if cur.Right != nil {
				q = append(q, cur.Right)
			}
		}
	}
	return false
}
```

# 2022/3/22

> 知我者谓我心忧，不知我者谓我何求

## [面试题 05.01. 插入](https://leetcode-cn.com/problems/insert-into-bits-lcci/)

给定两个整型数字 `N` 与 `M`，以及表示比特位置的 `i` 与 `j`（`i <= j`，且从 0 位开始计算）。

编写一种方法，使 `M` 对应的二进制数字插入 `N` 对应的二进制数字的第 `i ~ j` 位区域，不足之处用 `0` 补

![img](https://pic.leetcode-cn.com/1610104070-NuLVQi-05.01.gif)

题目保证从 `i` 位到 `j` 位足以容纳 `M`， 例如： `M = 10011`，则 `i～j` 区域至少可容纳 5 位。

**示例1**

``` 
 输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6
 输出：N = 1100(10001001100)
```

**示例2**

```
 输入： N = 0, M = 31(11111), i = 0, j = 4
 输出：N = 31(11111)
```

==go==

```golang
func insertBits(N int, M int, i int, j int) int {
	// 将M左移i位准备插入
	M <<= i
	// 将N的i-j位置零
	for ; i <= j; i++ {
		num := 1 << i
		if num&N != 0 {
			N ^= num
		}
	}
	return N | M
}
```

==java==

```java
class Solution {
    public int insertBits(int N, int M, int i, int j) {
        M <<= i;
        while (i <= j) {
            int num = 1 << i;
            if ((num & N) != 0) {
                N ^= num;
            }
            i++;
        }
        return N | M;
    }
}
```

## [2038. 如果相邻两个颜色均相同则删除当前颜色](https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/)

总共有 `n` 个颜色片段排成一列，每个颜色片段要么是 `'A'` 要么是 `'B'` 。给你一个长度为 `n` 的字符串 `colors` ，其中 `colors[i]` 表示第 `i` 个颜色片段的颜色。

Alice 和 Bob 在玩一个游戏，他们 **轮流** 从这个字符串中删除颜色。Alice **先手** 。

- 如果一个颜色片段为 `'A'` 且 **相邻两个颜色** 都是颜色 `'A'` ，那么 Alice 可以删除该颜色片段。Alice **不可以** 删除任何颜色 `'B'` 片段。
- 如果一个颜色片段为 `'B'` 且 **相邻两个颜色** 都是颜色 `'B'` ，那么 Bob 可以删除该颜色片段。Bob **不可以** 删除任何颜色 `'A'` 片段。
- Alice 和 Bob **不能** 从字符串两端删除颜色片段。
- 如果其中一人无法继续操作，则该玩家 **输** 掉游戏且另一玩家 **获胜** 。

假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 `true`，否则 Bob 获胜，返回 `false`。

**示例 1**

```输入：colors = "AAABABB"
输出：true
解释：
AAABABB -> AABABB
Alice 先操作。
她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。

现在轮到 Bob 操作。
Bob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。
因此，Alice 获胜，返回 true 。
```

**示例 2**

```
输入：colors = "AA"
输出：false
解释：
Alice 先操作。
只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。
因此，Bob 获胜，返回 false 。
```

### 贪心

> 统计L(L >= 3)个A或者B，则Alice或者Bob可以删除的次数为(L - 2)，而不能删除两边的 2边的

==java==

```java
class Solution {
    public boolean winnerOfGame(String colors) {
        int[] sum = {0, 0};
        char tmp = 'C';
        int cnt = 0;
        for (int i = 0; i < colors.length(); i++) {
            char c = colors.charAt(i);
            if (c != tmp) {
                tmp = c;
                cnt = 1;
            } else {
                cnt++;
                if (cnt >= 3) {
                    sum[c - 'A']++;
                }
            }
        }
        return sum[0] > sum[1];
    }
}
```

==go==

```golang
func winnerOfGame(colors string) bool {
	sum := []int{0, 0}
	tmp := 'C'
	cnt := 0
	for _, ch := range colors {
		if ch != tmp {
			tmp = ch
			cnt = 1
		} else {
			cnt++
			if cnt >= 3 {
				sum[ch-'A']++
			}
		}
	}
	return sum[0] > sum[1]
}
```

## [剑指 Offer II 051. 节点之和最大的路径](https://leetcode-cn.com/problems/jC7MId/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给定一个二叉树的根节点 `root` ，返回其 **最大路径和**，即所有路径上节点值之和的最大值。

**示例 1**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220322164422.jpeg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220322171154.jpeg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

### 递归

==go==

```golang
func maxPathSum(root *TreeNode) int {
	var dfs func(root *TreeNode) int
	res := root.Val
	dfs = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		maxLeft := max(0, dfs(node.Left))
		maxRight := max(0, dfs(node.Right))
		res = max(res, node.Val+maxLeft+maxRight)
		return node.Val + max(maxLeft, maxRight)
	}
	dfs(root)
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

==java==

```java
class Solution {
    int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return res;
    }
    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int maxLeft = Math.max(0, dfs(node.left));
        int maxRight = Math.max(0, dfs(node.right));
        res = Math.max(res, node.val + maxLeft + maxRight);
        return node.val + Math.max(maxLeft, maxRight);
    }
}
```

# 2022/3/23

## [剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

给定一个链表的 **头节点** `head` **，**请判断其是否为回文链表。

如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。

**示例 1**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220322165251.png)

```
输入: head = [1,2,3,3,2,1]
输出: true
```



**示例 2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220322165249.png)

```
输入: head = [1,2]
输出: false
```

==go==

```golang
func isPalindrome(head *ListNode) bool {
	nums := []int{}
	for tmp := head; tmp != nil; tmp = tmp.Next {
		nums = append(nums, tmp.Val)
	}
	n := len(nums)
	for i := 0; i < n/2; i++ {
		if nums[i] != nums[n-i-1] {
			return false
		}
	}
	return true
}
```

==java==

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while (head != null) {
            list.add(head.val);
            head = head.next;
        }
        for (int i = 0; i < list.size() / 2; i++) {
            if (list.get(i) != list.get(list.size() - 1 - i)) {
                return false;
            }
        }
        return true;
    }
}
```

# 2022/3/24

> 时间从来不说话，却回答了所有问题

## [661. 图片平滑器](https://leetcode-cn.com/problems/image-smoother/)

**图像平滑器** 是大小为 `3 x 3` 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的 **平均灰度** 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220324145549.jpeg)

给你一个表示图像灰度的 `m x n` 整数矩阵 `img` ，返回对图像的每个单元格平滑处理后的图像 。

**示例 1**

```
输入:img = [[1,1,1],[1,0,1],[1,1,1]]
输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
```

**示例 2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220324145624.jpeg)

```
输入: img = [[100,200,100],[200,50,200],[100,200,100]]
输出: [[137,141,137],[141,138,141],[137,141,137]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
```

### 模拟

==java==

```java
class Solution {
    int[][] dirs = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    public int[][] imageSmoother(int[][] img) {
        int m = img.length;
        int n = img[0].length;
        int[][] ans = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int sum = img[i][j];
                int count = 1;
                for (int[] dir : dirs) {
                    int x = i + dir[0];
                    int y = j + dir[1];
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        sum += img[x][y];
                        count++;
                    }
                }
                ans[i][j] = sum / count;
            }
        }
        return ans;
    }
}
```

## [667. 优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/)

给你两个整数 `n` 和 `k` ，请你构造一个答案列表 `answer` ，该列表应当包含从 `1` 到 `n` 的 `n` 个不同正整数，并同时满足下述条件：

- 假设该列表是 `answer = [a1, a2, a3, ... , an]` ，那么列表 `[|a1 - a2|, |a2 - a3|, |a3 - a4|,``... , |an-1 - an|]` 中应该有且仅有 `k` 个不同整数。

返回列表 `answer` 。如果存在多种答案，只需返回其中 **任意一种** 。

**示例 1**

```输入：n = 3, k = 1
输出：[1, 2, 3]
解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1	
```

**示例 2**

```
输入：n = 3, k = 2
输出：[1, 3, 2]
解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2
```

### 构造枚举

> 注意以下规律：

n = 5

当k = 1时 [`1`, 2, 3, 4, 5]， 剩余 2 3 4 5

当k = 2时 [`1, 5`, 4, 3, 2]， 剩余 4 3 2

当k = 3时 [`1, 5, 2`, 3, 4]， 剩余 3 4

当k = 4时 [`1, 5, 2, 4`, 3]， 剩余 3 

k从1每增大一次，数组剩余的数字倒序排列一次

==go==

*O(n)*

```go
func constructArray(n int, k int) []int {
	ans := make([]int, n)
	min, max := 1, n
	i := 0
	for ; i < k; i++ {
		if i%2 == 0 {
			ans[i] = min
			min++
		} else {
			ans[i] = max
			max--
		}
	}
	if i%2 == 0 {
		for ; i < n; i++ {
			ans[i] = max
			max--
		}
	} else {
		for ; i < n; i++ {
			ans[i] = min
			min++
		}
	}
	return ans
}
```

# 2022/3/25

> stay hungry, stay foolish

## [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`	

**示例 1**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

### 统计5的个数

n! 尾零的数量即为 n! 中因子 10 的个数，而 10=2×5，因此转换成求 n!中质因子 2 的个数和质因子 5 的个数的较小值。

由于质因子 5 的个数不会大于质因子 2 的个数，我们可以仅考虑质因子 5 的个数。

而 n!中质因子 5 的个数等于 [1,n]的每个数的质因子 5 的个数之和，我们可以通过遍历 [1,n] 的所有 5 的倍数求出。

```golang
func trailingZeroes(n int) (ans int) {
	for i := 5; i <= n; i++ {
		for x := i; x%5 == 0; x /= 5 {
			ans++
		}
	}
	return
}
```

### 优化计算

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220325152847.png" alt="image-20220325152844248" style="zoom:80%;" />

```go
func trailingZeroes(n int) (ans int) {
    for n > 0 {
        n /= 5
        ans += n
    }
    return
}
```

## [1601. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/)

我们有 `n` 栋楼，编号从 `0` 到 `n - 1` 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。

给你一个数组 `requests` ，其中 `requests[i] = [fromi, toi]` ，表示一个员工请求从编号为 `fromi` 的楼搬到编号为 `toi` 的楼。

一开始 **所有楼都是满的**，所以从请求列表中选出的若干个请求是可行的需要满足 **每栋楼员工净变化为 0** 。意思是每栋楼 **离开** 的员工数目 **等于** 该楼 **搬入** 的员工数数目。比方说 `n = 3` 且两个员工要离开楼 `0` ，一个员工要离开楼 `1` ，一个员工要离开楼 `2` ，如果该请求列表可行，应该要有两个员工搬入楼 `0` ，一个员工搬入楼 `1` ，一个员工搬入楼 `2` 。

请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。

**示例 1**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg" alt="img" style="zoom:80%;" />

```
输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
输出：5
解释：请求列表如下：
从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。
从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。
从楼 2 离开的员工为 z ，且他想要搬到楼 0 。
从楼 3 离开的员工为 c ，且他想要搬到楼 4 。
没有员工从楼 4 离开。
我们可以让 x 和 b 交换他们的楼，以满足他们的请求。
我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。
所以最多可以满足 5 个请求。
```

**示例 2**

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20220325162523.jpeg" alt="img" style="zoom:80%;" />

```
输入：n = 3, requests = [[0,0],[1,2],[2,1]]
输出：3
解释：请求列表如下：
从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。
从楼 1 离开的员工为 y ，且他想要搬到楼 2 。
从楼 2 离开的员工为 z ，且他想要搬到楼 1 。
我们可以满足所有的请求。
```

### 递归回溯

```go
func maximumRequests(n int, requests [][]int) (ans int) {
	delta := make([]int, n)
	var dfs func(pos int)
	cnt, zero := 0, n
	dfs = func(pos int) {
		if pos == len(requests) {
			if zero == n && cnt > ans {
				ans = cnt
			}
			return
		}
		// 不拿
		dfs(pos + 1)
		// 拿
		cnt++
		z := zero
		x, y := requests[pos][0], requests[pos][1]
		if delta[x] == 0 {
			zero--
		}
		delta[x]--
		if delta[x] == 0 {
			zero++
		}
		if delta[y] == 0 {
			zero--
		}
		delta[y]++
		if delta[y] == 0 {
			zero++
		}
		dfs(pos + 1)
		delta[x]++
		delta[y]--
		zero = z
		cnt--
	}
	dfs(0)
	return
}
```

### 二进制枚举

我们可以使用一个长度为 m 的二进制数 mask 表示所有的请求，其中 mask 从低到高的第 i位为 1 表示选择第 i 个请求，为 0 表示不选第 i 个请求。我们可以枚举 [0,2^m-1]范围内的所有mask，对于每个mask，依次枚举其每一位，判断是否为 1，并使用与方法一相同的数组 delta 以及变量 cnt 进行统计，在满足要求时更新答案。

```go
func maximumRequests(n int, requests [][]int) (ans int) {
next:
	for mask := 0; mask < 1<<len(requests); mask++ {
		count := bits.OnesCount(uint(mask))
		if ans >= count {
			continue
		}
		delta := make([]int, n)
		for i, r := range requests {
			if mask>>i&1 == 1 {
				delta[r[0]]--
				delta[r[1]]++
			}
		}
		for _, d := range delta {
			if d != 0 {
				continue next
			}
		}
		ans = count
	}
	return
}
```

# 2022/3/26

> 众人秋霖沾满身，我自漫步烟雨中

## [682. 棒球比赛](https://leetcode-cn.com/problems/baseball-game/)

你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 `ops`，其中 `ops[i]` 是你需要记录的第 `i` 项操作，`ops` 遵循下述规则：

1. 整数 `x` - 表示本回合新获得分数 `x`
2. `"+"` - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
3. `"D"` - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
4. `"C"` - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。

请你返回记录中所有得分的总和。

**示例 1**

```
输入：ops = ["5","2","C","D","+"]
输出：30
解释：
"5" - 记录加 5 ，记录现在是 [5]
"2" - 记录加 2 ，记录现在是 [5, 2]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
所有得分的总和 5 + 10 + 15 = 30
```

**示例 2**

```
输入：ops = ["5","-2","4","C","D","9","+","+"]
输出：27
解释：
"5" - 记录加 5 ，记录现在是 [5]
"-2" - 记录加 -2 ，记录现在是 [5, -2]
"4" - 记录加 4 ，记录现在是 [5, -2, 4]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
```

### 栈

```golang
func calPoints(ops []string) (ans int) {
	stack := []int{}
	for _, ch := range ops {
		switch ch {
		case "+":
			stack = append(stack, stack[len(stack)-1]+stack[len(stack)-2])
		case "D":
			stack = append(stack, stack[len(stack)-1]*2)
		case "C":
			stack = stack[:len(stack)-1]
		default:
			num, _ := strconv.Atoi(ch)
			stack = append(stack, num)
		}
	}
	for _, num := range stack {
		ans += num
	}
	return 
}
```

## [917. 仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)

给你一个字符串 `s` ，根据下述规则反转字符串：

- 所有非英文字母保留在原有位置。
- 所有英文字母（小写或大写）位置反转。

返回反转后的 `s` *。*

**示例 1**

```
输入：s = "ab-cd"
输出："dc-ba"
```

**示例 2**

```
输入：s = "a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
```

### 双指针

```golang
func reverseOnlyLetters(s string) string {
	bytes := []byte(s)
	l, r := 0, len(s)-1
	for l < r {
		for l < r && !unicode.IsLetter(rune(s[l])) {
			l++
		}
		for l < r && !unicode.IsLetter(rune(s[r])) {
			r--
		}
		bytes[l], bytes[r] = bytes[r], bytes[l]
		l++
		r--
	}
	return string(bytes)
}
```

## [1447. 最简分数](https://leetcode-cn.com/problems/simplified-fractions/)

给你一个整数 `n` ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 `n` 的 **最简** 分数 。分数可以以 **任意** 顺序返回。

**示例 1**

```
输入：n = 2
输出：["1/2"]
解释："1/2" 是唯一一个分母小于等于 2 的最简分数。
```

**示例 2**

```
输入：n = 3
输出：["1/2","1/3","2/3"]
```

### 欧几里得算法

> 计算最大公约数，如果为1，加入答案

```golang
func simplifiedFractions(n int) (ans []string) {
	for i := 1; i < n; i++ {
		for j := i + 1; j <= n; j++ {
			if gcd(i, j) == 1 {
				ans = append(ans, strconv.Itoa(i)+"/"+strconv.Itoa(j))
			}
		}
	}
	return
}

// 欧几里得算法
func gcd(a int, b int) int {
	if b == 0 {
		return a
	}
	return gcd(b, a%b)
}
```

# 2022/3/27

> Talk is cheap. Show me the code.

## [2028. 找出缺失的观测数据](https://leetcode-cn.com/problems/find-missing-observations/)

现有一份 `n + m` 次投掷单个 **六面** 骰子的观测数据，骰子的每个面从 `1` 到 `6` 编号。观测数据中缺失了 `n`份，你手上只拿到剩余 `m` 次投掷的数据。幸好你有之前计算过的这 `n + m` 次投掷数据的 **平均值** 。

给你一个长度为 `m` 的整数数组 `rolls` ，其中 `rolls[i]` 是第 `i` 次观测的值。同时给你两个整数 `mean` 和 `n` 。

返回一个长度为 `n` 的数组，包含所有缺失的观测数据，且满足这 `n + m` 次投掷的 **平均值** 是 `mean` 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。

`k` 个数字的 **平均值** 为这些数字求和后再除以 `k` 。

注意 `mean` 是一个整数，所以 `n + m` 次投掷的总和需要被 `n + m` 整除。

**示例 1**

```
输入：rolls = [3,2,4,3], mean = 4, n = 2
输出：[6,6]
解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。	
```

**示例 2**

```
输入：rolls = [1,5,6], mean = 3, n = 4
输出：[2,3,2,2]
解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。
```

### 模拟

```golang
func missingRolls(rolls []int, mean int, n int) []int {
	m := len(rolls)
	mean = (m + n) * mean
	for _, roll := range rolls {
		mean -= roll
	}
	if mean > n*6 || mean < n {
		return []int{}
	}
	ans := make([]int, n)
	num, mod := mean/n, mean%n
	for i := 0; i < n; i++ {
		ans[i] = num
		if i < mod {
			ans[i]++
		}
	}
	return ans
}
```

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

**示例 1**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220327155236.jpeg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2**

![img](https://gitee.com/zhang-songyao/blog-images/raw/master/20220327155249.jpeg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```



```golang
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
	if k == 1 {
		return head
	}
	curHead := &ListNode{-1, head}
	pre := curHead
	tmp := head
	tmk := k
	for tmp != nil {
		tmk--
		next := tmp.Next
		if tmk == 0 {
			tmk = k
			tmp.Next = nil
			tail := reverseListNode(pre)
			pre = tail
			tail.Next = next
		}
		tmp = next
	}
	return curHead.Next
}

func reverseListNode(node *ListNode) *ListNode {
	ans, tmp := node.Next, node.Next
	node.Next = nil
	for tmp != nil {
		next := tmp.Next
		tmp.Next = node.Next
		node.Next = tmp
		tmp = next
	}
	return ans
}
```

# 2022/5/7

> 最近太忙了，埋头学了很多东西，但是都没有总结输出，后面会陆续转向golang，会发一些golang相关的技术框架，如：grpc、go-micro、go-kafka、go-es、go-wire、goroutine、go-cron等等，keep learning....

## [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。

给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。

注意：起始基因序列 `start` 默认是有效的，但是它并不一定会出现在基因库中。

**示例 1**

```
输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
输出：1
```

**示例 2**

```
输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
输出：2
```

### 想法

嗯。。。很骚的是，他可以先改变别的字母在改变回来，比如AACCGGTT->AAACGGTA他可以这样做：AACCGGTT->AACCGATT->AACCGATA->AAACGATA->AAACGGTA，而不是我想的，只改变不同的字母。

所以将start放入队列中，为了防止和bank（如果bank非常大，那么时间复杂度会非常高`O(n*m*m)`，尽管题目bank最大只有10）里面的基因逐一比较，我选择修改start的每一个字母，基因变化一共有四种['A', 'T', 'C', 'G']，如果bank中存在修改过的基因，并且这个基因之前没有入过队列，那么将这个基因加入队列，广度优先遍历，如果队列中出现end，那么return即可

> 时间复杂度：`O(C*n*m)` C为4，n为基因长度，基因每次变换需要计算C*4次，m为bank的长度

```go
func minMutation(start string, end string, bank []string) int {
	mp := map[string]bool{}
	for _, b := range bank {
		mp[b] = true
	}
	factor := []byte{'A', 'T', 'C', 'G'}
	ans := 0
	queue := []string{start}
	mpQ := map[string]bool{}
	for len(queue) != 0 {
		n := len(queue)
		for i := 0; i < n; i++ {
			s := queue[0]
			if s == end {
				return ans
			}
			queue = queue[1:]
			for j := 0; j < len(s); j++ {
				tmp := []byte(s)
				for k := 0; k < len(factor); k++ {
					tmp[j] = factor[k]
					if mp[string(tmp)] && !(mpQ[string(tmp)]) {
						mpQ[string(tmp)] = true
						queue = append(queue, string(tmp))
					}
				}
			}
		}ans++
	}
	return -1
}
```

### 看看参考答案

> 方法类似，在广度优先遍历模板和对map的操作需要学习

```go
func minMutation(start, end string, bank []string) int {
    if start == end {
        return 0
    }
    bankSet := map[string]struct{}{}
    for _, s := range bank {
        bankSet[s] = struct{}{}
    }
    if _, ok := bankSet[end]; !ok {
        return -1
    }

    q := []string{start}
    for step := 0; q != nil; step++ {
        tmp := q
        q = nil
        for _, cur := range tmp {
            for i, x := range cur {
                for _, y := range "ACGT" {
                    if y != x {
                        nxt := cur[:i] + string(y) + cur[i+1:]
                        if _, ok := bankSet[nxt]; ok {
                            if nxt == end {
                                return step + 1
                            }
                            delete(bankSet, nxt)
                            q = append(q, nxt)
                        }
                    }
                }
            }
        }
    }
    return -1
}
```

### 根据参考答案优化空间

```go
func minMutation(start string, end string, bank []string) int {
	mp := map[string]bool{}
	for _, b := range bank {
		mp[b] = true
	}
	factor := []byte{'A', 'T', 'C', 'G'}
	ans := 0
	queue := []string{start}
	for len(queue) != 0 {
		n := len(queue)
		for i := 0; i < n; i++ {
			s := queue[0]
			if s == end {
				return ans
			}
			queue = queue[1:]
			for j := 0; j < len(s); j++ {
				tmp := []byte(s)
				for k := 0; k < len(factor); k++ {
					if tmp[j] != factor[k] {
						tmp[j] = factor[k]
						if mp[string(tmp)]{
							fmt.Println(string(tmp))
							delete(mp, string(tmp))
							queue = append(queue, string(tmp))
						}
					}
				}
			}
		}
		ans++
	}
	return -1
}
```

