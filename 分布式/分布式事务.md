[分布式事务](https://zhuanlan.zhihu.com/p/183753774)

> 分布式事务顾名思义就是要在分布式系统中实现事务，其实是有多个本地事务组合而成

## 2PC



2PC（Two-phase commit protocol），中文叫二阶段提交，二阶段提交是一种强一致性设计，2PC引入一个事务协调者的角色来协调管理各个参与者（也可称之为本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交阶段

- 准备阶段协调者会给各参与者发送准备命令，准备阶段除了提交事务之外的事都做
- 假设第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务提交成功之后，返回事务执行成功

![img](https://gitee.com/zhang-songyao/tripimages/raw/master/20210817102158.jpeg)

### 第一阶段失败

假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。

![img](https://gitee.com/zhang-songyao/tripimages/raw/master/20210817102223.jpeg)

### 第二阶段提交失败

第一种是**第二阶段执行的是回滚事务操作**，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。

第二种是**第二阶段执行的是提交事务操作**，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。

大体上二阶段提交的流程就是这样，**我们再来看看细节**。

首先 2PC 是一个**同步阻塞协议**，像第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的**协调者有超时机制**，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。

在第二阶段协调者的没法超时，因为按照我们上面分析只能不断重试！

### 协调者故障

**协调者是一个单点，存在单点故障问题**。

假设协调者在**发送准备命令之前**挂了，还行等于事务还没开始。

假设协调者在**发送准备命令之后**挂了，这就不太行了，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。

假设协调者在**发送回滚事务命令之前**挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。

假设协调者在**发送回滚事务命令之后**挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞着。

假设协调者在**发送提交事务命令之前**挂了，这个不行，傻了！这下是所有资源都阻塞着。

假设协调者在**发送提交事务命令之后**挂了，这个还行，也是至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。

> 协调者故障，通过选举得到新协调者

因为协调者单点问题，因此我们可以通过选举等操作选出一个新协调者来顶替。

如果处于第一阶段，其实影响不大，直接回滚，第一阶段，事务都没有提交

如果处于第二阶段，假设参与者都没有挂，姿势新协调者可以向所有参与者确认他们自身的情况来推断下一步操作

但是如果，个别参与者挂了，比如协调者发送了回滚命令，此时第一个参与者收到了并执行，然后协调者和第一个参与者都挂了。此时其他参与者都没收到请求，然后新协调者来了，它询问其他参与者都说OK，但它不知道挂了的那个参与者到底O不OK

问题其实就出在**每个参与者自身的状态只有自己和协调者知道**，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。

虽然协议上没说，不过在实现的时候我们可以灵活的让协调者将自己发过的请求在哪个地方记一下，也就是日志记录，这样新协调者来的时候不就知道此时该不该发了？

### 总结

2PC是一种尽量保证强一致性的分布式的事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险

## 3PC

3PC的出现是为了解决2PC的一些问题，相比于2PC，他在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一系统统一各自状态

3PC包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段

3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。

![img](https://gitee.com/zhang-songyao/tripimages/raw/master/20210817103742.jpeg)

### 三阶段

- 首先准备阶段的变更不会直接执行事务，而是会先去询问此事的参与者是否有条件接这个事务，因此不会直接锁住资源，使得在某些资源不可用的情况下所有参与者都阻塞者

- 预提交阶段的引入起到了一个统一的状态的作用，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。

假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。

但是多引入一个阶段也多一个交互，因此**性能会差一些**，而且**绝大部分的情况下资源应该都是可用的**，这样等于每次明知可用执行还得询问一次。

### 超时机制

参与者不会傻等，如果等待提交命令超时，那么参与者就会提交事务了，因为到了这一阶段大概率是提交的，如果等待预提交命令超时，那就该干啥干啥，反正没有加锁

### 总结

所以说3PC通过预提交阶段可以减少故障恢复时候的复杂性，但是不保证数据一致，除非挂了的参与者恢复

3PC对2PC做了一定改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂性降低，但整体的交互过程更长，性能下降，并且存在数据不一致性问题

> 所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。

## TCC

2PC和3PC都是数据库层面的，而TCC是业务层面的分布式事务，分布式事务不仅仅包括数据库的操作，还包括发送短信等

TCC 指的是`Try - Confirm - Cancel`。

- Try指的是预留，即资源的预留和锁定
- Confirm指的是确定操作，这一步其实是真正的执行
- Canel指的是撤销操作，可以理解为把预留阶段的动作撤销了

其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。

![img](https://gitee.com/zhang-songyao/tripimages/raw/master/20210817104924.jpeg)