# RabbitMQ基础

## MQ的基本概念

- 利用可靠的消息传递机制进行系统和系统直接的通讯	
- 通过提供消息传递和消息的排队机制，他可以在分布式系统环境下扩展进程间的通讯
  - 分布式系统通信的两种方式：
    - 直接远程调用
    - 借助第三方完成间接通信

### 应用场景

1. 跨系统数据传递
2. 高并发流量削峰
3. 数据的分发和异步处理
4. 大数据分析与传递
5. 分布式事务

### 为什么使用MQ？

- 异步处理：相比于传统的串行、并行方式，提高吞吐量
- 应用解耦：系统间通过消息通信，不用关心其他系统的处理
- 流量削峰：可以通过消息队列长度控制请求量；可以缓解短时间内高并发请求
- 日志处理：处理大量日志传输
- 消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现对点消息队列，或者聊天室

### 消息队列的优缺点

#### 优点

##### 解耦

> 允许独立扩展或者修改两边的处理过程，只要确保他们遵守同样的接口约束

> 一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦，但是其实这个调用是不需要直接同步调用接口的，如果用MQ给它异步化解耦

A系统发送数据到BCD三个系统，通过接口调用发送。如果E系统也需要这个数据呢？那如果 C 系统现在不需要了呢？A系统根其他各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要A系统将这个数据发送过来

如果使用MQ，A系统产生一条数据，发送到MQ里面去；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要跟谁发送数据，不需要维护这个代码是，也不需要考虑人家是否调用成功、失败超时等情况

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215004931.png" alt="image-20211215004925643" style="zoom: 80%;" />

##### 异步

> 不需要立即处理消息，消息队列提供了异步处理机制，允许用户把一个消息放入队列中，但不立即处理它，在需要的时候进行处理

A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要20ms，BCD三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 20 + 300 + 450 + 200 = 970ms，接近 1s。

如果使用MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 20 + 5 = 25ms。

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215004804.png" alt="image-20211215004800884" style="zoom:80%;" />

##### 削峰填谷

> 减少高峰时期对服务器压力

使用消息队列能够使关键组件顶住突发（突发流量并不常）的访问压力，而不会为突发的超负荷请求而完全崩溃

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215010315.png" alt="image-20211215010312075" style="zoom:80%;" />

##### 可恢复性

系统的一部分组件失效时，不会影响到整个系统。消息队列较低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列的消息任然可以在系统恢复后被处理

#### 缺点

- 系统可用性降低：如果消息队列挂了，系统就无法正常运行
- 系统复杂性提高：加入消息队列，要考虑更多的问题，比如：一致性问题、如何保证消息不被重复消费、如何把正确的消息的可靠传输等。因此考虑的东西增加，复杂性增加
- 一致性问题（分布式事务）：A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这数据就不一致了

> 小结

既然MQ有优势和劣势，那么使用MQ需要满足什么条件呢？

1. 生产者不需要从消费者出获得反馈。引入消息队列之前的直接调用，其接口返回值应该为空
2. 容许短暂的不一致性
3. 解耦、异步提速、削峰带来的收益，超过加入MQ，管理MQ的成本

### 消息中间件的核心组成部分

1. 消息的协议
2. 消息的持久化机制
3. 消息的分发策略
4. 消息的高可用，高可靠
5. 消息的容错机制

## 消息队列选择

### ActiveMQ

老牌的消息中间件，国内很多公司过去运用的非常广泛，功能强大，但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦

### RabbitMQ

好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用，支撑集群化、高可用部署架构、消息高可靠支持，功能较为完善。使用较为多

除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化

但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以

### RocketMQ

RocketMQ是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景

而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。

### Kafka

Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多，但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计

因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用  

## RabbitMQ简介

> 官网：https://www.rabbitmq.com/

 AMQP，2006年发布的，即Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不收客户端/中间件不同产品，不同开发语言等条件限制。

RabbitMQ是由erlang语言开发，2007年，Rabbit技术公司基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列RabbitMQ1.0，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛

### 基础架构

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215012900.png" alt="image-20211215012856578" style="zoom:80%;" />

- Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker
- Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange / queue 等
- Connection: publisher / consumer 和 broker之间的 TCP 连接
- Channel：如果每一次访问RabbitMQ 都建立一个Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection极大减少了操作系统建立 TCP connection 的开销
- Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到
  queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)
- Queue：消息最终被送到这里等待 consumer 取走 
- Binding：exchange 和 queue之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存
  到 exchange 中的查询表中，用于 message 的分发依据

> RabbitMQ的六种工作模式

- 简单模式
- work模式
- Publish/Subscribe发布与订阅模式
- Routing路由模式
- Topics主题模式
- RPC远程调用模式

<img src="https://gitee.com/zhang-songyao/blog-images/raw/master/20211215014855.png" alt="image-20211215014852868" style="zoom:80%;" />

### JMS

JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

#### AMQP和JMS区别

- JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式
- JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。
- JMS规定了两种消息模式；而AMQP的消息模式更加丰富

# RabbitMQ的安装与配置





## RabbitMQ入门程序

## RabbitMQ工作模式

## Spring整合RabbitMQ

# 高级



